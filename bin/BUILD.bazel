package(default_visibility = ["//visibility:public"])

load("//bzl:rules.bzl",
     "ocaml_compiler_r",
     "ocaml_compilers")

################################################################
## ocaml_compilers is a macro; it expands to: ocamlc_byte,
## ocamlopt_byte ocamlopt_opt, ocamlc_opt

ocaml_compilers(
    name = "ocamlcc",
    visibility             = ["//visibility:public"]
)

## to run the compilers directly from the cmd line:
sh_binary(
    name = "ocamlc.byte.sh",
    srcs = ["ocamlc.byte.shell"],
    env  = {"VERBOSE": "true"},
    data = [
        ":ocamlc.byte",
        "//runtime:ocamlrun",
        "//stdlib",
        "//stdlib:Std_exit",
        "//config/camlheaders",
    ],
    deps = [
         # for the runfiles lib used in ocamlc.sh:
        "@bazel_tools//tools/bash/runfiles"
    ]
)

sh_binary(
    name = "ocamlopt.byte.sh",
    srcs = ["ocamlopt.byte.shell"],
    env  = {"VERBOSE": "true",
            "DEVELOPER_DIR": "/Applications/Xcode.app/Contents/Developer",
            "SDKROOT": "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"},
    data = [
        ":ocamlopt.byte",
        "//runtime:asmrun",
        "//stdlib:stdlib.cmxa",
        "//stdlib:Std_exit.cmx",
        "//config/camlheaders",
        "@bazel_tools//tools/cpp:current_cc_toolchain"
    ],
    deps = [
         # for the runfiles lib used in ocamlc.sh:
        "@bazel_tools//tools/bash/runfiles"
    ],
    toolchains = ["@bazel_tools//tools/cpp:current_cc_toolchain"]
)

sh_binary(
    name = "ocamlopt.opt.sh",
    srcs = ["ocamlopt.opt.shell"],
    env  = {"VERBOSE": "true",
            "DEVELOPER_DIR": "/Applications/Xcode.app/Contents/Developer",
            "SDKROOT": "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"},
    data = [
        ":ocamlopt.opt",
        "//runtime:asmrun",
        "//config/camlheaders",
        "@bazel_tools//tools/cpp:current_cc_toolchain"
    ],
    deps = [
         # for the runfiles lib used in ocamlc.sh:
        "@bazel_tools//tools/bash/runfiles"
    ],
    toolchains = ["@bazel_tools//tools/cpp:current_cc_toolchain"]
)

sh_binary(
    name = "ocamlc.opt.sh",
    srcs = ["ocamlc.opt.shell"],
    env  = {"VERBOSE": "true",
            "DEVELOPER_DIR": "/Applications/Xcode.app/Contents/Developer",
            "SDKROOT": "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"},
    data = [
        ":ocamlc.opt",
        # "//runtime:asmrun",
        "//config/camlheaders",
        "@bazel_tools//tools/cpp:current_cc_toolchain"
    ],
    deps = [
         # for the runfiles lib used in ocamlc.sh:
        "@bazel_tools//tools/bash/runfiles"
    ],
    toolchains = ["@bazel_tools//tools/cpp:current_cc_toolchain"]
)

################################################################
## recursive builds. abandoned. they work, but at the cost of
## duplicated builds of some of the code.
ocaml_compiler_r(
    name = "ocamlcc_r",
    stdlib   = "//stdlib",
    prologue = ["//compilerlibs:ocamlcommon",
                ] + select({
        # "//config/target:baseline_vm?": ["//bytecomp:ocamlbytecomp"],
        # "//config/target:baseline_sys?": ["//asmcomp:ocamloptcomp"],
        # "//config/target:ult_sys?": ["//asmcomp:ocamloptcomp"],

        "//config/target/emitter:sys_emitter?": ["//asmcomp:ocamloptcomp"],

        "//conditions:default": ["//bytecomp:ocamlbytecomp"]
    }),
    main = select({
        # "//config/target:baseline_vm?": "//driver:Main",
        # "//config/target:baseline_sys?": "//driver:Optmain",
        # "//config/target:ult_sys?": "//driver:Optmain",

        "//config/target/emitter:sys_emitter?": "//driver:Optmain",

        "//conditions:default": "//driver:Main"
    }),
    opts = [ ] + select({
        # ocamlc.byte: ["-compat-32"]
        "//conditions:default": []
    }) + [
        ## use --//config/ocaml/link:verbose instead
        # "-verbose",

        ## for testing (linux):
        # "-cc", "gcc",  ## cancels mkexe
        # "-ccopt", "-B/usr/bin",
        # "-ccopt", "-B/usr/lib",
        # "-ccopt", "-B/usr/lib/gcc/x86_64-linux-gnu/9",
        ## bazel-generated args:
        # "-ccopt", "-fuse-ld=gold",
        # "-ccopt", "-fno-use-linker-plugin",
        # "-ccopt", "-Wl,-no-as-needed",
        # "-ccopt", "-Wl,-z,relro,-z,now",
        # "-ccopt", "-pass-exit-codes",
        # "-ccopt", "-lstdc++",

        # "-ccopt", "-Wl,-export_dynamic",
        # "-ccopt", "-Wl,-all_load"
    ] + select({
        "//platform/target/os:linux?": [
            "-cclib", "-lm",
            "-cclib", "-ldl",
            "-cclib", "-lpthread",
        ],
        "//conditions:default": []
    }),
    cc_linkopts = select({
        "@platforms//os:macos": [ ## FIXME: default tc, not zig
            # "-Wl,-v", # prints config, search paths
            # "-Wl,-print_statistics", # -Wl,-v plus timings, mem, etc.
            # "-t", # -Wl-v plus logs each file the linker loads.
            # "-why_load" # Log why each object file in a static library
            #             # is loaded. That is, what symbol was needed.
            ## zig linker opts
            # "-v",
            ],
        "@platforms//os:linux": [
            # "-Wl,--verbose"
            ##FIXME: depends on linker used (bfd, gold, etc.)
        ]
    }),
    # cc_deps = ["//runtime:asmrun"],
    visibility             = ["//visibility:public"]
)

