package(default_visibility = ["//visibility:public"])

load("//bzl:rules.bzl",
     "bootstrap_archive",
     "bootstrap_executable",
     "bootstrap_module",
     "boot_compiler"
)

#FIXME: clean these up!
load("//config:CONFIG.bzl",
     "ARCH", "MODEL", "SYSTEM",
     "HOST", "ROOTDIR", "LIBDIR",
     # flags
     # "OC_CFLAGS",
     "CFLAGS",
     "OC_CPPFLAGS", "CPPFLAGS",
     "OC_LDFLAGS", "LDFLAGS",
     # defines - replace by CC_DEFINES with selects
     # "OC_DEBUG_CPPDEFINES", "OC_INSTR_CPPDEFINES",
     # "OC_CPPDEFINES", "OC_NATIVE_CPPDEFINES",
     # "CC_DEFINES", "CC_NATIVE_DEFINES",
     # other
     # "OUTPUTEXE", "MKEXE_FLAGS",
     )

exports_files(["Makefile.config", "VERSION"])

# load("//config:CONFIG.bzl",
#      # "USE_PRIMS", "DATA_PRIMS",
#      # "PRIMITIVES"
#      )

################################################################
alias(
    name = "ocamlrun",
    actual = "//boot/bin:ocamlrun"
)

alias(
    name = "ocamllex",
    actual = "//boot:ocamllex"
)

# boot_compiler( ##FIXME: do we really need a separate rule?
# # compiler(
#     name = "ocamlc",
#     # compile_target = "//platform/cpu:arm",  ## ??
#     exec_compatible_with = [
#         ## *>vm ???
#     ],
#     opts = [
#         "-nostdlib", "-compat-32",
#     ],
#     # primitives = PRIMITIVES,
#     main = "//driver:Main",
#     deps = [
#         "//compilerlibs:ocamlcommon",
#         "//bytecomp:ocamlbytecomp",
#         # "//boot:stdlib"
#     ],
#     visibility = [
#         "//compilers/stage2:__pkg__",
#         "//testsuite:__pkg__"
#     ]
# )

