load("@bazel_skylib//rules:write_file.bzl", "write_file")
load("@bazel_skylib//rules:common_settings.bzl",
     "string_flag", "string_setting")

## NB: config flags a settings, e.g. --//runtime:dbg, at bottom of file

load(":BUILD.bzl", "asan")

load("//bzl:rules.bzl",
     "boot_executable",
     "boot_module")

exports_files(["gen_primitives.sh"] + glob(["*.c"]))

OPTIMIZATION_FLAGS = select({
    ":dbg?": ["-O0", "-g3"], # -Wall -Werror
    "//conditions:default": []
})

# IN_CAML_RUNTIME only used in domain_state.h
RUNTIME_DEFINES = select({
    # for both vm and sys runtimes
    "//config/mode:instrumented?": ["CAML_INSTR"],
    "//conditions:default": ["CAMLDLLIMPORT=", "IN_CAML_RUNTIME"]
}) + select({
    ## WARNING: //platforms/vm just for -DDEBUG, not debugger mode (-c dbg)
    ":DEBUG?": ["DEBUG"],
    "//conditions:default": []
})

################################################################
## TODO: we only need one runtime lib target if we select on build
## target to decide which to build. Call it "runtime" or
## "ocaml_runtime".
cc_library(
    name = "camlrun",
    alwayslink = True, linkstatic = True,
    srcs = [
        "//runtime:build_config.h",
        "//runtime:common_c_sources",
        "//runtime:bytecode_only_c_sources"
    ] + select({
    # "//platforms/target:vm?": ["//runtime:bytecode_only_c_sources"],
    # "//conditions:default": ["//runtime:native_only_c_sources"],
    "//conditions:default": []
    }),
    copts = [
        "-x", "c",
        # "-Wall",
        # "-pedantic",
        "-I$(GENDIR)/runtime", # build_config.h
        ## for platform-dependend s.h:
        "-I", "$(GENDIR)/runtime/caml/cross-compile", ##HACK for xcompile
        "$(OC_CFLAGS)",
        "$(OC_CPPFLAGS)",
    ] + select({
        "//platforms/os:macos?": ["-std=c11"],
        "//platforms/os:linux?": [],
        "//conditions:default":  [] #"-std=c11"]
    }) + select({
        "//config/mode:pedantic?": ["-pedantic"],
        "//conditions:default":  []
    }) + select({
        # "//runtime:asan?": ["-I", "runtime", "-fsanitize=address"],
        "//conditions:default":  []
    })
    ,
    # + CFLAGS + OC_CPPFLAGS + OPTIMIZATION_FLAGS,
    linkopts = ["$(OC_LDFLAGS)"]
    + select({
        # "//runtime:msan?": ["-fsanitize=leak", "-fPIE", "-pie"],
        "//conditions:default": []
    }) + select({
        # "//runtime:asan": ["-fsanitize=address"],
        "//conditions:default": []
    })
    ,
    defines = RUNTIME_DEFINES,
    deps = [
        "//runtime/caml:hdrs"
    ],
    toolchains = [
        "//profile/system/local"
    ],
    visibility = [
        "//:__pkg__",
        "//boot:__subpackages__",
        "//lib:__pkg__"
    ],
)

###########
cc_library(
    name = "asmrun",
    alwayslink = True, linkstatic = True,
    srcs = [
        "//runtime:build_config.h",
        "//runtime:common_c_sources",
        "//runtime:native_only_c_sources"
    ],
    copts = [
        "-x", "c",
        "-I$(GENDIR)/runtime", # build_config.h
        ## for platform-dependend s.h:
        "-I", "$(GENDIR)/runtime/caml/cross-compile", ##HACK for xcompile
        "$(OC_CFLAGS)",
        "$(OC_CPPFLAGS)",
    ] + select({
        "//platforms/os:macos?": [], #"-std=c11"],
        "//platforms/os:linux?": [],
        "//conditions:default":  [] #"-std=c11"]
    }) + select({
        "//config/mode:pedantic?": ["-pedantic"],
        "//conditions:default":  []
    }),
    linkopts = ["$(OC_LDFLAGS)"],
    defines = RUNTIME_DEFINES + [ # OC_NATIVE_DEFINES + [
    ] + select({
        # to unify camlrun and asmrun targets, need to select these:
        "//conditions:default"   : [
            "NATIVE_CODE",
            "TARGET_$(ARCH)",
            "MODEL_$(MODEL)",
            "SYS_$(SYSTEM)"
        ] #testing
    }),
    deps = ["//runtime/caml:hdrs"],
    toolchains = ["//profile/system/local"],
    visibility = [
        "//:__pkg__",
        "//boot/lib:__pkg__",
        "//dev/lib:__pkg__",
        "//lib:__pkg__"
    ],
)

### //runtime:ocamlc moved to //compilers:ocamlc
## root Makefile:
# The bytecode compiler
# ocamlc$(EXE): compilerlibs/ocamlcommon.cma \
#               compilerlibs/ocamlbytecomp.cma $(BYTESTART)
# 	$(CAMLC) $(LINKFLAGS) -compat-32 -o $@ $^
## level 0 - uses //boot/bin:ocamlc
# ocamlc_runtime(
# boot_executable(
#     name = "ocamlc",
#     # exe  = "ocamlc",
#     opts = ["-compat-32"],
#     deps = [
#         "//compilerlibs:ocamlcommon",
#         "//bytecomp:ocamlbytecomp"
#     ],
#     visibility = ["//visibility:public"]
# )

# ifeq "$(TOOLCHAIN)" "msvc"
# ASM_EXT := asm
# ASM_SOURCES := $(ARCH)nt.$(ASM_EXT)
# else
# ASM_EXT := S
# ASM_SOURCES := $(ARCH).$(ASM_EXT)
# endif

## Makefile.build_config.in:
## Platform-dependent assembler files to use to build the runtime
# runtime_ASM_OBJECTS = $(addprefix runtime/,@runtime_asm_objects@)

## configure.ac:
# AS_CASE([$ccomptype],
#   [msvc],
#     [runtime_asm_objects=${arch}nt.${OBJEXT}],
#   [runtime_asm_objects=${arch}.${OBJEXT}])

## configure:
# case $ccomptype in #(
#   msvc) :
#     runtime_asm_objects=${arch}nt.${OBJEXT} ;; #(
#   *) :
#     runtime_asm_objects=${arch}.${OBJEXT} ;;
# esac

##  ASPP: assembler w/preprocessor, default "$CC -c"
# runtime/%.o: runtime/%.S
# 	$(ASPP) $(OC_ASPPFLAGS) -o $@ $< || $(ASPP_ERROR)
# runtime/%.d.o: runtime/%.S
# 	$(ASPP) $(OC_ASPPFLAGS) $(OC_DEBUG_CPPFLAGS) -o $@ $< || $(ASPP_ERROR)
# runtime/%.i.o: runtime/%.S
# 	$(ASPP) $(OC_ASPPFLAGS) $(OC_INSTR_CPPFLAGS) -o $@ $< || $(ASPP_ERROR)
# runtime/%_libasmrunpic.o: runtime/%.S
# 	$(ASPP) $(OC_ASPPFLAGS) $(SHAREDLIB_CFLAGS) -o $@ $<


## OBJEXT: set by configure, but only 2 possibilities: .S or .asm
## ARCH: arm | arm64 | i386 | amd64 | power | riscv | s390x
## Bazel: arch must be set, by config setting to be determined.
## For now it's hardcoded as amd64 since I'm using a legacy Mac for dev.
# RUNTIME_ASM_OBJECTS = select({
#     "//platforms:windows_x86_32?": [ARCH + "nt.asm"],
#     "//conditions:default": [ARCH + ".S"] # e.g. amd64.S
# })

## WARNING: on windows the build for asm files is different, see //Makefile

filegroup(
    name = "common_c_sources",
    srcs = ["sync_posix.h"] + glob(
        include = ["*.c"],
        exclude = [
            "backtrace_byt.c",
            "backtrace_nat.c",
            "clambda_checks.c",
            "dynlink_nat.c",
            "fail_byt.c",
            "fail_nat.c",
            "fix_code.c",
            "frame_descriptors.c",
            "instrtrace.c",
            "interp.c",
            "main.c",
            "prims.c", ## in case a make build writes it to srcs
            "sak.c",
            "signals_nat.c",
            "startup_byt.c",
            "startup_nat.c",
            "unix.c",
            "win32.c"
        ]
    ) + select({
    ## $(UNIX_OR_WIN32) = 'unix' or 'win32', from configure script
    "//platforms/os:linux?": ["unix.c"],
    "//platforms/os:macos?": ["unix.c"],
    "//platforms:windows_x86_32?": ["win32.c"], # using bazel naming
    # "//platforms:windows_x86_64?": [???]
    "//conditions:default": []
    }),
    visibility = [
        "//boot:__pkg__",
        "//bin:__pkg__"
    ]
)

COMMON_C_SOURCES = [
    "addrmap.c",
    "afl.c",
    "alloc.c",
    "array.c",
    "backtrace.c",
    "bigarray.c",
    "callback.c",
    "codefrag.c",
    "compare.c",
    "custom.c",
    "debugger.c",
    "domain.c",
    "dynlink.c",
    "extern.c",
    "fiber.c",
    "finalise.c",
    "floats.c",
    "gc_ctrl.c",
    "gc_stats.c",
    "globroots.c",
    "hash.c",
    "intern.c",
    "ints.c",
    "io.c",
    "lexing.c",
    "lf_skiplist.c",

    ## if we compile main.c into libcamlrun.a zig will fail to find main
    ## entry point.

    ## but main is not really appropriate for a library anyway. but
    ## then why is it shared with both bc and native? why does the
    ## latter need it?

    # "main.c",

    "major_gc.c",
    "md5.c",
    "memory.c",
    "memprof.c",
    "meta.c",
    "minor_gc.c",
    "misc.c",
    "obj.c",
    "parsing.c",
    "platform.c",
    "printexc.c",
    "prng.c",
    "roots.c",
    "runtime_events.c",
    "shared_heap.c",
    "signals.c",
    "skiplist.c",
    "startup_aux.c",
    "str.c",
    "sync.c", "sync_posix.h",
    "sys.c",
    "weak.c"
] + select({
    ## $(UNIX_OR_WIN32) = 'unix' or 'win32', from configure script
    "//platforms/os:linux?": ["unix.c"],
    "//platforms/os:macos?": ["unix.c"],
    "//platforms:windows_x86_32?": ["win32.c"], # using bazel naming
    # "//platforms:windows_x86_64?": [???]
    "//conditions:default": []
})

filegroup(
    name = "instrtrace",
    srcs = ["instrtrace.c"],
    visibility = ["//boot:__pkg__"]
)

filegroup(
    name = "bytecode_only_c_sources",
    srcs = [
            "backtrace_byt.c",
            "fail_byt.c",
            "fix_code.c",
            "interp.c",
            "main.c",
            "startup_byt.c",
        ],
    visibility = [
        "//boot:__pkg__",
        "//bin:__pkg__"
    ]
)

BYTECODE_ONLY_C_SOURCES = [
    "backtrace_byt.c",
    "fail_byt.c",
    "fix_code.c",
    "interp.c",
    "main.c",
    "startup_byt.c"
]

# RUNTIME_BYTECODE_C_SOURCES = COMMON_C_SOURCES + BYTECODE_ONLY_C_SOURCES

filegroup(
    name = "native_only_c_sources",
    srcs = [
        "backtrace_nat.c",
        "clambda_checks.c",
        "dynlink_nat.c",
        "fail_nat.c",
        "frame_descriptors.c",
        "startup_nat.c",
        "signals_nat.c"
    ],
    visibility = [
        "//boot:__pkg__",
        "//bin:__pkg__"
    ]
)

NATIVE_ONLY_C_SOURCES = [
  "backtrace_nat.c",
  "clambda_checks.c",
  "dynlink_nat.c",
  "fail_nat.c",
  "frame_descriptors.c",
  "startup_nat.c",
  "signals_nat.c"
]

# RUNTIME_NATIVE_C_SOURCES = COMMON_C_SOURCES + NATIVE_ONLY_C_SOURCES

########
genrule(
    outs = ["build_config.h"],
    name = "build_config_h",
    tools = ["//runtime:sak.exe"],
    srcs = ["//:Makefile.config", "//profile/system/local:BUILD.bazel"],
    cmd  = " ".join([
        "STDLIBDIR=`$(location //runtime:sak.exe) encode-C-literal $(LIBDIR)`;",
	    "echo '/* This file is generated from $(location //profile/system/local:BUILD.bazel) */' > $@;",
	    "echo \"#define OCAML_STDLIB_DIR $$STDLIBDIR\" >> $@;",
	    "echo '#define HOST \"$(HOST)\"' >> $@"
    ]),
    toolchains = ["//profile/system/local"],
    visibility = ["//boot:__pkg__"]
)

##//Makefile:
  # $(shell runtime/gen_primitives.sh > runtime/primitives.new; \
  #                   cmp -s runtime/primitives runtime/primitives.new || \
  #                   echo runtime/primitives.new)
  #   cp $^ $@

## FIXME: do the cmp
genrule(
    outs  = ["primitives"],
    name  = "primitives_dat",
    visibility = ["//visibility:public"],
    tools = [":gen_primitives.sh"],
    ## cwd is proj root, but the script assumes it is runtime
    cmd   = " ".join([
        # "echo PWD: $$(PWD);",
        # "cd runtime && ",
        "$(location :gen_primitives.sh) > $@;"
    ]),
    ## script depends on these (Bazel: runfiles):
    ##FIXME: use filegroups above?
    srcs  = [
        "alloc.c", "array.c", "compare.c", "extern.c", "floats.c",
        "gc_ctrl.c", "hash.c", "intern.c", "interp.c", "ints.c", "io.c",
        "lexing.c", "md5.c", "meta.c", "memprof.c", "obj.c", "parsing.c",
        "signals.c", "str.c", "sys.c", "callback.c", "weak.c",
        "finalise.c", "domain.c", "platform.c", "fiber.c", "memory.c",
        "startup_aux.c", "runtime_events.c", "sync.c", "dynlink.c",
        "backtrace_byt.c", "backtrace.c", "afl.c", "bigarray.c", "prng.c",
    ]
)

## TODO: obazl_rules_mustache
# mustache_lines(
#     name = "prims_c",
#     out  = "prims.c",
#     template = "prims.mustache",
#     data     = "prims.c",
# )

# prims.c : primitives
genrule(
    outs  = ["prims.c"],
    name  = "prims_c",
    srcs  = [":primitives"],
    cmd   = "\n".join([
        "PRIMS=`cat $(location primitives)`;",
        # "echo PRIMS: $$PRIMS;",
	    "echo '#define CAML_INTERNALS' > $@;",
        "echo '#include \"caml/mlvalues.h\"' >> $@;",
	    "echo '#include \"caml/prims.h\"' >> $@;",
        "sed -e 's/.*/extern value &();/' $(location :primitives) >> $@;",
        "echo 'c_primitive caml_builtin_cprim[] = {' >> $@;",
        "sed -e 's/.*/  &,/' $(location :primitives) >> $@;",
        "echo '  0 };' >> $@;",
        "echo 'char * caml_names_of_builtin_cprim[] = {' >> $@;",
        "sed -e 's/.*/  \"&\",/' $(location :primitives) >> $@;",
        "echo '  0 };' >> $@"
    ]),
    visibility = [
        "//boot:__pkg__",
        "//bin:__pkg__"
    ]
)

## FIXME: to build multiple "versions" (e.g. libcamlrun, libcamlrund,
## etc.) we can either support multiple targets, or one target
## parameterized by build settings.

## Either way, we will have to build each separately, one build cmd
## per output.

## what is ocamlruns? windows only? (with flexdll?)
# runtime/ocamlruns$(EXE): runtime/prims.$(O) runtime/libcamlrun_non_shared.$(A)
# 	$(call MKEXE_VIA_CC,$@,$^ $(BYTECCLIBS))

# MKEXE_VIA_CC=\
#   $(CC) $(OC_EXE_LDFLAGS) $(OC_CFLAGS) $(CFLAGS) $(OC_LDFLAGS) $(LDFLAGS) $(OUTPUTEXE)$(1) $(2)
# OUTPUTEXE=-o $(EMPTY)

################################################################
## compile flags: OC_CPPFLAGS, runtime_CPPFLAGS
# Makefile.config:
#   OC_CFLAGS=-O2 -fno-strict-aliasing -fwrapv -pthread -g -Wall -Werror -fno-common
## these are configured in //config:
#   OC_CPPFLAGS=-I$(ROOTDIR)/runtime  -D_FILE_OFFSET_BITS=64
#   runtime_CPPFLAGS = -DCAMLDLLIMPORT= -DIN_CAML_RUNTIME
#   ocamlrund_CPPFLAGS = -DDEBUG
#   ocamlruni_CPPFLAGS = -DCAML_INSTR

# ################  standard  ################
## The makefiles copy stuff into boot and make it accessible to build
## targets by passing '-I boot'. OBazl does not (need to) do that.
## Instead we define a library target that aggregates the same
## resources by label, so targets can depend on '//boot/lib:stdlib'. NB:
## the only difference between //stdlib and //boot/lib:stdlib is that the
## latter includes //stdlib:Std_exit and //stdlib:camlheader.

# target: runtime
## initial build of the runtime, using the bootstrap compiler. the
## legacy build system builds runtime/ocamlrun, then copies it to
## boot/ocamlrun, so that the boot compiler and the runtime needed to
## interpret the code it admits are in the same place.

## under bazel we can build boot/ocamlrun etc. directly.

################################################################
# From Makefile.common: Most of the time, boot/ocamlrun and
# runtime/ocamlrun are the same. However, under some circumstances it
# is important to be able to distinguish one from the other, hence
# these two variables. (OCAMLRUN NEW_OCAMLRUN)
# NEW_OCAMLRUN only used for running 'make_opcodes', in tools and bytecomp.

cc_binary( ##FIXME: move this to //runtime and use an alias here
    name = "ocamlrun",
    srcs = [
        ":prims.c",
    ] + select({
        # add instrtrace if mode is debug on any platform, or
        # fastbuild on macos (where Bazel adds -DDEBUG)
        ":trace?": ["//runtime:instrtrace"],
        "//conditions:default": []
    }),
    copts = [
        "-x", "c",
        "-Iruntime",  # expose caml/*.h
        "-I$(GENDIR)/runtime", # build_config.h
        "-I$(GENDIR)/runtime/caml/cross-compile", ##HACK for xcompile
        "$(OC_CFLAGS)",
        "$(OC_CPPFLAGS)",
    ] + select({
        "//platforms/os:macos?": ["-std=c11"],
        "//platforms/os:linux?": [],
        "//conditions:default":  ["-std=c11"]
    }), # + CFLAGS + OC_CPPFLAGS,
    defines = RUNTIME_DEFINES,
    linkopts = ["$(OC_LDFLAGS)"] + select({
        "//platforms/target:sys?": ["$(SYS_LINKLIBS)"],
        "//platforms/target:vm?" : ["$(VM_LINKLIBS)"],
        "//conditions:default"   : ["$(VM_LINKLIBS)"],
    }),
    deps= [
        ":camlrun",
        "//runtime/caml:hdrs"
    ],
    toolchains = ["//profile/system/local"],
    visibility = ["//visibility:public"],
)

################################################################
## problem: makefiles set different options for bytecode and native
## runtimes. meaning commonrun would have to be built twice. the
## legacy build pgm always does this, compiling srcs to different
## outputs (named with a type suffix, e.g. .bd for bytecode debug.)
## but with bazel we need not do this. instead of multiple targets
## building the same code, we have one target and we parameterize the
## builds. so instead of distinguishing between e.g. vm and native
## builds we select on features. after all the vm/runtime is c code
## compiled to the native sys target, just like the native runtime.
# cc_library(
#     name = "commonrun",
#     alwayslink = True,
#     linkstatic = True,
#     srcs = [":build_config.h", ##] + COMMON_C_SOURCES,
#             ":common_c_sources"
#     ],
#     # srcs = COMMON_C_SOURCES,
#     copts = [
#         "-I$(GENDIR)/runtime", # pick up build_config.h
#     ] + OC_CPPFLAGS,
#     # + select({
#     #     #FIXME: macos with compilation_mode == fastbuild
#     #     "//platforms/os:macos_fastbuild?": ["-UDEBUG"],
#     #     "//conditions:default": []
#     # }),
#     defines = ["CAMLDLLIMPORT=", "IN_CAML_RUNTIME"] + CC_DEFINES,
#     # defines = CC_DEFINES,
#     deps = ["//runtime/caml:hdrs"],
#     visibility = ["//visibility:public"]
# )

################  PIC  ################
## if unix and SUPPORTS_SHARED_LIBRARIES (i.e. has dlopen)
# cc_library(
#     name = "camlrun_pic",
#     srcs = [
#         ":build_config.h",
#     ] + RUNTIME_BYTECODE_C_SOURCES,
#     copts = [
#         "-I$(GENDIR)/runtime", # pick up build_config.h
#     ] + OC_CPPFLAGS + select({
#         "//config/debug:ocamlrun-debug": ["-g"],
#         #FIXME: on mac bazel always adds -DDEBUG for fastbuild
#         "//conditions:default": ["-UDEBUG"]
#     }),
#     defines = CC_DEFINES,
#     deps = ["//runtime/caml:hdrs"],
# )

################ shared
# cc_binary(
#     name       = "camlrun_shared",
#     linkshared = True,
#     srcs = [
#         ":build_config.h",
#     ] + RUNTIME_BYTECODE_C_SOURCES,
#     copts = [
#         "-I$(GENDIR)/runtime", # pick up build_config.h
#     ] + OC_CPPFLAGS + select({
#         "//config/debug:ocamlrun-debug": ["-g"],
#         #FIXME: on mac bazel always adds -DDEBUG for fastbuild
#         "//conditions:default": ["-UDEBUG"]
#     }),
#     defines = CC_DEFINES,
#     deps = ["//runtime/caml:hdrs"],
# )

################ debug
# cc_binary(
#     name = "ocamlrund",
#     srcs = ["prims.c"],
#     copts = OC_CFLAGS + CFLAGS + ["-g"],
#     linkopts = OC_LDFLAGS + LDFLAGS + BYTECCLIBS + MKEXE_FLAGS,
#     deps= [":camlrund"],
#     visibility = ["//visibility:public"]
# )

# cc_library(
#     name = "camlrund",
#     srcs = [
#         ":build_config.h",
#         "instrtrace.c"
#     ] + RUNTIME_BYTECODE_C_SOURCES,
#     copts = [
#         "-I$(GENDIR)/runtime" # to pick up build_config.h
#     ] + OC_CPPFLAGS,
#     defines = CC_DEFINES, ##  + OC_DEBUG_CPPDEFINES,
#     deps = ["//runtime/caml:hdrs"]
# )

################ vm cmd, instrumented
## configure.ac says:
# The instrumented runtime is built by default
# if the proper clock source is found.
# If asked via --enable-instrumented-runtime, configuration fails if the proper
# clock source is missing.

# macos: has_monotonic_clock is true if:
# macos: HAS_MACH_ABSOLUTE_TIME if has mach_timebase_info, mach_absolute_time
# macos: HAS_POSIX_MONOTONIC_CLOCK if _POSIX_TIMERS etc. - see configure.ac

# linux: clock_gettime etc. - complicated, see configure.ac


## Generating an ld.conf is not a build-time task; it can be done as
## part of a packaging task.
# genrule(
#     outs = ["ld.conf"],
#     name "__ld.conf__",
#     srcs = ["//:Makefile.config"],
#     cmd  = "\n".join([
# 	    echo "$(location STUBLIBDIR)" > $@
# 	    echo "$(locationn LIBDIR)" >> $@
#     ])
# )

################################################################
##  experiments: partition the code
##      libprimitives, libmem, libinterp, etc.

cc_library(
    name = "mem",
    alwayslink = True, linkstatic = True,
    srcs = [
        "gc_ctrl.c",
        "gc_stats.c",
        "memory.c",
        "memprof.c",
        "shared_heap.c",
    ],
    copts = [
        "-x", "c",
        "-I$(GENDIR)/runtime", # build_config.h
        ## for platform-dependend s.h:
        "-I", "$(GENDIR)/runtime/caml/cross-compile", ##HACK for xcompile
        "$(OC_CFLAGS)",
        "$(OC_CPPFLAGS)",
    ] + select({
        "//platforms/os:macos?": [], #"-std=c11"],
        "//platforms/os:linux?": [],
        "//conditions:default":  [] #"-std=c11"]
    }) + select({
        "//config/mode:pedantic?": ["-pedantic"],
        "//conditions:default":  []
    }), # + CFLAGS + OC_CPPFLAGS + OPTIMIZATION_FLAGS,
    linkopts = ["$(OC_LDFLAGS)"],
    defines = RUNTIME_DEFINES + [
        "NATIVE_CODE",
        "TARGET_$(ARCH)",
        "MODEL_$(MODEL)",
        "SYS_$(SYSTEM)"
    ],
    deps = ["//runtime/caml:hdrs"],
    toolchains = ["//profile/system/local"],
    visibility = [
        "//boot/lib:__pkg__",
        "//dev/lib:__pkg__",
        "//lib:__pkg__"
    ],
)

################################################################
## sak - swiss army knife. tool used for the build only.
##########
## make log:
# gcc -c -O2 -fno-strict-aliasing -fwrapv -pthread -g -Wall -Werror -fno-common  -I./runtime  -D_FILE_OFFSET_BITS=64  -DCAMLDLLIMPORT= -DIN_CAML_RUNTIME -DNATIVE_CODE -DTARGET_amd64 -DMODEL_default -DSYS_macosx  -DCAMLDLLIMPORT= -DIN_CAML_RUNTIME  -o runtime/sak.o runtime/sak.c
# gcc  -O2 -fno-strict-aliasing -fwrapv -pthread -g -Wall -Werror -fno-common  -Wl,-no_compact_unwind  -o runtime/sak runtime/sak.o

# NB: none of the defines here are used in sak.c!
cc_binary(
    name = "sak.exe",
    srcs = ["sak.c"],
    copts = [
        ## for platform-dependent s.h:
        "-I", "$(GENDIR)/runtime/caml/cross-compile",
        "$(OC_CFLAGS)",
        "$(OC_CPPFLAGS)",
    ],
    defines = RUNTIME_DEFINES,
    linkopts = ["$(OC_LDFLAGS)"],
    deps= [
        "//runtime/caml:hdrs",
    ],
    ## access to Make vars:
    toolchains = ["//profile/system/local"],
    visibility = ["//runtime/caml:__pkg__"]
)

################################################################
load("@bazel_skylib//lib:selects.bzl", "selects")
load("@bazel_skylib//rules:common_settings.bzl",
     "bool_flag", "string_list_flag")

string_flag(name = "runtime",
            build_setting_default = "std",
            values = [
                "std", # standard
                "dbg", # debug
                "instr"  # instrumented
            ],
            visibility = ["//visibility:public"]
            )

config_setting(name = "standard?", flag_values = {":runtime": "std"},
               visibility = ["//visibility:public"])

# FIXME: dbg? true if either -c dbg or --//runtime:dbg
config_setting(name = "vmdbg?", flag_values = {":runtime": "dbg"},
               visibility = ["//visibility:public"])
selects.config_setting_group(
    name = "dbg?",
    match_any = [":vmdbg?", "//config/compilation_mode:dbg?"],
)

config_setting(name = "instrumented?", flag_values = {":runtime": "instr"},
               visibility = ["//visibility:public"])


## WARNING: for Bazel, -c dbg means `-g`, not `-DDEBUG`

bool_flag(name = "DEBUG", build_setting_default = False)
config_setting(name = "DEBUG?", flag_values = {":DEBUG": "True"})

bool_flag(name = "trace", build_setting_default = False)
config_setting(name = "trace?", flag_values = {":trace": "True"})

selects.config_setting_group(
    name = "DEBUG_TRACE?",
    match_any = [
        ":trace?",
        ":DEBUG?",
        "//config/compilation_mode:dbg?"
    ],
)

#### sanitizers
bool_flag(name = "asan", build_setting_default = False)
config_setting(name = "asan?", flag_values = {":asan": "True"})
bool_flag(name = "msan", build_setting_default = False)
config_setting(name = "msan?", flag_values = {":msan": "True"})


################
bool_flag(name = "fastbuild", build_setting_default = False)
config_setting(name = "vmfastbuild?", flag_values = {":fastbuild": "True"})
selects.config_setting_group(
    name = "fastbuild?",
    match_any = [":vmfastbuild?",
                 "//config/compilation_mode:fastbuild?"],
)

config_setting(
    name = "instrtrace?",
    values = {"compilation_mode":"fastbuild"},
    constraint_values = ["@platforms//os:macos"]
)

string_list_flag(name = "args", build_setting_default = [],
            visibility = ["//toolchain:__subpackages__"])
