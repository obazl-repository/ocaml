= CC Toolchain Integration
:toc: auto
:toclevels: 3

The OCaml compilers are actually compiler drivers, more like gcc than
a compiler. Like gcc, they may invoke the C compiler, assembler, or
linker.

== assembler

OCaml native compilers may emit commands to assemble a file. You can
see this by passing `-verbose` to the OCaml compiler (in a target's
'opts' attr or by passing `--//config/ocaml:verbose`).

For example on Mac, the OCaml compiler, when compiling a native module, will
run something like the following to compile the assembly code it generates:

    gcc -c -Wno-trigraphs  -o 'bazel-out/darwin-fastbuild-ST-aaef713aa55a/bin/typing/_BS_vs/Persistent_env.o' '/var/folders/wz/dx0cgvqx5qn802qmc3d4hcfr0000gq/T/camlasm9ca102.s'

This command is stored in `Config.asm` at configure-time. It is used
by the `Proc` modules defined for each supported arch under `asmcomp`;
for example `asmcomp/arm64/proc.ml`, or `asmcomp/X86_proc.ml`.
Ultimately it gets passed to a call to `system(3)` (in
`runtime/sys.c`) which passes it to `sh(1)`.

Bazel does things a little differently. The commands used by the OCaml
compilers to drive the CC toolchain are derived from the CC toolchain
selected by Bazel at build-time. This ensures the same toolchain and
commands used to build free-standing C code (such as the runtimes) are
used by the OCaml compilers to assemble and link the code they generate.

For example, on the Mac, Bazel by default uses the Xcode toolchain,
and uses some customized tools. So the above assemble command, when
configured by Bazel instead of `./configure`, looks like this:

----
 exec env -i - DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer SDKROOT=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk external/local_config_cc/wrapped_clang -c -D_FORTIFY_SOURCE=1 -fstack-protector -fcolor-diagnostics -Wall -Wthread-safety -Wself-assign -fno-omit-frame-pointer -g0 -O2 -DNDEBUG -DNS_BLOCK_ASSERTIONS=1 DEBUG_PREFIX_MAP_PWD=. -isysroot __BAZEL_XCODE_SDKROOT__ -F__BAZEL_XCODE_SDKROOT__/System/Library/Frameworks -F__BAZEL_XCODE_DEVELOPER_DIR__/Platforms/MacOSX.platform/Developer/Library/Frameworks -no-canonical-prefixes -pthread -no-canonical-prefixes -Wno-builtin-macro-redefined -D__DATE__="redacted" -D__TIMESTAMP__="redacted" -D__TIME__="redacted" -target x86_64-apple-macosx13.1 -Wno-trigraphs -v  -o 'bazel-out/darwin-fastbuild-ST-aaef713aa55a/bin/typing/_BS_vs/Persistent_env.o' '/var/folders/wz/dx0cgvqx5qn802qmc3d4hcfr0000gq/T/camlasm64188c.s'
----

== linker
The command lines used are fixed at config-time (by `/.configure`) as
members of the Config module:

* mkexe - cmd to link an executable, used e.g. when building a native executable
* mkdll etc. - windows stuff

The problem with this is that ocaml_cc build actions are outside the
control of Bazel. In particular, the mkexe command line generated
by ./configure will not (probably) match the one used by Bazel. Recall
that Bazel has its own "configure" mechanism for the CC toolchain; it
interrogates the system to discover the toolchain and has its own
ideas about which arguments should be passed when invoking the tools.

A second problem is that there is no way to pass user flags to the
ocaml_cc link action.  [Correction: the -cclib and --ccopt options allow this.]

For example, on Ubuntu 20.04 the ./configure setting for mkexe is:

* `gcc -O2 -fno-strict-aliasing -fwrapv -pthread -Wl,-E`

First point: all but the last two are compile options, not link options.

This will use the standard `ld` linker.

Bazel uses the following args for linking executables:

* `-fuse-ld=gold -Wl,-no-as-needed -Wl,-z,relro,-z,now -B/usr/bin -pass-exit-codes -lstdc++`

These are all linker options, derived from the CC toolchain selected and configured by Bazel.

This is what will be used to link CC executables for the build, using
the standard `cc_binary`  Bazel rule ( `//runtime:ocamlrun`,
`//yacc:ocamlyacc`).


Now the problem is that Bazel constructs this command line at build
time. But the source for module `Config` is fixed at config-time. So
there are several ways to integrate Bazel into this protocol.

1. Use a custom Bazel rule to be executed using `bazel run` instead of
`bazel build`, and have it write out a config file. This would
essentially be a kind of Bazel `./configure` rule.

2. Use build-time preprocessing to generate the Config source in such
a way that it contains the Bazel-generated link args. Input to the
preprocessing target would be a file generated by `./configure`; the
pp rule would extract the link cmds from the cc toolchain selected by
Bazel. **This is the current strategy.** See the "config" targets in link:../../../config/BUILD.bazel[//config:BUILD.bazel].

3. Use the OCaml options `-cc`, `-ccopt`, `-cclib`. Passing `-cc`
overrides mkexe, but requires that any args be passed with `-ccopt`,
which will be placed after the `-o` and `-L` args.


