= preprocessing

The legacy build uses a variety of shell scripts and tools (awk, sed,
  etc.) to transform and/or generate code. The Bazel build replaces
  all (or at least most) of this with templated code generation using
  an link:https://gitlab.com/jobol/mustach[implementation] of
  link:https://mustache.github.io/mustache.5.html[Mustache] written in
  portable C.

(Some things have not (yet) been replaced, e.g. `lambda/generate_runtimedef.sh`)

CAUTION: This requires some changes to the sources,

Below are some examples. Look for `.mustache` and `.json` files in the
sources; the process is driven by a custom Bazel rule named
`mustache`.

=== Domain state

File `runtime/caml/domain_state.tbl` is replaced by
`domain_state.json`, and `runtime/caml/domain_state.h` is generated
from that and a template, `runtime/caml/domain_state.h.mustache`.
Similarly for other files generated from `domain_state.tbl`. I believe
the result is much simpler and clearer.


=== Opcodes and opnames

The legacy build parses `runtime/caml/instruct.h` to extract
information about opcodes. It uses an OCaml program (a lexer) to do
this (tools/make_opcodes), which of course must be built. This is
overkill - its job is very simple, parse the enum in
`runtime/caml:instruct.h`. OBazl eliminates this, instead using a json
file to drive code generation from mustache templates. The result is
much simpler, IMO.

The following files are generated by template `bytecomp:opcodes.json`:

** `bytecomp/opcodes.ml`
** `bytecomp/opnames.ml`
** `runtime/caml/instruct.h`
** `runtime/caml/jumptbl.h`
** `runtime/caml/instruct.h`
** `runtime/caml/opnames.h`

=== Primitives

The legacy build uses a shell script `runtime/gen_primitives.sh` to
extract (using `sed`) the list of primitives from C source files in
`runtime`, and use it to generate some files:

* `runtime/primitives`
* `runtime/prims.c`

OBazl uses `runtime/primitives.json` to generate these files (and
renames `primitives` to `primitives.dat`).

[WARNING]
====
**Objection**: under the legacy build, the C sources are the
authoritative source of information on primitives. Using
`runtime/primitives.json` means we now have two sources of info.

**Response 1** We could generate `runtime/primitives.json` at
  configure-time and use it at build-time, just to eliminate shell
  scripts and tools from the build process.

**Response 2** We could emit `primitives.h` containing one macro for
  each primitive and include it in each file defining a primitive. For example instead of (in alloc.c)

  CAMLprim value caml_alloc_dummy(value size)

we could have something like

  CAMLprim_alloc_dummy(value size)

with `CAMLprim_alloc_dummy` a macro that expands appropriately. But I
guess that does not really buy us anything.


**Response 3** We could also templatize the c sources in some manner
====
