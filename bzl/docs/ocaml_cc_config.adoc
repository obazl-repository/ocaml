= ocaml_cc config
:toc: auto
:toclevels: 3

The OCaml compilers are actually compiler drivers, more like gcc than
a compiler. Like gcc, they may invoke the C compiler, assembler, or
linker.

== assembler

OCaml native compilers may emit commands to assemble a file. You can
see this by passing `-verbose` to the OCaml compiler (in a target's
'opts' attr or by passing `--//config/ocaml:verbose`).

For example on Mac:

  gcc -c -Wno-trigraphs  -o '/var/.../camlstartup16e89b.o' '/var/.../camlstartupb205fe.s'

This command is stored in `Config.asm` at configure-time. It is used
by the `Proc` modules defined for each supported arch under `asmcomp`;
for example `asmcomp/arm64/proc.ml`, or `asmcomp/X86_proc.ml`.
Ultimately it gets passed to a call to `system(3)` (in
`runtime/sys.c`) which passes it to `sh(1)`.


TODO:

1.  Replace this command string with one derived from the CC toolchain selected by Bazel
2. Use `posix_spawn` (or vfork + exec) to run the command instead of `system` (avoid launching a shell)

See link:https://blog.famzah.net/2018/12/19/posix_spawn-performance-benchmarks-and-usage-examples/[posix_spawn() performance benchmarks and usage examples]

== linker
The command lines used are fixed at config-time (by `/.configure`) as
members of the Config module:

* mkexe - cmd to link an executable, used e.g. when building a native executable
* mkdll etc. - windows stuff

The problem with this is that ocaml_cc build actions are outside the
control of Bazel. In particular, the mkexe command line generated
by ./configure will not (probably) match the one used by Bazel. Recall
that Bazel has its own "configure" mechanism for the CC toolchain; it
interrogates the system to discover the toolchain and has its own
ideas about which arguments should be passed when invoking the tools.

A second problem is that there is no way to pass user flags to the
ocaml_cc link action.  [Correction: the -cclib and --ccopt options allow this.]

For example, on Ubuntu 20.04 the ./configure setting for mkexe is:

* `gcc -O2 -fno-strict-aliasing -fwrapv -pthread -Wl,-E`

First point: all but the last two are compile options, not link options.

This will use the standard `ld` linker.

Bazel uses the following args for linking executables:

* `-fuse-ld=gold -Wl,-no-as-needed -Wl,-z,relro,-z,now -B/usr/bin -pass-exit-codes -lstdc++`

These are all linker options.

This is what will be used to link CC executables for the build, since
OBazl uses `cc_binary` for them ( `//runtime:ocamlrun`, `//yacc:ocamlyacc`).



Now the problem is that Bazel constructs this command line at build
time. But the source for module `Config` is fixed at config-time. So
there are several ways to integrate Bazel into this protocol.

1. Use a custom Bazel rule to be executed using `bazel run` instead of
`bazel build`, and have it write out a config file. This would
essentially be a kind of Bazel `./configure` rule.

2. Use build-time preprocessing to generate the Config source in such
a way that it contains the Bazel-generated link args. Input to the
preprocessing target would be a file generated by `./configure`; the
pp rule would extract the link cmds from the cc toolchain selected by
Bazel. **This is the current strategy.** See the "config" targets in link:../../../config/BUILD.bazel[//config:BUILD.bazell].

3. Use the OCaml options `-cc`, `-ccopt`, `-cclib`. Passing `-cc`
overrides mkexe, but requires that any args be passed with `-ccopt`,
which will be placed after the `-o` and `-L` args.


