= Testing guide
:toc: auto
:toclevels: 3

The test rules are documented in article xref:test_rules.adoc[Test rules].

== Quickstart

TIP: By default the test runner will halt at the first error. Pass
`--keep_going` to keep going.

=== Running tests

Test target names are constructed from filename stems normalized to
module names; they always have suffix `_test`. For example, from
`arrays.ml` we get `Arrays_test` (suite of all tests for that file),
`Arrays_vv_test`, `Arrays_vs_test`, `Arrays_ss_test`,
`Arrays_sv_test`.

* Run all tests currently implemented:

  ** `$ bazel test testsuite/tests`

WARNING: This may take a while. Each test is run once per compiler, so
this target builds all the compilers, builds all the tests, and runs all the tests.

* Run all the tests for `testsuite/tests/basic`:

  ** `$ bazel test testsuite/tests/basic:tests`

* Run all the `ocamlc.byte` tests for `testsuite/tests/basic`:

  ** `$ bazel test testsuite/tests/basic:tests --test_tag_filters=vv`

* Run all the `ocamlc.byte` and `ocamlopt.opt` tests for `testsuite/tests/basic`:

  ** `$ bazel test testsuite/tests/basic:tests --test_tag_filters=vv,ss`

* Run the test suite for `testsuite/tests/basic/arrays.ml`:

  ** `$ bazel test testsuite/tests/basic:Arrays_test`

* Run the `ocamlc.byte` test for `testsuite/tests/basic/arrays.ml`:

  ** `$ bazel test testsuite/tests/basic:Arrays_test --test_tag_filters=vv`
  ** or: `$ bazel test testsuite/tests/basic:Arrays_vv_test`

* Run the `ocamlc.byte` and `ocamlopt.opt` tests for
  `testsuite/tests/basic/arrays.ml`:

  ** `$ bazel test testsuite/tests/basic:Arrays_test --test_tag_filters=vv,ss`

=== Building, linking, and running test executables

Bazel test rules (like our `expect_test`, `ocaml_test` etc.) must emit
an executable, which the Bazel test machinery will then run. The
`rules_ocamlcc` test rules emit shell script executables that run test
OCaml executables, rather than linking and emitting OCaml executables.
Linking the test executables is the responsibility of a separate
family of rules, `test_executable . So test cases have the following
dependency structure:

----
compile test module -> link test executable -> run test executable
----

This makes it possible to develop test cases outside of the test
framework. Specically, you can run your test executable as an ordinary
executble, in order to develop its stdout, before running it under the
control of the testing apparatu[qs.

The `arrays.ml` test emits nothing to stdout, so for the following we
will use `boxedints.ml` instead, which does.

* Compile test_module `testsuite/tests/basic:boxedints.ml`

  ** `$ bazel build testsuite/tests/basic:Boxedints`

* Link the test executables for `testsuite/tests/basic:boxedints.ml` without running them:

  ** `$ bazel build testsuite/tests/basic:Boxedints.vv.byte`
  ** `$ bazel build testsuite/tests/basic:Boxedints.vs.opt`
  ** `$ bazel build testsuite/tests/basic:Boxedints.ss.opt`
  ** `$ bazel build testsuite/tests/basic:Boxedints.sv.byte`

* Run the test executables directly (not using `bazel test`), to examine stdout:
  ** `$ bazel run testsuite/tests/basic:Boxedints.vv.byte.sh`
  ** `$ bazel run testsuite/tests/basic:Boxedints.vs.opt`
  ** `$ bazel run testsuite/tests/basic:Boxedints.ss.opt`
  ** `$ bazel run testsuite/tests/basic:Boxedints.sv.byte.sh`

NOTE: For example, `$ bazel run
testsuite/tests/basic:Boxedints.sv.byte.sh` will use the baseline
`ocamlc.opt` compiler (`sv` == **s**ys->**v**m) to compile
`testsuite/tests/basic/boxedints.ml` as a bytecode executable, and
then run it. The `ocamlc.opt` compiler will be incrementally rebuilt
if any of its sources have changed, or if its configuration settings
have changed.


== Default configuration

By default tests do _not_ automatically load and open `Stdlib`. This
is contrary to the default of the standard releases, which always load
`stdlib.cmx?a` and open `Stdlib`; see link:stdlib.adoc[Stdlib] for
justification.

In practice this means that tests are built with options `-nostdlib`
and `-nopervasives`, and each test target must explicitly enumerate
its dependencies, including any dependency on either the `Stdlib`
module or any submodules in the `Stdlib` namespace (i.e. contained in
the `stdlib.cmx?a` archive). The Bazel rules will detect a dependency
on the `Stdlib` module and automatically add `-open Stdlib` if such a
dependency is detected.

The build target for the `Stdlib` module is `//stdlib:Stdlib`. Since
that module serves two purposes - it implements a set of primitives on
the one hand, and it defines the aliasing equations for the `Stdlib`
namespace on the other - we define an alias `//stdlib:Primitives`;
this can be used to express dependencies a little more precisely. A
module that depends on `Stdlib` for primitives but does not depend on
any `Stdlb` submodules can express this by listing
`//stdlib:Primitives` rather than `//stdlib:Stdlib` as a dependency.
Note that this is intented solely a hint to the human reader.

IMPORTANT: Do not confuse `//stdlib:Stdlib` and `//stdlib`; the former
builds module `Stdlib`, the latter builds archive `stdlib.cmx?a`. It
is not necesssary to depend on the archive in order to depend on a
submodule.  See link:stdlib.adoc[Stdlib] for more information.

If a test depends on primitives from `Stdlib`, or on submodules in
stdlib, configure the target as follows:

* module depends on primitives in module `Stdlib`, but not on
  submodules in namespace `Stdlib`:
 ** `deps = ["//stdlib:Primitives"]`
* module depends on a submodule - say, `Bool`  in `Stdlib`, but not on any primitives:
 ** `deps = ["//stdlib:Stdlib.Bool"]`
* module depends on both a primitive and a submodule:
 ** `deps = ["//stdlib:Primitives", "//stdlib:Stdlib.Bool"]`
* if you do not care about fine-grained dependencies, you can just
  depend on the archive, `//stdlib`. The drawback of this is that the
  archive will be rebuilt whenever any of its submodules changes.

FIXME: well, not necessarily. We can choose between archived and
non-archived libraries. The default is non-archived, which means that
`//stdib` delivers all the modules in `Stdlib`, unarchived.


For example, running
`testsuite/tests/basic:patmatch_for_multiple_test` without
`deps=["//stdlib:Primitives"]` results in a longish error report, in
which we find:

----
> 3 | | ((1, _, _) as x) -> ignore x; true
>                           ^^^^^^
> Error: Unbound value ignore
----

This tells us that the module depends on the `ignore` primitive, which
is defined in module `Stdlib`. So this error can be corrected by
adding `//stdlib:Primitives` as a dependency.


