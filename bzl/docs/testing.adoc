= testing
:toc: auto
:toclevels: 3


== quickstart

=== running tests

Test target names are constructed from filename stems normalized to
module names; they always have suffix `_test`. For example, from
`arrays.ml` we get `Arrays_test` (suite of all tests for that file),
`Arrays_vv_test`, `Arrays_vs_test`, `Arrays_ss_test`,
`Arrays_sv_test`.

* Run all the tests for `testsuite/tests/basic`:

  ** `$ bazel test testsuite/tests/basic:tests`

* Run all the `ocamlc.byte` tests for `testsuite/tests/basic`:

  ** `$ bazel test testsuite/tests/basic:tests --test_tag_filters=vv`

* Run all the `ocamlc.byte` and `ocamlopt.opt` tests for `testsuite/tests/basic`:

  ** `$ bazel test testsuite/tests/basic:tests --test_tag_filters=vv,ss`

* Run the test suite for `testsuite/tests/basic/arrays.ml`:

  ** `$ bazel test testsuite/tests/basic:Arrays_test`

* Run the `ocamlc.byte` test for `testsuite/tests/basic/arrays.ml`:

  ** `$ bazel test testsuite/tests/basic:Arrays_test --test_tag_filters=vv`
  ** or: `$ bazel test testsuite/tests/basic:Arrays_vv_test`

* Run the `ocamlc.byte` and `ocamlopt.opt` tests for
  `testsuite/tests/basic/arrays.ml`:

  ** `$ bazel test testsuite/tests/basic:Arrays_test --test_tag_filters=vv,ss`

=== building and linking test executables

The `arrays.ml` test emits nothing to stdout, so for the following we
will use `boxedints.ml` instead, which does.

* Compile `testsuite/tests/basic:boxedints.ml`

  ** `$ bazel build testsuite/tests/basic:Boxedints`

* Link the test executables for `testsuite/tests/basic:boxedints.ml` without running them:

  ** `$ bazel build testsuite/tests/basic:__Boxedints.vv.byte`   [NB: leading underscores]
  ** `$ bazel build testsuite/tests/basic:Boxedints.vs.opt`
  ** `$ bazel build testsuite/tests/basic:Boxedints.ss.opt`
  ** `$ bazel build testsuite/tests/basic:__Boxedints.sv.byte`

* Run the test executables directly (not using the test runner), to examine stdout:
  ** `$ bazel run testsuite/tests/basic:Boxedints.vv.byte`
  ** `$ bazel run testsuite/tests/basic:Boxedints.vs.opt`
  ** `$ bazel run testsuite/tests/basic:Boxedints.ss.opt`
  ** `$ bazel run testsuite/tests/basic:Boxedints.sv.byte`

=== queries

* link:https://bazel.build/query/guide[Bazel query guide]
* link:https://bazel.build/query/language[Bazel query reference]

TIP: For each query you can ask for several kinds of output: `build`
displays build code; `label` displays the target label; `label_kind`
displays the both the target label and rule name; etc. - see link:https://bazel.build/query/language#output-formats[Output formats] for more information.

CAUTION: Don't forget to quote the query expressions.

* List all rules used in package `//testsuite/tests/basic`:

  bazel query 'kind(rule, testsuite/tests/basic:*)' --output label_kind | sort

Macro `expect_test` expands to targets using rules `expect_vv_test`,
`expect_vs_test`, etc. (one per compiler):

* List all targets generated by macro `expect_test` in `//testsuite/tests/basic`:

    bazel query 'attr(generator_function, expect_test, //testsuite/tests/basic/...)'

* List all `expect_vv_test` targets:

    bazel query 'kind("expect_vv_test", testsuite/tests/basic:*)' --output label_kind | sort

* List all `test_suite` targets:

  bazel query 'kind("test_suite", testsuite/tests/basic:*)' --output label_kind | sort

* List the tests that `test_suite` target `//testsuite/tests/basic:Boxedints_test` expands to:

    bazel query 'tests(//testsuite/tests/basic:Boxedints_test)'

The `expect_test` macro contains a nested macro, `test_executable`.

* List the targets that `test_executable` expands to:

     bazel query 'kind("test_executable", testsuite/tests/basic:*)' --output label_kind | sort

* List all the `test_module` targets:

    bazel query 'kind("test_module", testsuite/tests/basic:*)' --output label_kind | sort

* Show targets whose label contains "int" by filtering with a regex:

    bazel query 'filter(".*int.*", kind(".*_test rule", //testsuite/tests/basic...))'

==== inspecting build code

* Show the code of a particular `expect_vv_test` target:

    bazel query testsuite/tests/basic:Boxedints_vv_test --output=build

* Show the code for the `test_executable` used by `//testsuite/tests/basic:Boxedints_vv_test`:

    bazel query testsuite/tests/basic:Boxedints.vv.byte --output=build

* Expand all macros in `testsuite/tests/basic/BUILD.bazel`:

    bazel query testsuite/tests/basic/...  --output=build
    or: bazel query 'testsuite/tests/basic/...:*'  --output=build

* Expand the `expect_test` macro for target `testsuite/tests/basic:Boxedints_test`:

    bazel query testsuite/tests/basic:Boxedints_test  --output=build

* Expand the `test_executable` macro for target `testsuite/tests/basic:Boxedints.ss.opt`:

    bazel query testsuite/tests/basic:Boxedints.ss.opt  --output=build

==== dependencies

* What build files does a target depend on?

    bazel query 'buildfiles(deps(//testsuite/tests/basic:Arrays))'

* Why does `//testsuite/tests/basic:Arrays_test` depend on
  `//stdlib:Stdlib.Array`?

    bazel cquery 'somepath(testsuite/tests/basic:Arrays_test, stdlib:Stdlib.Array)'

NOTE: The `cquery` command runs _after_ all `select` functions have been resolved.

* Which targets depend on Stdlib.Gc

     bazel cquery 'testsuite/tests/basic/... intersect allpaths(testsuite/tests/basic/..., stdlib:Stdlib.Gc)' | sort

* Show length of dependency paths for a target:

    bazel query 'deps(//testsuite/tests/basic:Arrays)' --output maxrank


== Default configuration

By default tests do _not_ automatically load and open `Stdlib`. This
is contrary to the default of the standard releases, which always load
`stdlib.cmx?a` and open `Stdlib`; see link:stdlib.adoc[Stdlib] for
justification.

In practice this means that tests are built with options `-nostdlib`
and `-nopervasives`, and each test target must explicitly enumerate
its dependencies, including any dependency on either the `Stdlib`
module or any submodules in the `Stdlib` namespace (i.e. contained in
the `stdlib.cmx?a` archive). The Bazel rules will detect a dependency
on the `Stdlib` module and automatically add `-open Stdlib` if such a
dependency is detected.

The build target for the `Stdlib` module is `//stdlib:Stdlib`. Since
that module serves two purposes - it implements a set of primitives on
the one hand, and it defines the aliasing equations for the `Stdlib`
namespace on the other - we define an alias `//stdlib:Primitives`;
this can be used to express dependencies a little more precisely. A
module that depends on `Stdlib` for primitives but does not depend on
any `Stdlb` submodules can express this by listing
`//stdlib:Primitives` rather than `//stdlib:Stdlib` as a dependency.
Note that this is intented solely a hint to the human reader.

IMPORTANT: Do not confuse `//stdlib:Stdlib` and `//stdlib`; the former
builds module `Stdlib`, the latter builds archive `stdlib.cmx?a`. It
is not necesssary to depend on the archive in order to depend on a
submodule.  See link:stdlib.adoc[Stdlib] for more information.

If a test depends on primitives from `Stdlib`, or on submodules in
stdlib, configure the target as follows:

* module depends on primitives in module `Stdlib`, but not on
  submodules in namespace `Stdlib`:
 ** `deps = ["//stdlib:Primitives"]`
* module depends on a submodule - say, `Bool`  in `Stdlib`, but not on any primitives:
 ** `deps = ["//stdlib:Stdlib.Bool"]`
* module depends on both a primitive and a submodule:
 ** `deps = ["//stdlib:Primitives", "//stdlib:Stdlib.Bool"]`
* if you do not care about fine-grained dependencies, you can just
  depend on the archive, `//stdlib`. The drawback of this is that the
  archive will be rebuilt whenever any of its submodules changes.

FIXME: well, not necessarily. We can choose between archived and
non-archived libraries. The default is non-archived, which means that
`//stdib` delivers all the modules in `Stdlib`, unarchived.


For example, running
`testsuite/tests/basic:patmatch_for_multiple_test` without
`deps=["//stdlib:Primitives"]` results in a longish error report, in
which we find:

----
> 3 | | ((1, _, _) as x) -> ignore x; true
>                           ^^^^^^
> Error: Unbound value ignore
----

This tells us that the module depends on the `ignore` primitive, which
is defined in module `Stdlib`. So this error can be corrected by
adding `//stdlib:Primitives` as a dependency.


== Test rules

Source code: link:../../test/rules[test/rules]

Common attributes: certain attributes are supported by all test rules; see link:https://bazel.build/reference/be/common-definitions#common-attributes-tests[Attributes common to all test rules] for more information.

In particular:

* `tags`: list of strings. Tags can be used to group tests; running
tests with `--test_tag_filters=<tags>` will select targets annotated
with the listed tags.  Currently we use the following tags:

  ** `inline_expect`
  ** `vv` - tests built using the ocamlc.byte compiler
  ** `ss` -  tests built using the ocamlopt.opt compiler
  ** `vvss` -  tests built using either ocamlc.byte or ocamlopt.opt


=== rule: ocaml_test

Standard unit tests, where test code is in the compiled test
executable, which just reports pass//fail. No output files, so no
actual/expected diffing (except within the test code itself).

=== rule: ocaml_compile_test



=== rule: expect_test

Expect tests run a test executable, which must emit some result to
stdout; redirects stdout to an "actual" file; compares actual to
expected.

There is one expect test rule per compiler; they are named using the
abbreviations explained in link:terminology[symbols & terminology], in
order to indicate which compiler is used to build the test. The naming
schema is `expect_<compiler>_test`. For example, the `expect_vv_test`
uses `ocamlc.byte` to build its target.

Standard compilers:

* `expect_vv_test` - ocamlc.byte
* `expect_vs_test` - ocamlopt.byte
* `expect_ss_test` - ocamlopt.opt
* `expect_sv_test` - ocamlc.opt

Flambda-enabled:

* `expect_vS_test` - ocamloptx.byte
* `expect_SS_test` - ocamloptx.optx
* `expect_Ss_test` - ocamlopt.optx
* `expect_Sv_test` - ocamlc.optx

Rule attributes:

* `test_executable`: the executable to run; must be built by rule `test_executable` (which see)
* `stdout`: label; name of file to which stdout will be redirected (i.e. "actuals" file)
* `expected`: label of the file containing expected output

Test target naming schema: `<executable>_<compiler>_test`. For
example, for `testsuite/tests/basic/bigints.ml` we have the following test targets:

* `:Bigints_vv_test`
* `:Bigints_vs_test`
* `:Bigints_ss_test`
* `:Bigints_sv_test`

and similar for flambda.

=== rule: text_executable



=== rule: inline_expect_test

Runs the `testsuite/tools/expect_test.ml` tool (under the name
`inline_expect`).

Attributes:

* `src` - a .ml file (or .mli?)


=== rule: lambda_expect_test



=== rule: compile_fail_test


== Working with Bazel tests

=== inspecting test targets

We use some macros to create test targets, so the actual Bazel code
for the targets is hidden. To inspect the code you use Bazel's `query`
facilities:

* ` bazel query --output=build '//testsuite/tools/basic:*'

=== tags

Tests are annotated with "tag" strings, which can be used to select
subsets of the tests. For example, all tests that use `ocamlc.byte` to
build the test are tagged with `vv`. The `--test_tag_filters`
command-line arg can be used to run tests for a given list of tags.
For example to run all of the `ocamlc.byte` tests in `testsuite/tests/basic`:

* `bazel test testsuite/tests/basic:tests --test_tag_filters=foo,bar`



=== test suites

https://bazel.build/reference/test-encyclopedia#tag-conventions

Tags: small, medium, large, smoke

"smoke	test_suite convention; means it should be run before committing code changes into the version control system"

=== private test suites

You can define _ad-hoc_ `test_suite` rules in `private/BUILD.bazel`.

For example suppose you are making changes involving ints. Relevant
tests may be scattered throughout `testsuite/tests`; you can create a
custom test suite that will run just the tests you want, such as:

[source,python]
.private/BUILD.bazel
----
test_suite(
    name = "ints",
    tests = [
        "//testsuite/tests/basic:bigints_test",
        "//testsuite/tests/basic:boxedints_test",
        "//testsuite/tests/basic:divint_test",
        "//testsuite/tests/basic:min_int_test",
        "//testsuite/tests/int64-unboxing:test_test:",
        "//testsuite/tests/lib-int:test_test:",
        "//testsuite/tests/lib-int64:test_test:",
        ## etc.
    ]
)
---
