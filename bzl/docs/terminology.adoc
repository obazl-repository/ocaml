= Terminology & symbols
:toc: auto
:toclevels: 3


== terminology

[[archive]]Archive::
An archive is a <<library>> packaged as an OCaml archive file (`.cma`
  or `.cmxa` file). Archives are expressed by library rules with
  attribute `archive` set to True.
+
NOTE: The OCaml sources use only a few librarys (which are expressed
as archives in the legacy Makefile system); for example,
`stdlib.cmx?a`, `ocamlbytecomp.cmx?a`. The `rules_ocamlcc` rules
expresses these as unarchived libraries by default. A global switch,
[.nowrap]`--//config/ocaml/compiler/libs:archived`, may be set to
switch to archived libraries. For more information see
xref:libraries.adoc[Libraries & Archives] and
xref:stdlib.adoc[stdlib].

Filesystem module (fs-module)::

A module deterimined by a source file; for example, file `a.ml`,
determines module `A`, which is thereby a filesystem module or
fs-module for short.

[[library]]Library:: A named collection of modules and/or signatures,
expressed using rules `compiler_library`, `test_library`, etc.

Namespace::
OCaml does not have first-class namespaces, and it does not define a
mapping between symbol "paths" like `A.B.C` and the file system. Each
module effectively determines a namespace, but only for the symbols
defined within it and symbols for fs-modules that the compiler can
find in its search path. There is no built-in method for mapping the
`B` in `A.B` to the file system (e.g. as a file `a/b.ml`). The OCaml
namespace is "flat".
+
This can be a problem because without namespacing name collisions are
more likely. To prevent them two mechanisms are provided: "packed"
modules and module aliasing. A packed module serves as a namespace for
the modules it contains; no collisions are possible just because it
physically contains its submodules. Module aliasing makes it possible
to give modules names likely to be globally unique (usually by
prefixing a psuedo-namespace string like `+Foo__+`) but still refer to
them with short names. For example the `B` in `A.B` can be aliased to
`A__B` (or `foobarbaz`, for that matter). Mangling the actual filename
and using an alias to make it "nice" can prevent name collisions, but
it's still not true namespacing. Or rather it's not "closed"
namespacing; nothing forces reference to the mangled module name to go
through the alias; aliasing does not make it an element of any
hierarchical namespace.
+
The compiler sources in the legacy Makefile system use one
packed-module namespace (`Dynlink_compilerlibs`) and one aliasing
namespace, `Stdlib`.


[[resolver]]NS Resolver:: An _ns resolver module_ (or just 'resolver' for
short) is a module containing module aliasing equations used to
implement OCaml's pseudo-namespaces. In the OCaml community this is
often called a "wrapper", but we eschew this term since there is no
real wrapping going on. A resolver merely provides information the
compiler needs to resolve module symbols.
+
The compiler only uses one aliasing namespace and thus one resolver
module: `Stdlib`. The Bazel build adds a resolver for a second
namespace, `Dynlink_compilerlibs`, which is implemented as a "packed"
module the legacy Makefile system. See link:dynlink.adoc[dynlink] for
more information.

Output group:: A collection of output files for a target that may be
requested using `--output_groups` on the command line. See
xref:output_groups.adoc[Output groups] for more information.

Provider:: A provider is a kind of specialized struct (in the Starlark
language). Bazel rules use providers to deliver their outputs.

Sigfile::
A `.mli` source file.

Structfile::
A `.ml` source file.

Starlark::
The language of Bazel.  A constrainted Python variant.

Toolchain::
A toolchain is ...

Toolchain adapter::
A tc is ...

Toolchain selector::
A tc selector ...

Toolset::
A toolset is a collection of tools.

== compiler structure

The compilers are composed of:

Runtime:: The runtime, written in C, contains the primitives, the
   memory manager, and... some other stuff. Runtimes are specified as
   <os>_<arch>, e.g. `macos_amd64` or as `sys`, indicating "whatever
   the local system architecture is".
+
NOTE: All compilers use a C runtime; for local builds (not involving
cross-compilation) it is always `sys`, and it need not be mentioned
explicitly.

Executor:: The executor is composed of two parts:
+
  ** The *compiler* proper, and
  ** The *command processor* or driver. The command processor is
    resposible for accepting user requests and directing the
    compiler's operations. For the standard compilers, user requests
    are the arguments passed via the command line; for a service
    working compiler, they would be protocol requests received from an
    input stream.
+
Executors are specified as `vm` or `sys`. For cross-compilation, `sys`
executor implies whatever the runtime is (e.g. `linux_arm64`)
+
Emitter:: The emitter is responsible for emitting the compiled code.
   Obviously the line between compiler and emitter is vague. There are
   two types: vm and sys.

To fully specify a build target we need to specify all three parts.  The form is

`<runtime>_<executor>_<emitter>`

This level of explicitness is only needed for cross-compilation. For
local builds, `<runtime>_` may be omitted.

=== standard compiler names:

Standard naming schema: `ocaml<emitter>.<executor>`, where `<emitter>`
is `c` or `opt`, and `<executor>` is `byte` or `opt`. The bazel rules
use standard naming for compiler names: `ocamlc.byte`,
`ocamlopt.byte`, `ocamlopt.opt`, `ocamlc.opt`.

Names for flambda-enabled compilers use `optx`:

* `ocamloptx.byte` - vm executor, flambda emitter (emits flambda-optimized native code)
* `ocamlc.optx` - executor: flambda-optimized native compiler emitting bytecode
* `ocamloptx.optx` - flambda-optimized native compiler emitting flambda-optimized native code
* `ocamlopt.optx` - flambda-optimized native compiler emitting (non-flambda) native code
* `ocamloptx.opt` - un-optimized native compiler emitting flambda native code

=== OCamlCC naming conventions

Bazel rules and non-compiler build targets (e.g. test targets) use the
following abbreviations:

* `vv` - vm executor and emitter: `ocamlc.byte`
* `vs` - vm executor, sys emitter:  `ocamlopt.byte`
* `ss` - sys executor, sys emitter: `ocamlopt.opt`
* `sv` - sys executor, vm emitter: `ocamlc.opt`

Flambda uses 'x':

* `vx` - vm executor, flambda emitter:  `ocamloptx.byte`
* `xx` - flambda executor, flambda emitter: `ocamloptx.optx`
* `xv` - flambda executor, vm emitter: `ocamlc.optx`
* `xs` - flambda executor, sys emitter: `ocamlopt.optx`
* `sx` - sys executor, flambda emitter: `ocamloptx.opt`

Special case:  `BS` for `boot/ocamlc` (vm executor and emitter)

These abbreviations are used to construct the working directory for
compiler builds, thus encoding the provenance of each compiler. For
example, the working directory for `ocamlopt.optx` is:

    ocamlcc/bin/_BS_vx_xx_xx/ocamlopt.optx

which indicates that `boot/ocamlc` built `ocamloptx.byte`, which built
`ocamloptx.optx`, which built itself (another `ocamloptx.optx), which
built the `ocamlopt.optx` shown. The actual build command that printed
this is:

----
[ bazel-out/darwin-fastbuild-ST-4ec7cbaf6f37/bin/bin/_BS_vx_xx/ocamloptx.optx \
    bazel-out/darwin-opt-exec-2B5CBBC6-ST-3c4e7a86d990/bin/runtime/libasmrun.a \
    -nostdlib \
    ... other options ...
    -I ... (include directives elided) ...
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/stdlib/_BS_vx_xx_xx/CamlinternalFormatBasics.cmx \
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/stdlib/_BS_vx_xx_xx/Stdlib.cmx \
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/stdlib/_BS_vx_xx_xx/Stdlib__Sys.cmx \
    ... other module deps, elided ...
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/driver/_BS_vx_xx_xx/Optmaindriver.cmx \
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/driver/_BS_vx_xx_xx/Optmain.cmx \
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/stdlib/_BS_vx_xx_xx/std_exit.cmx \
    -o \
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/bin/_BS_vx_xx_xx/ocamlopt.optx)
----

In other words, the working directory indicates which compiler was
used to build whatever it contains.

IMPORTANT: The build command excerpted above shows the effect of using
unarchived libraries; with archiving enabled, the listed `.cmx`
dependencies would be packaged into a few archive files.

IMPORTANT: The listing also shows that the ocamlcc Bazel code makes
all dependencies explicit. In a "standard" build, the standard library
`stdlib.cmxa` (shown here unarchived), module `std_exit.cmx`, and
`libasmrun.a` would be found and loaded automatically by the compiler
and thus hidden from the user. The Bazel rules prioritize explicitness.

The abbreviations are also used to name test rules and targets; see link:testing.adoc[testing] for more information.
