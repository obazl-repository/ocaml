= Terminology & symbols
:toc: auto
:toclevels: 3


== Terminology

[[archive]]Archive::
An archive is a <<library>> packaged as an OCaml archive file (`.cma`
  or `.cmxa` file). Archives are expressed in Bazel by library rules with
  attribute `archive` set to True.
+
NOTE: The OCaml sources use only a few librarys (which are expressed
as archives in the legacy Makefile system); for example,
`stdlib.cmx?a`, `ocamlbytecomp.cmx?a`. The `rules_ocamlcc` rules
expresses these as unarchived libraries by default. A global switch,
[.nowrap]`--//config/ocaml/compiler/libs:archived`, may be set to
switch to archived libraries. For more information see
xref:libraries.adoc[Libraries & Archives] and
xref:stdlib.adoc[stdlib].

[[build_action]]Build action:: Compilation, linking, symlinking, preprocessing, or any
other process involved in producing the output of a build target. A
single build target may produce more than one build action. For
example the rules responsible for compiling <<structfile>>s generate
at least two build actions: one to symlink the source file to a
working directory, and one to compile the (symlinked) source file.
+
IMPORTANT: Build actions need not "build" anything. Most of them do
run tools that build stuff, like compilers and linkers, so they are
invoked by `bazel build`. But the build action generated by a rule can
also run tools and programs purely for their side-effects; they are
intended to be used with `bazel run` rather than `bazel build`. For
example, target `//boot:checkpoint` runs build actions that build the
compilers and tools, and then copies the output to a directory
(`.baseline`). Running `bazel run @dev//bin:repl` launches the OCaml
toplevel repl.

Build rule:: A Bazel build rule is a function-like routine whose role
is to express one or more <<build_action>>s. Build rules are defined
in `*.bzl` files and used (applied to arguments) in `BUILD.bazel`
files. Applying a build rule has the effect of registering its
actions, inputs, outputs, etc. with the Bazel build engine, which is
responsible for orchestrating the ordering and execution of build
actions. Build rules are written
link:https://bazel.build/rules/language[Starlark], which is based on
Python 3. See
link:file:///Users/gar/obazl-repository/ocamlcc/bzl/docs/rules.adoc[rules]
for more information.

Build target:: Each build target is expressed as a xref:rules.adoc[build rule]
application and has a unique name, which is expressible as a Bazel
label.
+
IMPORTANT: In Bazel, _everything_ is expressed as a build target (rule), including configuration settings and flags.

Filesystem module (fs-module)::

A module deterimined by a source file; for example, file `a.ml`,
determines module `A`, which is thereby a filesystem module or
fs-module for short.

[[library]]Library:: A named collection of modules and/or signatures,
expressed using rules `compiler_library`, `test_library`, etc. By
default library targets do _not_ produce archive files (`.cmx?a`) -
they have an attribute, `archive`, that defaults to `False` but may be
set to `True` for individual targets. See
xref:libraries.adoc[Libraries & Archives] for more information.

Namespace::
OCaml does not have first-class namespaces, and it does not define a
mapping between symbol "paths" like `A.B.C` and the file system. Each
module effectively determines a namespace, but only for the symbols
defined within it and symbols for fs-modules that the compiler can
find in its search path. There is no built-in method for mapping the
`B` in `A.B` to the file system (e.g. as a file `a/b.ml`). The OCaml
namespace is "flat".
+
This can be a problem because without namespacing name collisions are
more likely. To prevent them two mechanisms are provided: "packed"
modules and module aliasing. A packed module serves as a namespace for
the modules it contains; no collisions are possible just because it
physically contains its submodules. Module aliasing makes it possible
to give modules names likely to be globally unique (usually by
prefixing a psuedo-namespace string like `+Foo__+`) but still refer to
them with short names. For example the `B` in `A.B` can be aliased to
`A__B` (or `foobarbaz`, for that matter). Mangling the actual filename
and using an alias to make it "nice" can prevent name collisions, but
it's still not true namespacing. Or rather it's not "closed"
namespacing; nothing forces reference to the mangled module name to go
through the alias; aliasing does not make it an element of any
hierarchical namespace.
+
The compiler sources in the legacy Makefile system use one
packed-module namespace (`Dynlink_compilerlibs`) and one aliasing
namespace, `Stdlib`.


[[resolver]]NS Resolver:: An _ns resolver module_ (or just 'resolver' for
short) is a module containing module aliasing equations used to
implement OCaml's pseudo-namespaces. In the OCaml community this is
often called a "wrapper", but we eschew this term since there is no
real wrapping going on. A resolver merely provides information the
compiler needs to resolve module symbols.
+
The compiler only uses one aliasing namespace and thus one resolver
module: `Stdlib`. The Bazel build adds a resolver for a second
namespace, `Dynlink_compilerlibs`, which is implemented as a "packed"
module the legacy Makefile system. See link:dynlink.adoc[dynlink] for
more information.

Output group:: A collection of output files for a target that may be
requested using `--output_groups` on the command line. See
xref:output_groups.adoc[Output groups] for more information.

Package:: This term has a very specific meaning for Bazel: a package
is determined by a `BUILD.bazel` file. For example,
`foo/bar/BUILD.bazel` determines package `//foo/bar`.

Primitive::
See xref:primitives.adoc[Primitives].

Provider:: A Bazel provider is a kind of specialized struct (in the Starlark
language). Bazel rules use providers to deliver their outputs.

[[runfiles]]Runfiles:: A _runfile_ is a file needed by a target at runtime.
Runfiles are often data files (e.g. a file of configuration data that
a tool needs to read at runtime) but may also be executable files or
libraries. See link:https://bazel.build/rules/lib/runfiles[runfiles^] and link:https://bazel.build/extending/rules#runfiles[Runfiles^].
In `rules_ocamlcc` runfiles are used in must xref:runners.adoc[runner] rules.

[[sigfile]]Sigfile::
A `.mli` source file.

[[structfile]]Structfile::
A `.ml` source file.

link:https://bazel.build/rules/language[Starlark]::
The language of Bazel.  A constrainted Python variant.

[[toolchain]]Toolchain::
A toolchain is ...

Toolchain adapter::
A tc adapter is ...

Toolchain selector::
A tc selector ...

Toolset:: A toolset is a collection of tools. Not to be confused with
a <<toolchain>>, which is a toolset organized in a particular way.

== compiler structure

The compilers are composed of:

Runtime library:: The runtime libraries, of which there are two (one
   native, one for the VM) are written in C and contain the
   primitives, the memory manager, and... some other stuff. Runtimes
   are specified as <os>_<arch>, e.g. `macos_amd64` or as `sys`,
   indicating "whatever the local system architecture is".
+
NOTE: All OCaml compilers use a C runtime library; for local builds (not involving
cross-compilation) it is always `sys`, and it need not be mentioned
explicitly.

Executor:: The executor is composed of two parts:
+
  ** The *compiler* proper, and
  ** The *command processor* or driver. The command processor is
    resposible for accepting user requests and directing the
    compiler's operations. For the standard compilers, user requests
    are the arguments passed via the command line; for a service
    working compiler, they would be protocol requests received from an
    input stream. The VM command processor is a separate program,
    `ocamlrun`; the native command processor is bundled with the
    runtime lib, compiler, and emitter in a single binary.
+
Executors are specified as `vm` or `sys`. For cross-compilation, `sys`
executor implies whatever the runtime is (e.g. `linux_arm64`)
+
Emitter:: The emitter is responsible for emitting the compiled code.
   Obviously the line between compiler and emitter is vague. There are
   two types: vm and sys.

To fully specify a build target we need to specify all three parts.  The form is

`<runtime>_<executor>_<emitter>`

This level of explicitness is only needed for cross-compilation. For
local builds, `<runtime>_` may be omitted.

WARNING: This schema unfortunately breaks down if we use a vm emitter
with `-custom` to link an executable. In that case the output will be
a vm/sys hybrid that can be run directly from the command line without
`ocamlrun`. Haven't figured out what to do about that yet. Another
emitter type? "h" for "hybrid"?

=== standard compiler names:

Standard naming schema: `ocaml<emitter>.<executor>`, where `<emitter>`
is `c` or `opt`, and `<executor>` is `byte` or `opt`. The bazel rules
use standard naming for compiler names: `ocamlc.byte`,
`ocamlopt.byte`, `ocamlopt.opt`, `ocamlc.opt`.

The profiling compilers are also use the standard names:
`ocamlcp.byte`, `ocamlcp.opt`, `ocamloptp.byte`, `ocamloptp.opt`.

Names for flambda-enabled compilers use `optx`:

* `ocamloptx.byte` - vm executor, flambda emitter (emits flambda-optimized native code)
* `ocamloptx.opt` - native executor (un-optimized), flambda emitter
* `ocamlc.optx` - flambda-optimized native executor, bytecode emitter
* `ocamlopt.optx` - flambda-optimized native executor, emitting (non-flambda) native code
* `ocamloptx.optx` - flambda-optimized native executor, emitting flambda-optimized native code

=== OCamlCC Bazel naming conventions

Bazel rules and non-compiler build targets (e.g. test targets) use the
following abbreviations:

* `vv` - vm executor and emitter: `ocamlc.byte`
* `vs` - vm executor, sys emitter:  `ocamlopt.byte`
* `ss` - sys executor, sys emitter: `ocamlopt.opt`
* `sv` - sys executor, vm emitter: `ocamlc.opt`

Flambda uses 'x':

* `vx` - vm executor, flambda emitter:  `ocamloptx.byte`
* `xx` - flambda executor, flambda emitter: `ocamloptx.optx`
* `xv` - flambda executor, vm emitter: `ocamlc.optx`
* `xs` - flambda executor, sys emitter: `ocamlopt.optx`
* `sx` - sys executor, flambda emitter: `ocamloptx.opt`

Special case:  `BS` for `boot/ocamlc` (vm executor and emitter)

These abbreviations are used to construct the working directory for
compiler builds, thus encoding the provenance of each compiler. For
example, the working directory for `//bin:ocamlopt.optx` is:

    ocamlcc/bin/_BS_vx_xx_xx/ocamlopt.optx

which indicates that `boot/ocamlc` built `ocamloptx.byte`, which built
`ocamloptx.optx`, which built itself (another `ocamloptx.optx), which
built the `ocamlopt.optx` shown. The actual build command that printed
this is:

----
[ bazel-out/darwin-fastbuild-ST-4ec7cbaf6f37/bin/bin/_BS_vx_xx/ocamloptx.optx \
    bazel-out/darwin-opt-exec-2B5CBBC6-ST-3c4e7a86d990/bin/runtime/libasmrun.a \
    -nostdlib \
    ... other options ...
    -I ... (include directives elided) ...
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/stdlib/_BS_vx_xx_xx/CamlinternalFormatBasics.cmx \
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/stdlib/_BS_vx_xx_xx/Stdlib.cmx \
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/stdlib/_BS_vx_xx_xx/Stdlib__Sys.cmx \
    ... other module deps, elided ...
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/driver/_BS_vx_xx_xx/Optmaindriver.cmx \
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/driver/_BS_vx_xx_xx/Optmain.cmx \
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/stdlib/_BS_vx_xx_xx/std_exit.cmx \
    -o \
    bazel-out/darwin-fastbuild-ST-163fcd87d216/bin/bin/_BS_vx_xx_xx/ocamlopt.optx)
----

In other words, the working directory indicates which compiler was
used to build whatever it contains.

IMPORTANT: The build command excerpted above shows the effect of using
unarchived libraries; with archiving enabled, the listed `.cmx`
dependencies would be packaged into a few archive files.

IMPORTANT: The listing also shows that the ocamlcc Bazel code makes
all dependencies explicit. In a "standard" build, the standard library
`stdlib.cmxa` (shown here unarchived), module `std_exit.cmx`, and
`libasmrun.a` would be found and loaded automatically by the compiler
and thus hidden from the user. The Bazel rules prioritize explicitness.

The abbreviations are also used to name test rules and targets; see link:testing.adoc[testing] for more information.
