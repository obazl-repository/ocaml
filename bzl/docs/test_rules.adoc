= Test rules
:toc: auto
:toclevels: 3

== Overview

The Bazel test rules for OCamlCC prioritize compositionality, explicitness and expressiveness.

=== Compositionality

The general protocol is: compile test module using rule `test_module`,
link test module to standard executable using `test_executable`, use a
test rule such as `expect_test` to run executable.

In some cases other build actions may be involved (.e.g.
preprocessing), but in all cases tests are composed of these individuated actions.

This gives the developer easy fine-grained control over development.
Each action can be run separately and inspected.

For example, the tests in
link:../../testsuite/tests/lib-dynlink-bytecode[lib-dynlink-bytecode]
exercise the link:https://v2.ocaml.org/manual/libdynlink.html[dynlink]
library, which dynamically loads bytecode libraries, and the runtime
dynamic linker responsible for loading shared libraries (`lib*.so`).
The Bazel rules allow the developer to inspect and verify each step
involved in building and running the tests. For example the developer
might want to verify that a C library has been correctly passed to an
OCaml archive file. Thanks to compositionality this is easily done,
since the archive file is built by a free-standing build target:

    bazel run @dev//bin:lso --//:arg=//testsuite/tests/lib-dynlink-bytecode:plug1_lib

This command runs `ocamlobjinfo` ('lso', list objects, is a simple
alias provided for convenience) against the archive file produced by
the `//testsuite/tests/lib-dynlink-bytecode:plug1_lib` build target.
That target uses the `test_library` rule, and is a dependency of the
test executable target for this test.


=== Expressiveness

CC dependencies can be expressed for modules, libraries/archives, and
executables. Such dependencies are always encapsulated in `CcInfo`
providers, which are always propageted in target dependency graphs. So
you can attach a C library directly to the OCaml module that uses it,
and it will be passed up the chain of dependencies to any executable
that links the OCaml module. If the module is included in an archive,
the C library will automatically be added to the archive metadata.

For example, in the `lib-dynlink-bytecode` test example, `libstub1.a`
is attached to module `Plug.cmo`; the module is included in archive
`plug1_lib.cma`, so `libstub.a` metadata is added to the archive. The
archive in turn is linked into the `:Registry.vv.byte` executable, so
the linker will use the metadata to find `libstub.a` and link it.

IMPORTANT: This works even if `plug1_lib` is an unarchived library. In
that case an archive file will not be created, but the `libstub1.a`
dependency will be propagated in the dependency tree of `Plug.cmo`.
That tree is available to the test executable rule reponsible for
running the OCaml linker, so it will extract the library and add it to the link command line.

== The Rules

Source code: link:../../test/rules[test/rules]

Common attributes: certain attributes are supported by all test rules; see link:https://bazel.build/reference/be/common-definitions#common-attributes-tests[Attributes common to all test rules] for more information.

In particular:

* `tags`: list of strings. Tags can be used to group tests; running
tests with `--test_tag_filters=<tags>` will select targets annotated
with the listed tags.  Currently we use the following tags:

  ** `inline_expect`
  ** `vv` - tests built using the ocamlc.byte compiler
  ** `ss` -  tests built using the ocamlopt.opt compiler

=== rule: ocaml_test

Standard unit tests, where test code is in the compiled test
executable, which just reports pass//fail. No output files, so no
actual/expected diffing (except within the test code itself).

=== rule: ocaml_compile_test



=== rule: expect_test

Expect tests run a test executable, which must emit some result to
stdout; redirects stdout to an "actual" file; compares actual to
expected.

There is one expect test rule per compiler; they are named using the
abbreviations explained in link:terminology[symbols & terminology], in
order to indicate which compiler is used to build the test. The naming
schema is `expect_<compiler>_test`. For example, the `expect_vv_test`
uses `ocamlc.byte` to build its target.

Standard compilers:

* `expect_vv_test` - ocamlc.byte
* `expect_vs_test` - ocamlopt.byte
* `expect_ss_test` - ocamlopt.opt
* `expect_sv_test` - ocamlc.opt

Flambda-enabled:

* `expect_vS_test` - ocamloptx.byte
* `expect_SS_test` - ocamloptx.optx
* `expect_Ss_test` - ocamlopt.optx
* `expect_Sv_test` - ocamlc.optx

Rule attributes:

* `test_executable`: the executable to run; must be built by rule `test_executable` (which see)
* `stdout`: label; name of file to which stdout will be redirected (i.e. "actuals" file)
* `expected`: label of the file containing expected output

Test target naming schema: `<executable>_<compiler>_test`. For
example, for `testsuite/tests/basic/bigints.ml` we have the following test targets:

* `:Bigints_vv_test`
* `:Bigints_vs_test`
* `:Bigints_ss_test`
* `:Bigints_sv_test`

and similar for flambda.

=== rule: text_executable



=== rule: inline_expect_test

Runs the `testsuite/tools/expect_test.ml` tool (under the name
`inline_expect`).

Attributes:

* `src` - a .ml file (or .mli?)


=== rule: lambda_expect_test



=== rule: compile_fail_test


== Working with Bazel tests

=== inspecting test targets

We use some macros to create test targets, so the actual Bazel code
for the targets is hidden. To inspect the code you use Bazel's `query`
facilities:

* ` bazel query --output=build '//testsuite/tools/basic:*'

=== tags

Tests are annotated with "tag" strings, which can be used to select
subsets of the tests. For example, all tests that use `ocamlc.byte` to
build the test are tagged with `vv`. The `--test_tag_filters`
command-line arg can be used to run tests for a given list of tags.
For example to run all of the `ocamlc.byte` tests in `testsuite/tests/basic`:

* `bazel test testsuite/tests/basic:tests --test_tag_filters=foo,bar`



=== test suites

https://bazel.build/reference/test-encyclopedia#tag-conventions

Tags: small, medium, large, smoke

"smoke	test_suite convention; means it should be run before committing code changes into the version control system"

=== private test suites

You can define _ad-hoc_ `test_suite` rules in `private/BUILD.bazel`.

For example suppose you are making changes involving ints. Relevant
tests may be scattered throughout `testsuite/tests`; you can create a
custom test suite that will run just the tests you want, such as:

[source,python]
.private/BUILD.bazel
----
test_suite(
    name = "ints",
    tests = [
        "//testsuite/tests/basic:bigints_test",
        "//testsuite/tests/basic:boxedints_test",
        "//testsuite/tests/basic:divint_test",
        "//testsuite/tests/basic:min_int_test",
        "//testsuite/tests/int64-unboxing:test_test:",
        "//testsuite/tests/lib-int:test_test:",
        "//testsuite/tests/lib-int64:test_test:",
        ## etc.
    ]
)
---


== Misc

WARNING: You may see some error messages like the following when
running tests:
+
----
Could not create "/home/<uid>/.cache/bazel/_bazel_<uid>/f4012e66d98647d4c49d9c650a5ae78c/sandbox/linux-sandbox/10917/execroot/ocamlcc/bazel-out/k8-fastbuild-ST-462396b1cbfe/testlogs/testsuite/tests/basic/Eval_order_2_vv_test/test.outputs/outputs.zip": zip not found or failed
----

This message is harmless and can be ignored. It has to do with files
the test may have written to TEST_UNDECLARED_OUTPUTS_DIR, which is
documented at link:https://bazel.build/reference/test-encyclopedia#initial-conditions[Test Encyclopedia#Initial conditions].

See also link:https://github.com/bazelbuild/bazel/issues/8336[test-setup.sh: outputs.zip creation may fail silently #8336]
