load("@bazel_skylib//rules:common_settings.bzl", "BuildSettingInfo")
load("@bazel_skylib//lib:new_sets.bzl", "sets")
load("@bazel_skylib//lib:paths.bzl", "paths")

# load("//ocaml/_transitions:ns_transitions.bzl", "nsarchive_in_transition")

load("//bzl:providers.bzl",
     "CompilationModeSettingProvider",
     "BootInfo",
     "DepsAggregator",
     "new_deps_aggregator",
     "OcamlSignatureProvider")

     # "OcamlArchiveProvider",
     # "OcamlLibraryMarker",

     # "OcamlModuleMarker",
     # "OcamlNsResolverProvider",

load("//bzl:functions.bzl",
     "capitalize_initial_char",
     "get_fs_prefix",
     "get_module_name",
     "normalize_module_label"
)

load(":options.bzl", "get_options", "NEGATION_OPTS")

load(":impl_ccdeps.bzl", "link_ccdeps", "dump_CcInfo")

load(":impl_common.bzl",
     "dsorder",
     "opam_lib_prefix",
     "tmpdir")

load(":DEPS.bzl",
     "aggregate_deps",
     "merge_depsets",
     "COMPILE", "LINK", "COMPILE_LINK")

########## RULE:  BOOT_SIGNATURE  ################
def _boot_signature_impl(ctx):

    debug = False
    # if ctx.label.name in ["Pervasives"]
    #     debug = True

    tc = ctx.toolchains["//toolchain/type:bootstrap"]

    ################################################################
    ################
    # indirect_adjunct_depsets      = []
    # indirect_adjunct_path_depsets = []
    # indirect_cc_deps  = {}

    ################
    includes   = []

    sig_src = ctx.file.src
    if debug:
        print("sig_src: %s" % sig_src)

    # if sig_src.extension == "ml":
    #     # extract mli file from ml file

    # add prefix if namespaced. from_name == normalized module name
    # derived from sig_src; module_name == prefixed if ns else same as
    # from_name.

    ns = None
    (from_name, ns, module_name) = get_module_name(ctx, sig_src)
    if debug:
        print("From {src} To: {dst}".format(
            src = from_name, dst = module_name))

    # if False: ## ctx.attr.ppx:
    #     ## mlifile output is generated output of ppx processing
    #     mlifile = impl_ppx_transform("ocaml_signature", ctx,
    #                                  sig_src,
    #                                  module_name + ".mli")
    # else:

    if from_name == module_name:
        # if ctx.label.name == "CamlinternalFormatBasics_cmi":
        #     print("not namespaced")

        ## We need to ensure mli file and cmi file are in the same
        ## place. Since Bazel writes output files into its own dirs
        ## (won't write back into src dir), this means we need to
        ## symlink the source mli file into the same output directory,
        ## so that it will be found when it comes time to compile the
        ## .ml file.

        if debug:
            print("not namespaced")
        if sig_src.is_source:  # i.e. not generated by a preprocessor
            mlifile = ctx.actions.declare_file(tmpdir + module_name + ".mli") # sig_src.basename)
            ctx.actions.symlink(output = mlifile,
                                target_file = sig_src)
            if debug:
                print("symlinked {src} => {dst}".format(
                    src = sig_src.path, dst = mlifile.path))
        else:
            ## generated file, already in bazel dir
            if debug:
                print("not symlinking {src}".format(
                    src = sig_src))

            mlifile = sig_src

    else:
        # namespaced w/o ppx: symlink sig_src to prefixed name, so
        # that output dir will contain both renamed input mli and
        # output cmi.
        ns_sig_src = module_name + ".mli"
        if debug:
            print("ns_sig_src: %s" % ns_sig_src)
        mlifile = ctx.actions.declare_file(tmpdir + ns_sig_src)
        ctx.actions.symlink(output = mlifile,
                            target_file = sig_src)
        if debug:
            print("mlifile %s" % mlifile)

    # if sig_src.extension == "ml":  ## wtf?
    #     ofile = tmpdir + sig_src.basename + "i"
    #     out_cmi = ctx.actions.declare_file(ofile)
    # else:
    ocmi = tmpdir + module_name + ".cmi"
    # if ctx.label.name == "CamlinternalFormatBasics_cmi":
    #     print("OCMI: %s" % ocmi)

    out_cmi = ctx.actions.declare_file(ocmi)

    if debug:
        print("out_cmi %s" % out_cmi)


    ################################################################
    ################  DEPS  ################
    depsets = new_deps_aggregator()

    # if ctx.attr._manifest[BuildSettingInfo].value:
    #     manifest = ctx.attr._manifest[BuildSettingInfo].value
    # else:
    manifest = []

    # if ctx.label.name == "Stdlib_cmi":
    #     print("Stdlib manifest: %s" % manifest)
        # fail("X")

    for dep in ctx.attr.deps:
        depsets = aggregate_deps(ctx, dep, depsets, manifest)

    if hasattr(ctx.attr, "ns"):
        if ctx.attr.ns:
            # for dep in ctx.attr.ns:
            depsets = aggregate_deps(ctx, ctx.attr.ns, depsets, manifest)

    ## build depsets here, use for OcamlProvider and OutputGroupInfo
    sigs_depset = depset(
        order=dsorder,
        direct = [out_cmi],
        transitive = [merge_depsets(depsets, "sigs")])

    cli_link_deps_depset = depset(
        order = dsorder,
        transitive = [merge_depsets(depsets, "cli_link_deps")]
    )

    afiles_depset  = depset(
        order=dsorder,
        transitive = [merge_depsets(depsets, "afiles")]
    )

    archived_cmx_depset = depset(
        order=dsorder,
        transitive = [merge_depsets(depsets, "archived_cmx")]
    )

    paths_depset  = depset(
        order = dsorder,
        direct = [out_cmi.dirname],
        transitive = [merge_depsets(depsets, "paths")]
    )

    # if ctx.label.name == "CamlinternalFormatBasics_cmi":
    #     print("depsets: %s" % depsets)
    #     fail("x")

    #########################
    args = ctx.actions.args()

    if tc.target_host in ["boot", "vm"]:
        # if not stage == 1:
        args.add_all(["-use-prims", tc.primitives])

    # if tc.target_host in ["boot", "dev", "vm"]:
    #     args.add(tc.compiler)

    args.add_all(tc.copts)

    _options = get_options(ctx.attr._rule, ctx)
    args.add_all(_options)

    # for arg in ctx.attr.opts:
    #     if arg not in NEGATION_OPTS:
    #         args.add(arg)

    # -use-prims:
    #   >vm: always on for boot phase, may be disabled for next stage,
    #   >sys: always off

    # if "-for-pack" in _options:
    #     for_pack = True
    #     _options.remove("-for-pack")
    # else:
    #     for_pack = False

    # if ctx.attr.pack:
    #     args.add("-for-pack", ctx.attr.pack)

    # if ctx.attr.pack:
    #     args.add("-linkpkg")


    # includes.append(out_cmi.dirname)

    # paths_direct   = []
    # paths_indirect = []
    # all_deps_list = []
    # direct_deps_list = []
    # archive_deps_list = []
    # archive_inputs_list = [] # not for command line!

    # input_deps_list = []

    #### INDIRECT DEPS first ####
    # these direct deps are "indirect" from the perspective of the consumer
    # indirect_inputs_depsets = []
    # indirect_linkargs_depsets = []
    # indirect_paths_depsets = []

    ccInfo_list = []

    # the_deps = ctx.attr.deps # + [ctx.attr._ns_resolver]
    # for dep in the_deps:

    #     if BootInfo in dep:
    #         indirect_inputs_depsets.append(dep[BootInfo].inputs)
    #         indirect_linkargs_depsets.append(dep[BootInfo].linkargs)
    #         indirect_paths_depsets.append(dep[BootInfo].paths)

    #     if CcInfo in dep:
    #         ccInfo_list.append(dep[CcInfo])

    # print("SIGARCHDL: %s" % archive_deps_list)

    # paths_depset  = depset(
    #     order = dsorder,
    #     direct = [out_cmi.dirname],
    #     transitive = indirect_paths_depsets
    # )

    ## FIXME: do we need the resolver for sigfiles?
    # for f in ctx.files._ns_resolver:
    #     if f.extension == "cmx":
    #         args.add("-I", f.dirname) ## REQUIRED, even if cmx has full path
    #         args.add(f.path)

    ns_resolver_depset = []
    if hasattr(ctx.attr, "ns"):
        # print("HAS ctx.attr.ns")
        ## Only -open Stdlib if we have a dep on Stdlib.
        if ctx.files.deps :
            if ctx.attr.ns:
                # if BootInfo in ctx.attr.ns:
                    # ns_resolver_depset = [ctx.attr.ns[BootInfo].inputs]

                # for f in ctx.attr.ns[DefaultInfo].files.to_list():
                #     # args.add("-I", f.dirname)
                #     includes.append(f.dirname)
                    # args.add(f)

                args.add("-no-alias-deps")
                args.add("-open", ns)
        #     else:
        #         args.add("-nopervasives")
        # else:
        #     args.add("-nopervasives")

    # if ctx.label.name == "Stdlib_cmi":
    #     print("sig depset : %s" % depsets)
        # fail("x")

    # arch_depset = merge_depsets(depsets, "archives")
    # for arch in arch_depset.to_list():
    #     includes.append(arch.dirname)

    # args.add_all(paths_depset.to_list(), before_each="-I")
    includes.extend(paths_depset.to_list())

    args.add_all(includes, before_each="-I", uniquify = True)

    if sig_src.extension == "ml":
        args.add("-i")
        args.add("-o", out_cmi)
    else:
        args.add("-c")
        args.add("-o", out_cmi)

    pack_ns = False
    if hasattr(ctx.attr, "_pack_ns"):
        if ctx.attr._pack_ns:
            if ctx.attr._pack_ns[BuildSettingInfo].value:
                pack_ns = ctx.attr._pack_ns[BuildSettingInfo].value
                # print("GOT PACK NS: %s" % pack_ns)
    if pack_ns:
        args.add("-for-pack", pack_ns)

    args.add("-intf", mlifile)

    direct_inputs = [mlifile]
    if ctx.files.data:
        direct_inputs.extend(ctx.files.data)

    # if ctx.label.name == "Config_cmi":
    #     print("depsets.deps.sigs: %s" % depsets.deps.sigs)
    #     fail("x")

    inputs_depset = depset(
        order = dsorder,
        direct = []
        + direct_inputs # + ctx.files._ns_resolver,
        # + [tc.compiler[DefaultInfo].files_to_run.executable],
        # + ctx.files.data if ctx.files.data else [],
        ,
        transitive = []## indirect_inputs_depsets
        + [merge_depsets(depsets, "sigs"),
           merge_depsets(depsets, "cli_link_deps")
           ]
        # + depsets.deps.structs
        # + depsets.deps.sigs
        # + depsets.deps.archives
        + ns_resolver_depset
        # + [tc.compiler[DefaultInfo].default_runfiles.files]
    )

    ##########################################
    ################  ACTION  ################
    ctx.actions.run(
        # env = env,
        executable = tc.compiler[DefaultInfo].files_to_run,
        arguments = [args],
        inputs = inputs_depset,
        outputs = [out_cmi],
        tools = [
            tc.compiler[DefaultInfo].default_runfiles.files,
            tc.compiler[DefaultInfo].files_to_run
        ],
        # tools = [tc.tool_runner, tc.compiler],
        mnemonic = "CompileOcamlSignature",
        progress_message = "{mode} compiling boot_signature: {ws}//{pkg}:{tgt}".format(
            mode = tc.build_host + ">" + tc.target_host,
            ws  = ctx.label.workspace_name if ctx.label.workspace_name else "", ## ctx.workspace_name,
            pkg = ctx.label.package,
            tgt=ctx.label.name
        )
    )

    #############################################
    ################  PROVIDERS  ################

    default_depset = depset(
        order = dsorder, direct = [out_cmi]
    )

    defaultInfo = DefaultInfo(
        files = default_depset
    )

    sigProvider = OcamlSignatureProvider(
        mli = mlifile,
        cmi = out_cmi
    )

    # ofiles_depset  = depset(order=dsorder,
    #                         # direct=ofiles_primary,
    #                         transitive = depsets.deps.ofiles)
    #                         # transitive=ofiles_secondary)
    # ## FIXME: add unarchived module deps of archives
    # archives_depset = depset(order="postorder",
    #                          # direct = archives_primary,
    #                          transitive = depsets.deps.archives)
    #                          # transitive = archives_secondary)
    # astructs_depset = depset(order=dsorder,
    #                          # direct = astructs_primary,
    #                          transitive = depsets.deps.astructs)
    #                      # transitive = astructs_secondary)

    bootInfo = BootInfo(
        sigs     = sigs_depset,
        cli_link_deps = cli_link_deps_depset,
        afiles   = afiles_depset,
        archived_cmx  = archived_cmx_depset,
        paths    = paths_depset,

        # ofiles   = ofiles_depset,
        # archives = archives_depset,
        # astructs = astructs_depset,
    )

    providers = [
        defaultInfo,
        bootInfo,
        sigProvider,
    ]

    if ccInfo_list:
        providers.append(
            cc_common.merge_cc_infos(cc_infos = ccInfo_list)
        )

    return providers


################################################################
################################################################

################################
# rule_options = options("ocaml")
# rule_options.update(options_signature)
# rule_options.update(options_ns_opts("ocaml"))
# rule_options.update(options_ppx)

# rule_options = options("ocaml")
# rule_options.update(options_ns_opts("ocaml"))

#######################
boot_signature = rule(
    implementation = _boot_signature_impl,
    doc = "Sig rule for bootstrapping ocaml compilers",
    attrs = dict(
        # rule_options,

        # _boot       = attr.label(
        #     default = "//bzl/toolchain:boot",
        # ),

        primitives = attr.label(
            # default = "//runtime:primitives",
            allow_single_file = True,
        ),

        # _toolchain = attr.label(
        #     default = "//bzl/toolchain:tc"
        # ),

        _stage = attr.label(
            doc = "bootstrap stage",
            default = "//bzl:stage"
        ),

        # ocamlc = attr.label(
        #     # cfg = ocamlc_out_transition,
        #     allow_single_file = True,
        #     default = "//bzl/toolchain:ocamlc"
        # ),

        # _mode       = attr.label(
        #     default = "//bzl/toolchain",
        # ),
        # mode       = attr.string(
        #     doc     = "Overrides global mode build setting.",
        # ),

        opts             = attr.string_list(
            doc          = "List of OCaml options. Will override configurable default options."
        ),
        ## GLOBAL CONFIGURABLE DEFAULTS (all ppx_* rules)
        # _debug           = attr.label(default = "@ocaml//debug"),
        # _cmt             = attr.label(default = "@ocaml//cmt"),
        # _keep_locs       = attr.label(default = "@ocaml//keep-locs"),
        # _noassert        = attr.label(default = "@ocaml//noassert"),
        # _opaque          = attr.label(default = "@ocaml//opaque"),
        # _short_paths     = attr.label(default = "@ocaml//short-paths"),
        # _strict_formats  = attr.label(default = "@ocaml//strict-formats"),
        # _strict_sequence = attr.label(default = "@ocaml//strict-sequence"),
        # _verbose         = attr.label(default = "@ocaml//verbose"),

        # _mode       = attr.label(
        #     default = "@ocaml//mode",
        # ),

        # _sdkpath = attr.label(
        #     default = Label("@ocaml//:sdkpath") # ppx also uses this
        # ),

        src = attr.label(
            doc = "A single .mli source file label",
            allow_single_file = [".mli", ".ml"] #, ".cmi"]
        ),

        ns = attr.label(
            doc = "Bottom-up namespacing",
            allow_single_file = True,
            mandatory = False
        ),

        _pack_ns = attr.label(
            doc = """Namepace name for use with -for-pack. Set by transition function.
""",
            # default = "//config/pack:ns"
        ),

        # pack = attr.string(
        #     doc = "Experimental",
        # ),

        deps = attr.label_list(
            doc = "List of OCaml dependencies. Use this for compiling a .mli source file with deps. See [Dependencies](#deps) for details.",
            # cfg = compile_mode_out_transition,
            providers = [
                # BootInfo,  ## bug

                # [OcamlArchiveProvider],
                # # [OcamlImportMarker],
                # [OcamlLibraryMarker],
                # [OcamlModuleMarker],
                # [OcamlSigMarker],
                # [OcamlNsMarker],
            ],
        ),

        data = attr.label_list(
            allow_files = True
        ),

        _manifest = attr.label(
            default = "//config:manifest"
        ),

        ################################################################
        # _ns_resolver = attr.label(
        #     doc = "Experimental",
        #     providers = [OcamlNsResolverProvider],
        #     # default = "@ocaml//ns:bootstrap",
        #     default = "@ocaml//bootstrap/ns:resolver",
        # ),

        # _ns_submodules = attr.label( # _list(
        #     doc = "Experimental.  May be set by ocaml_ns_library containing this module as a submodule.",
        #     default = "@ocaml//ns:submodules", ## NB: ppx modules use ocaml_signature
        # ),

        ################################################################


        # opts = attr.string_list(doc = "List of OCaml options."),

        # mode       = attr.string(
        #     doc     = "Compilation mode, 'bytecode' or 'native'",
        #     default = "bytecode"
        # ),

        # _debug           = attr.label(default = "@ocaml//debug"),

        ## RULE DEFAULTS
        # _linkall     = attr.label(default = "@ocaml//signature/linkall"), # FIXME: call it alwayslink?
        # _threads     = attr.label(default = "@ocaml//signature/threads"),
        # _warnings  = attr.label(default = "@ocaml//signature:warnings"),

        #### end options ####

        # src = attr.label(
        #     doc = "A single .mli source file label",
        #     allow_single_file = [".mli", ".ml"] #, ".cmi"]
        # ),

        # ns_submodule = attr.label_keyed_string_dict(
        #     doc = "Extract cmi file from namespaced module",
        #     providers = [
        #         [OcamlNsMarker, OcamlArchiveProvider],
        #     ]
        # ),

        # as_cmi = attr.string(
        #     doc = "For use with ns_module only. Creates a symlink from the extracted cmi file."
        # ),

        # pack = attr.string(
        #     doc = "Experimental",
        # ),

        # deps = attr.label_list(
        #     doc = "List of OCaml dependencies. Use this for compiling a .mli source file with deps. See [Dependencies](#deps) for details.",
        #     providers = [
        #         [BootInfo],
        #         [OcamlArchiveProvider],
        #         [OcamlImportMarker],
        #         [OcamlLibraryMarker],
        #         [OcamlModuleMarker],
        #         [OcamlNsMarker],
        #     ],
        #     # cfg = ocaml_signature_deps_out_transition
        # ),

        # data = attr.label_list(
        #     allow_files = True
        # ),

        # ################################################################
        # _ns_resolver = attr.label(
        #     doc = "Experimental",
        #     providers = [OcamlNsResolverProvider],
        #     # default = "@ocaml//ns:bootstrap",
        #     default = "@ocaml//bootstrap/ns:resolver",
        # ),

        # _ns_submodules = attr.label( # _list(
        #     doc = "Experimental.  May be set by ocaml_ns_library containing this module as a submodule.",
        #     default = "@ocaml//ns:submodules", ## NB: ppx modules use ocaml_signature
        # ),
        # _ns_strategy = attr.label(
        #     doc = "Experimental",
        #     default = "@ocaml//ns:strategy"
        # ),
        # _mode       = attr.label(
        #     default = "@ocaml//mode",
        # ),
        # _sdkpath = attr.label(
        #     default = Label("@ocaml//:sdkpath")
        # ),

        _rule = attr.string( default = "ocaml_signature" ),

        # _allowlist_function_transition = attr.label(
        #     default = "@bazel_tools//tools/allowlists/function_transition_allowlist"
        # ),
    ),
    # cfg = compile_mode_in_transition,
    incompatible_use_toolchain_transition = True,

    # custom provider initializer bug:
    # provides = [OcamlSignatureProvider],

    executable = False,
    toolchains = ["//toolchain/type:bootstrap",
                  "@bazel_tools//tools/cpp:toolchain_type"]
)
