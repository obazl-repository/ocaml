package(default_visibility = ["//visibility:public"])

load("//bzl:rules.bzl",
     "boot_archive",
     "boot_compiler",
     "compiler_module")

# load("//bzl/rules/macros:compiler.bzl", "compiler")
load("//bzl/rules/macros:lexer.bzl", "lexer")

## select emitter:
## if stage < 2 then set vm emitter
## if stage == 2, then emitter == target executor

## WARNING: obsolete.  use //bin:ocamlcc instead
boot_compiler(
    name                   = "compiler",
    opts = [
        "-verbose",
    ],
    cc_linkopts = [
        "verbose", #linux: --verbose; mac: -v (undocumented)
    ] + select({
        "@platforms//os:macos": [
            # "-Wl,-v", # prints config, search paths
            # "-Wl,-print_statistics", # -Wl,-v plus timings, mem, etc.
            "-t", # -Wl-v plus logs each file the linker loads.
            # "-why_load" # Log why each object file in a static library
            #             # is loaded. That is, what symbol was needed.
            ],
        "@platforms//os:linux": [
            ##FIXME: depends on linker used (bfd, gold, etc.)
        ]
    }),
    # toolchains = ["//profile/system/local"],
    prologue = ["//compilerlibs:ocamlcommon"] + select({
        "//config/target:baseline_vm?": ["//bytecomp:ocamlbytecomp"],
        "//config/target:baseline_sys?": ["//asmcomp:ocamloptcomp"],
        "//config/target:ult_sys?": ["//asmcomp:ocamloptcomp"],

        "//conditions:default": ["//bytecomp:ocamlbytecomp"]
    }),
    main = select({
        "//config/target:baseline_vm?": "//driver:Main",
        "//config/target:baseline_sys?": "//driver:Optmain",
        "//config/target:ult_sys?": "//driver:Optmain",

        "//conditions:default": "//driver:Main"
    }),
    # prologue = [
    #     "//compilerlibs:ocamlcommon",
    #     "//bytecomp:ocamlbytecomp"
    # ],
    # main = "//driver:Main",
    # compatibility constraints ensure selection of boot toolchain
    # exec_compatible_with   = [
    #     "//platform/constraints/ocaml/executor:vm_executor",

    #     # platform: boot_build == sys_vm_vm + build + boot
    #     # "//platform/constraints/ocaml/build/executor:vm_executor",
    #     # "//platform/constraints/ocaml/build/emitter:vm_emitter",
    #     # "//platform/constraints/stage:boot"
    # ],
    # target_compatible_with = [
    #     "//platform/constraints/ocaml/executor:vm_executor",
    #     # platform: boot_target == sys_vm_vm + target + boot
    #     # "//platform/constraints/ocaml/target/executor:vm_executor",
    #     # "//platform/constraints/ocaml/target/emitter:vm_emitter",
    #     # "//platform/constraints/stage:boot"
    # ],
    visibility             = ["//visibility:public"]
)

# uses baseline ocamlc.byte to produce ocamlc.byte, ocamlopt.byte
# boot_compiler(
#     name                   = "dev",
#     # stage                  = "dev", # stage,
#     prologue = ["//compilerlibs:ocamlcommon"] + select({
#         "//platform/constraints/ocaml/target/emitter:sys_emitter?": ["//asmcomp:ocamloptcomp"],
#         "//platform/constraints/ocaml/target/emitter:vm_emitter?": ["//bytecomp:ocamlbytecomp"],
#     }),
#     main = select({
#         "//platform/constraints/ocaml/target/emitter:sys_emitter?": "//driver:Optmain",
#         "//platform/constraints/ocaml/target/emitter:vm_emitter?": "//driver:Main"
#     }),
#     opts                   = [],
#     exec_compatible_with   = [
#         "//platform/constraints/ocaml/build/executor:vm_executor",
#         "//platform/constraints/ocaml/build/emitter:vm_emitter",
#         "//platform/constraints/stage:baseline"
#     ],
#     target_compatible_with = [
#         # platform: boot_target == sys_vm_vm + target + boot
#         # "//platform/constraints/ocaml/target/executor:vm_executor",
#         # "//platform/constraints/ocaml/target/emitter:vm_emitter",
#         # "//platform/constraints/stage:baseline"
#         ],
#     visibility             = ["//visibility:public"]
# )
