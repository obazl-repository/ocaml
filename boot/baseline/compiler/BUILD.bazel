package(default_visibility = ["//visibility:public"])

load("//bzl:rules.bzl",
     "boot_archive",
     "boot_compiler",
     "compiler_module")

# load("//bzl/rules/macros:compiler.bzl", "compiler")
load("//bzl/rules/macros:lexer.bzl", "lexer")

# This macro expands to three different boot_compiler targets:
#   //baseline/compiler:baseline uses the boot compiler
#   //baseline/compiler:dev uses the baseline compiler
#   //baseline/compiler:prod uses the dev compiler
# compiler( name  = "compilers" )

## select emitter:
## if stage < 2 then set vm emitter
## if stage == 2, then emitter == target executor

boot_compiler(
    name                   = "compiler",
    prologue = ["//compilerlibs:ocamlcommon"] + select({
        "//config/target:baseline_vm?": ["//bytecomp:ocamlbytecomp"],
        "//config/target:baseline_sys?": ["//asmcomp:ocamloptcomp"],
        "//config/target:ult_sys?": ["//asmcomp:ocamloptcomp"],

        "//conditions:default": ["//bytecomp:ocamlbytecomp"]
    }),
    main = select({
        "//config/target:baseline_vm?": "//driver:Main",
        "//config/target:baseline_sys?": "//driver:Optmain",
        "//config/target:ult_sys?": "//driver:Optmain",

        "//conditions:default": "//driver:Main"
    }),
    # prologue = [
    #     "//compilerlibs:ocamlcommon",
    #     "//bytecomp:ocamlbytecomp"
    # ],
    # main = "//driver:Main",
    opts                   = [],
    # compatibility constraints ensure selection of boot toolchain
    # exec_compatible_with   = [
    #     "//platform/constraints/ocaml/executor:vm_executor",

    #     # platform: boot_build == sys_vm_vm + build + boot
    #     # "//platform/constraints/ocaml/build/executor:vm_executor",
    #     # "//platform/constraints/ocaml/build/emitter:vm_emitter",
    #     # "//platform/constraints/stage:boot"
    # ],
    # target_compatible_with = [
    #     "//platform/constraints/ocaml/executor:vm_executor",
    #     # platform: boot_target == sys_vm_vm + target + boot
    #     # "//platform/constraints/ocaml/target/executor:vm_executor",
    #     # "//platform/constraints/ocaml/target/emitter:vm_emitter",
    #     # "//platform/constraints/stage:boot"
    # ],
    visibility             = ["//visibility:public"]
)

# uses baseline ocamlc.byte to produce ocamlc.byte, ocamlopt.byte
# boot_compiler(
#     name                   = "dev",
#     # stage                  = "dev", # stage,
#     prologue = ["//compilerlibs:ocamlcommon"] + select({
#         "//platform/constraints/ocaml/target/emitter:sys_emitter?": ["//asmcomp:ocamloptcomp"],
#         "//platform/constraints/ocaml/target/emitter:vm_emitter?": ["//bytecomp:ocamlbytecomp"],
#     }),
#     main = select({
#         "//platform/constraints/ocaml/target/emitter:sys_emitter?": "//driver:Optmain",
#         "//platform/constraints/ocaml/target/emitter:vm_emitter?": "//driver:Main"
#     }),
#     opts                   = [],
#     exec_compatible_with   = [
#         "//platform/constraints/ocaml/build/executor:vm_executor",
#         "//platform/constraints/ocaml/build/emitter:vm_emitter",
#         "//platform/constraints/stage:baseline"
#     ],
#     target_compatible_with = [
#         # platform: boot_target == sys_vm_vm + target + boot
#         # "//platform/constraints/ocaml/target/executor:vm_executor",
#         # "//platform/constraints/ocaml/target/emitter:vm_emitter",
#         # "//platform/constraints/stage:baseline"
#         ],
#     visibility             = ["//visibility:public"]
# )
