package(default_visibility = ["//visibility:public"])

load("//bzl:rules.bzl",
     "boot_import_vm_executable",
     "ocamlc_byte",
     "ocamlopt_byte",
     "ocamlopt_opt",
     "ocamlc_opt")


load(":BUILD_RULES.bzl", "boot_coldstart", "boot_setup")

# load("//bzl/rules/macros:stdlib.bzl", "stdlib")

# exports_files(["ocamlc", "ocamllex"])

## Package //boot contains pre-compiled OCaml executables (ocamlc,
## ocamllex) and aliases to native C executables (ocamlrun, ocamlyacc).

alias(name = "coldstart", actual = ":bootstrap")

boot_coldstart(
    name = "bootstrap",
    runner = "coldstart_runner.sh",
    runtimes = [
        "//runtime:asmrun",
        "//runtime:camlrun",
    ],
    data = [
        "//bin:ocamlc.opt",  ## runfiles contain all 4
        "//lex:ocamllex.byte",
        "//lex:ocamllex.opt",
        "//stdlib",
        "//stdlib:Std_exit",
        "//asmcomp:cvt_emit.byte",
        "//asmcomp:cvt_emit.opt",
        "//yacc:ocamlyacc",
        "@bazel_tools//tools/bash/runfiles",
    ],
)

boot_setup(
    name = "preproc",
    runner = "preproc_runner.sh",
    data = [
        "@bazel_tools//tools/bash/runfiles",
        # generated code - cache it so it only gets generated once
        "//runtime:ints.c",
        "//runtime:primitives.dat",
        "//runtime:primitives.h",
        "//runtime:prims.c",
        "//runtime/caml:domain_state.h",
        "//runtime/caml:instruct.h",
        "//runtime/caml:fail.h",
        "//runtime/caml:jumptbl.h",
        "//runtime/caml:opnames.h",
        "//runtime/caml:s.h",
        "//stdlib:stdlib.mli",
        "//stdlib:stdlib.ml",
        "//vendor/mustach",
    ],
)


sh_binary(
    name = "clean",
    srcs = ["clean.sh"]
)

################################################################
boot_import_vm_executable(
    name = "ocamlc.boot",
    tool = "ocamlc",
    # runtime = "//runtime:ocamlrun"
)

ocamlc_byte(
    name = "ocamlc.byte",
    stdlib   = "//stdlib",
    prologue = [
        "//compilerlibs:ocamlcommon",
        "//bytecomp:ocamlbytecomp"
    ],
    main = "//driver:Main",
    opts = [ ] + select({
        # ocamlc.byte: ["-compat-32"]
        "//conditions:default": []
    }) + [
    ] + select({
        "//platform/target/os:linux?": [
            "-cclib", "-lm",
            "-cclib", "-ldl",
            "-cclib", "-lpthread",
        ],
        "//conditions:default": []
    }),
    visibility             = ["//visibility:public"]
)

ocamlopt_byte(
    name = "ocamlopt.byte",
    stdlib   = "//stdlib",
    prologue = [
        "//compilerlibs:ocamlcommon",
        "//asmcomp:ocamloptcomp"
    ],
    main = "//driver:Optmain",
    opts = [ ] + select({
        # ocamlc.byte: ["-compat-32"]
        "//conditions:default": []
    }) + [
    ] + select({
        "//platform/target/os:linux?": [
            "-cclib", "-lm",
            "-cclib", "-ldl",
            "-cclib", "-lpthread",
        ],
        "//conditions:default": []
    }),
    visibility             = ["//visibility:public"]
)

ocamlopt_opt(
    name = "ocamlopt.opt",
    stdlib   = "//stdlib",
    prologue = [
        "//compilerlibs:ocamlcommon",
        "//asmcomp:ocamloptcomp"
    ],
    main = "//driver:Optmain",
    opts = [ ] + select({
        "//platform/target/os:linux?": [
            "-cclib", "-lm",
            "-cclib", "-ldl",
            "-cclib", "-lpthread",
        ],
        "//conditions:default": []
    }),
    visibility             = ["//visibility:public"]
)

ocamlc_opt(
    name = "ocamlc.opt",
    stdlib   = "//stdlib",
    prologue = [
        "//compilerlibs:ocamlcommon",
        "//asmcomp:ocamloptcomp"
    ],
    main = "//driver:Optmain",
    opts = [ ] + select({
        "//platform/target/os:linux?": [
            "-cclib", "-lm",
            "-cclib", "-ldl",
            "-cclib", "-lpthread",
        ],
        "//conditions:default": []
    }),
    visibility             = ["//visibility:public"]
)

sh_binary(
    name = "ocamlc.sh",
    srcs = ["ocamlc.byte.sh"],
    data = [
        ":ocamlc",
        "//runtime:ocamlrun",
        "//config/camlheaders",

        # We cannot depend on Std_exit on pain of circularity.
        # It depends on Stdlib, which is compiled by this tool.
        # "//stdlib:Std_exit"
    ],
    deps = [
         # for the runfiles lib used in ocamlc.sh:
        "@bazel_tools//tools/bash/runfiles"
    ]
)

################################################################
boot_import_vm_executable(
    name = "ocamllex.boot",
    tool = "ocamllex",
    # runtime = "//runtime:ocamlrun"
)

sh_binary(
    name = "ocamllex.sh",
    srcs = ["ocamllex.byte.sh"],
    data = [
        ":ocamllex.byte",
        "//runtime:ocamlrun"
    ],
    deps = ["@bazel_tools//tools/bash/runfiles"]
)
