load("//bzl:rules.bzl",
     "bootstrap_executable",
     "bootstrap_library",
     "bootstrap_module",
     "bootstrap_ocamllex",
     "bootstrap_signature"
)

exports_files([
    "check-parser-uptodate-or-warn.sh",
])

load("//config:BUILD.bzl",
     "TOOLS_MODULE_OPTS",
     "TOOLS_SIG_OPTS"
     )

MODULE_OPTS = TOOLS_MODULE_OPTS
SIG_OPTS    = TOOLS_SIG_OPTS

STDLIB = ["//stdlib", "//stdlib:Std_exit"]

## first the executables. modules and sigs below.
# programs_byte := \
#   ocamldep ocamlprof ocamlcp ocamloptp ocamlmklib  \
#   ocamlmktop ocamlcmt dumpobj ocamlobjinfo \
#   primreq stripdebug cmpbyt
# $(programs_byte:%=%$(EXE)):
# 	$(CAMLC) $(LINKFLAGS) -I $(ROOTDIR) -o $@ $(filter-out %.cmi,$^)

################################################################
# The dependency generator
# OCAMLDEP = \
#   $(ROOTDIR)/compilerlibs/ocamlcommon.cma \
#   $(ROOTDIR)/compilerlibs/ocamlbytecomp.cma \
#   ocamldep.cmo depend.cmi
# ocamldep$(EXE): LINKFLAGS += -compat-32
# ocamldep$(EXE): $(OCAMLDEP)
# ocamldep.opt$(EXE): $(call byte2native, $(OCAMLDEP))

bootstrap_executable(
    name = "ocamldep",
    main = ":Ocamldep",
    deps = [
        "//compilerlibs:ocamlcommon",
        "//compilerlibs:ocamlbytecomp",
    ]
)

################################################################
# Profiling: https://ocaml.org/manual/profil.html
# The OCaml profiling compilers: ocamlcp, ocamloptp
# Viewer: ocamlprof

# OCAMLPROF=config.cmo build_path_prefix_map.cmo misc.cmo identifiable.cmo \
#   numbers.cmo arg_helper.cmo clflags.cmo terminfo.cmo \
#   warnings.cmo location.cmo longident.cmo docstrings.cmo \
#   syntaxerr.cmo ast_helper.cmo \
#   camlinternalMenhirLib.cmo parser.cmo \
#   pprintast.cmo \
#   lexer.cmo parse.cmo ocamlprof.cmo
# ocamlprof$(EXE): $(OCAMLPROF)
# ocamlcp$(EXE): $(OCAMLCP) ocamlcp.cmo
# ocamlcp.opt$(EXE): $(call byte2native, $(OCAMLCP) ocamlcp.cmo)
# ocamloptp$(EXE): $(OCAMLCP) ocamloptp.cmo
# ocamloptp.opt$(EXE): $(call byte2native, $(OCAMLCP) ocamloptp.cmo)

bootstrap_executable(
    name = "ocamlprof",
    main = ":Ocamlprof",
    deps = [
        "//utils:Config",
        "//utils:Build_path_prefix_map",
        "//utils:Misc",
        "//utils:Identifiable",
        "//utils:Numbers",
        "//utils:Arg_helper",
        "//utils:Clflags",
        "//utils:Terminfo",
        "//utils:Warnings",
        "//parsing:Location",
        "//parsing:Longident",
        "//parsing:Docstrings",
        "//parsing:Syntaxerr",
        "//parsing:Ast_helper",
        "//parsing:CamlinternalMenhirLib",
        "//parsing:Parser",
        "//parsing:Pprintast",
        "//parsing:Lexer",
        "//parsing:Parse",
    ]
)

################################################################
# other tools
# OCAMLMKLIB = config.cmo build_path_prefix_map.cmo misc.cmo ocamlmklib.cmo
# ocamlmklib$(EXE): $(OCAMLMKLIB)
# ocamlmklib.opt$(EXE): $(call byte2native, $(OCAMLMKLIB))

# To make custom toplevels
# OCAMLMKTOP=config.cmo build_path_prefix_map.cmo misc.cmo \
#        identifiable.cmo numbers.cmo arg_helper.cmo clflags.cmo \
#        local_store.cmo load_path.cmo profile.cmo ccomp.cmo ocamlmktop.cmo
# ocamlmktop$(EXE): $(OCAMLMKTOP)
# ocamlmktop.opt$(EXE): $(call byte2native, $(OCAMLMKTOP))

################################################################
# The preprocessor for asm generators
# cvt_emit := cvt_emit$(EXE)
# $(eval $(call PROGRAM_SYNONYM,cvt_emit))
# $(cvt_emit): cvt_emit.cmo
# 	$(CAMLC) $(LINKFLAGS) -o $@ $^

bootstrap_executable(
    name = "cvt_emit.exe",
    main = ":Cvt_emit",
    # deps = STDLIB,
    visibility = ["//asmcomp:__subpackages__"]
)

bootstrap_module(
    name   = "Cvt_emit",
    struct = "cvt_emit.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//stdlib:Stdlib.Sys",
        "//stdlib:Stdlib.Printf",
        "//bytecomp:Bytesections",
        "//stdlib:Stdlib.Array",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_ocamllex(
    name = "cvt_emit_ml",
    out  = "cvt_emit.ml",
    src  = "cvt_emit.mll"
)

################################################################
# Reading cmt files
# OCAMLCMT = \
#           $(ROOTDIR)/compilerlibs/ocamlcommon.cma \
#           $(ROOTDIR)/compilerlibs/ocamlbytecomp.cma \
#           ocamlcmt.cmo
# ocamlcmt$(EXE): $(OCAMLCMT)
# ocamlcmt.opt$(EXE): $(call byte2native, $(OCAMLCMT))


################################################################
# The bytecode disassembler
# DUMPOBJ= \
#           $(ROOTDIR)/compilerlibs/ocamlcommon.cma \
#           $(ROOTDIR)/compilerlibs/ocamlbytecomp.cma \
#           opnames.cmo dumpobj.cmo
# dumpobj$(EXE): $(DUMPOBJ)
# dumpobj.opt$(EXE): $(call byte2native, $(DUMPOBJ))

################
# make_opcodes, opnames.ml
# OCAMLRUN ?= $(ROOTDIR)/boot/ocamlrun$(EXE)
# NEW_OCAMLRUN ?= $(ROOTDIR)/runtime/ocamlrun$(EXE)
# opnames.ml: $(ROOTDIR)/runtime/caml/instruct.h $(make_opcodes)
# 	$(NEW_OCAMLRUN) $(make_opcodes) -opnames < $< > $@
bootstrap_module(
    name = "Opnames",
    struct = "opnames.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
    ]
)

genrule(
    name = "gen_opnames",
    outs = ["opnames.ml"],
    srcs = ["//runtime/caml:instruct.h", ":make_opcodes"],
    tools = ["//runtime:ocamlrun"],
    cmd   = " ".join([
        "$(execpath //runtime:ocamlrun) $(location :make_opcodes)",
        "-opnames < $(location //runtime/caml:instruct.h)",
        "> $@"
    ])
)


################################################################
## ocamlobjinfo - Display info on compiled files
# DEF_SYMBOL_PREFIX = '-Dsymbol_prefix=""'
# ifeq "$(SYSTEM)" "macosx"
# DEF_SYMBOL_PREFIX = '-Dsymbol_prefix="_"'
# endif
# ifeq "$(SYSTEM)" "cygwin"
# DEF_SYMBOL_PREFIX = '-Dsymbol_prefix="_"'
# endif
# OCAMLOBJINFO=$(ROOTDIR)/compilerlibs/ocamlcommon.cma \
#              $(ROOTDIR)/compilerlibs/ocamlbytecomp.cma \
#              $(ROOTDIR)/compilerlibs/ocamlmiddleend.cma \
#              objinfo.cmo
# ocamlobjinfo$(EXE): $(OCAMLOBJINFO)
# ocamlobjinfo.opt$(EXE): $(call byte2native, $(OCAMLOBJINFO))

bootstrap_executable(
    name = "ocamlobjinfo",
    main = ":Objinfo",
    deps = [
        "//compilerlibs:ocamlcommon",
        "//compilerlibs:ocamlbytecomp",
        "//middle_end:ocamlmiddleend",
    ]
)

################################################################
# # Scan object files for required primitives
# primreq$(EXE): $(PRIMREQ)
# primreq.opt$(EXE): $(call byte2native, $(PRIMREQ))

################################################################
# LINTAPIDIFF=$(ROOTDIR)/compilerlibs/ocamlcommon.cmxa \
#         $(ROOTDIR)/compilerlibs/ocamlbytecomp.cmxa \
#         $(ROOTDIR)/compilerlibs/ocamlmiddleend.cmxa \
#         $(ROOTDIR)/otherlibs/str/str.cmxa \
#         lintapidiff.cmx

# lintapidiff.opt$(EXE): INCLUDES+= -I $(ROOTDIR)/otherlibs/str
# lintapidiff.opt$(EXE): $(LINTAPIDIFF)
# 	$(CAMLOPT_CMD) $(LINKFLAGS) -I $(ROOTDIR) -o $@ $(LINTAPIDIFF)

################
# Copy a bytecode executable, stripping debug info
# STRIPDEBUG=$(ROOTDIR)/compilerlibs/ocamlcommon.cma \
#            $(ROOTDIR)/compilerlibs/ocamlbytecomp.cma \
#            stripdebug.cmo
# stripdebug$(EXE): $(STRIPDEBUG)
# stripdebug.opt$(EXE): $(call byte2native, $(STRIPDEBUG))

################
# Compare two bytecode executables
# CMPBYT=$(ROOTDIR)/compilerlibs/ocamlcommon.cma \
#        $(ROOTDIR)/compilerlibs/ocamlbytecomp.cma \
#        cmpbyt.cmo
# cmpbyt$(EXE): $(CMPBYT)
# cmpbyt.opt$(EXE): $(call byte2native, $(CMPBYT))

################
# checkstack tool
# checkstack$(EXE): checkstack.$(O)
# 	$(MKEXE) $(OUTPUTEXE)$@ $<

################
#Scan latex files, and run ocaml code examples
# caml_tex_files := \
#   $(ROOTDIR)/compilerlibs/ocamlcommon.cma \
#   $(ROOTDIR)/compilerlibs/ocamlbytecomp.cma \
#   $(ROOTDIR)/compilerlibs/ocamltoplevel.cma \
#   $(ROOTDIR)/otherlibs/str/str.cma \
#   $(ROOTDIR)/otherlibs/$(UNIXLIB)/unix.cma \
#   caml_tex.ml
# caml_tex := caml-tex$(EXE)
# caml-tex uses str.cma and unix.cma and so must be compiled with
# $(ROOTDIR)/ocamlc not $(ROOTDIR)/boot/ocamlc since the boot
# compiler does not necessarily have the correct shared library
# configuration.
# $(caml_tex): INCLUDES += $(addprefix -I $(ROOTDIR)/otherlibs/,str $(UNIXLIB))
# $(caml_tex): $(caml_tex_files)
# 	$(OCAMLRUN) $(ROOTDIR)/ocamlc$(EXE) -nostdlib -I $(ROOTDIR)/stdlib \
# 	  $(LINKFLAGS) -linkall -o $@ -no-alias-deps $^
# # we need str and unix which depend on the bytecode version of other tools
# # thus we delay building caml-tex to the opt.opt stage
# ifneq "$(WITH_CAMLTEX)" ""
# opt.opt: $(caml_tex)
# endif


##########################################################
################  ocaml modules and sigs  ################
## dev/test - build everything
bootstrap_library(
    name = "tools",
    manifest  = [
        # ":Caml_tex",
        ":Cmpbyt",
        ":Dumpobj",
        # ":Eqparsetree",
        ":Objinfo",
        ":Ocamlcmt",
        ":Ocamlcp",
        ":Ocamldep",
        ":Ocamlmklib",
        ":Ocamlmktop",
        ":Ocamloptp",
        ":Ocamlprof",
        ":Primreq",
        ":Profiling",
        ":Stripdebug",
    ]
    ## TODO:
    # ] + select({
    #     "//compilers/mode:native": [":Lintapidiff.opt"]
    #     "//conditions:default": []
    # })
)

## FIXME: special handling
bootstrap_module(
    name   = "Caml_tex",
    struct = "caml_tex.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//driver:Compenv",
        "//driver:Compmisc",
        "//otherlibs/str:Str",
        "//parsing:Ast_helper",
        "//parsing:Ast_iterator",
        "//parsing:Lexer",
        "//parsing:Location",
        "//parsing:Parse",
        "//parsing:Parsetree_cmi",
        "//parsing:Syntaxerr",
        "//stdlib:Stdlib.Arg",
        "//stdlib:Stdlib.Buffer",
        "//stdlib:Stdlib.Bytes",
        "//stdlib:Stdlib.Filename",
        "//stdlib:Stdlib.Format",
        "//stdlib:Stdlib.Lexing",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Printexc",
        "//stdlib:Stdlib.StdLabels",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Sys",
        "//toplevel:Toploop",
        "//utils:Clflags",
        "//utils:Misc",
        ## (Unix)
        #### (Mtd)
        #### (Mty)
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Cmpbyt",
    struct = "cmpbyt.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//stdlib:Stdlib.Sys",
        "//stdlib:Stdlib.Printf",
        "//bytecomp:Bytesections",
        "//stdlib:Stdlib.Array",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Dumpobj",
    struct = "dumpobj.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//stdlib:Stdlib.Sys",
        "//bytecomp:Symtable",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Printf",
        ":Opnames",
        "//bytecomp:Opcodes",
        "//stdlib:Stdlib.Obj",
        "//parsing:Location",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Lexing",
        "//bytecomp:Instruct",
        "//typing:Ident",
        "//stdlib:Stdlib.Hashtbl",
        "//utils:Config",
        "//file_formats:Cmo_format_cmi",
        "//bytecomp:Bytesections",
        "//parsing:Asttypes_cmi",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.Arg",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Eqparsetree",
    struct = "eqparsetree.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        # "//parsing:Asttypes_cmi",
        "//parsing:Parsetree_cmi",
        # "//parsing:Longident",
        # "//parsing:Location",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Lintapidiff.opt",
    mode   = "native",
    struct = "lintapidiff.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//driver:Pparse",
        "//otherlibs/str:Str",
        "//parsing:Location",
        "//parsing:Parse",
        "//parsing:Parsetree_cmi",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.Filename",
        "//stdlib:Stdlib.Format",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Printf",
        "//stdlib:Stdlib.Scanf",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Sys",
        "//typing:Ident",
        "//typing:Path",
        "//typing:Printtyp",
        "//utils:Misc",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Objinfo",
    struct = "objinfo.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//stdlib:Stdlib.Sys",
        "//bytecomp:Symtable",
        "//middle_end:Symbol",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Printf",
        "//middle_end:Printclambda",
        "//utils:Misc",
        "//stdlib:Stdlib.List",
        "//middle_end:Linkage_name",
        #### (LargeFile)
        "//typing:Ident",
        "//stdlib:Stdlib.Format",
        "//stdlib:Stdlib.Filename",
        "//middle_end/flambda:Export_info",
        "//stdlib:Stdlib.Digest",
        "//middle_end:Compilation_unit",
        "//file_formats:Cmxs_format_cmi",
        "//file_formats:Cmx_format_cmi",
        "//file_formats:Cmt_format",
        "//file_formats:Cmo_format_cmi",
        "//file_formats:Cmi_format",
        "//bytecomp:Bytesections",
        "//utils:Binutils",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.Arg",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Ocamlcmt",
    struct = "ocamlcmt.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//typing:Untypeast",
        "//typing:Stypes",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Printf",
        "//parsing:Pprintast",
        "//parsing:Location",
        "//utils:Load_path",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Lexing",
        "//stdlib:Stdlib.Format",
        "//stdlib:Stdlib.Filename",
        "//typing:Envaux",
        "//stdlib:Stdlib.Digest",
        "//driver:Compmisc",
        "//file_formats:Cmt_format",
        "//typing:Cmt2annot",
        "//utils:Clflags",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.Arg",
        "//typing:Annot_cmi",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Ocamlcp",
    struct = "ocamlcp.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//stdlib:Stdlib.Sys",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Printf",
        "//driver:Main_args",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Filename",
        "//driver:Compenv",
        "//stdlib:Stdlib.Arg",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Ocamldep",
    struct = "ocamldep.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//driver:Makedepend"
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Ocamlmklib",
    struct = "ocamlmklib.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//stdlib:Stdlib.Sys",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Stack",
        "//stdlib:Stdlib.Printf",
        "//utils:Misc",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Filename",
        "//utils:Config",
        "//stdlib:Stdlib.Bytes",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.Arg",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Ocamlmktop",
    struct = "ocamlmktop.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//stdlib:Stdlib.Sys",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Filename",
        "//utils:Config",
        "//utils:Ccomp",
        "//stdlib:Stdlib.Array",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Ocamloptp",
    struct = "ocamloptp.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//stdlib:Stdlib.Sys",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Printf",
        "//driver:Main_args",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Filename",
        "//driver:Compenv",
        "//stdlib:Stdlib.Arg",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Ocamlprof",
    struct = "ocamlprof.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//parsing:Location",
        "//parsing:Parse",
        "//parsing:Parsetree_cmi",
        "//stdlib:Stdlib.Arg",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.Bytes",
        "//stdlib:Stdlib.Filename",
        "//stdlib:Stdlib.Format",
        "//stdlib:Stdlib.Int",
        "//stdlib:Stdlib.Lexing",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Option",
        "//stdlib:Stdlib.Printf",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Sys",
        "//utils:Warnings",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Primreq",
    struct = "primreq.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//file_formats:Cmo_format_cmi",
        "//stdlib:Stdlib.Arg",
        "//stdlib:Stdlib.List",
        "//utils:Config",
        "//utils:Misc",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Profiling",
    struct = "profiling.ml",
    sig    = "Profiling_cmi",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Sys",
    ],
    data = ["//runtime:primitives"]
)

bootstrap_signature(
    name = "Profiling_cmi",
    src  = "profiling.mli",
    opts = SIG_OPTS,
    deps   = STDLIB + [
    ],
    data = ["//runtime:primitives"]
)

bootstrap_module(
    name   = "Stripdebug",
    struct = "stripdebug.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
        "//bytecomp:Bytesections",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Printf",
        "//stdlib:Stdlib.Sys",
        "//utils:Misc",
    ],
    data = ["//runtime:primitives"]
)

################################################################
## root Makefile: The numeric opcodes
# make_opcodes := tools/make_opcodes$(EXE)
# bytecomp/opcodes.ml: runtime/caml/instruct.h $(make_opcodes)
# 	$(NEW_OCAMLRUN) $(make_opcodes) -opcodes < $< > $@
# bytecomp/opcodes.mli: bytecomp/opcodes.ml
# 	$(CAMLC) -i $< > $@
# $(make_opcodes): tools/make_opcodes.mll
# 	$(MAKE) -C tools make_opcodes

## tools/Makefile
# CAMLC = $(BOOT_OCAMLC) -g -nostdlib -I $(ROOTDIR)/boot \
#         -use-prims $(ROOTDIR)/runtime/primitives -I $(ROOTDIR)
# make_opcodes := make_opcodes$(EXE)
# $(eval $(call PROGRAM_SYNONYM,make_opcodes))
# $(make_opcodes): make_opcodes.ml
# 	$(CAMLC) $< -o $@

# toolchain uses //boot:ocamlc ==  BOOT_OCAMLC
bootstrap_executable(
    name = "make_opcodes",
    main = ":Make_opcodes",
    # deps = ["//stdlib:Std_exit"],
    # opts = ["-w", "-31"],
    # data = ["//stdlib:header"],
    visibility = ["//bytecomp:__pkg__"]
)

bootstrap_module(
    name   = "Make_opcodes",
    struct = "make_opcodes.ml",
    opts = MODULE_OPTS,
    deps   = STDLIB + [
    ],
    data = ["//runtime:primitives"]
)

bootstrap_ocamllex(
    name = "make_opcodes_ml",
    out  = "make_opcodes.ml",
    src  = "make_opcodes.mll"
)
