package(default_visibility = ["//visibility:public"])

load("//bzl:rules.bzl",
     "boot_executable",
     "boot_library",
     "boot_lexer",
     "build_module",
     "build_tool",
     "compiler_module",
     "compiler_signature",
     "ocaml_tool"
)

exports_files([
    "check-parser-uptodate-or-warn.sh",
])

load("//config:CONFIG.bzl", "w") # warnings

MODULE_OPTS = []
SIG_OPTS    = []

## first the executables. modules and sigs below.
# programs_byte := \
#   ocamldep ocamlprof ocamlcp ocamloptp ocamlmklib  \
#   ocamlmktop ocamlcmt dumpobj ocamlobjinfo \
#   primreq stripdebug cmpbyt
# $(programs_byte:%=%$(EXE)):
# 	$(CAMLC) $(LINKFLAGS) -I $(ROOTDIR) -o $@ $(filter-out %.cmi,$^)

## OBazl divides these into two classes: build tools and ocaml tools.
## The former are used only to build the compiler and tools, or for
## use by compiler engineers; the latter are utilities designed for users.

################################################################
# The dependency generator
# OCAMLDEP = \
#   $(ROOTDIR)/compilerlibs/ocamlcommon.cma \
#   $(ROOTDIR)/compilerlibs/ocamlbytecomp.cma \
#   ocamldep.cmo depend.cmi
# ocamldep$(EXE): LINKFLAGS += -compat-32
# ocamldep$(EXE): $(OCAMLDEP)
# ocamldep.opt$(EXE): $(call byte2native, $(OCAMLDEP))

ocaml_tool(
    name = "ocamldep",
    main = ":Ocamldep",
    prologue = [
        "//compilerlibs:ocamlcommon",
        "//bytecomp:ocamlbytecomp",
    ]
)

################################################################
# Profiling: https://ocaml.org/manual/profil.html
# The OCaml profiling compilers: ocamlcp, ocamloptp, ocamlprof
ocaml_tool(
    name = "ocamlprof",
    prologue = [
        "//config:Config",
        "//utils:Build_path_prefix_map",
        "//utils:Misc",
        "//utils:Identifiable",
        "//utils:Numbers",
        "//utils:Arg_helper",
        "//utils:Clflags",
        "//utils:Terminfo",
        "//utils:Warnings",
        "//parsing:Location",
        "//parsing:Longident",
        "//parsing:Docstrings",
        "//parsing:Syntaxerr",
        "//parsing:Ast_helper",
        "//parsing:CamlinternalMenhirLib",
        "//parsing:Parser",
        "//parsing:Pprintast",
        "//parsing:Lexer",
        "//parsing:Parse",
    ],
    main = ":Ocamlprof",
    # warnings = ["$(WARNINGS)"],
    use_prims = True,
    # toolchains = ["//toolchain/profile/ocaml"]
)

ocaml_tool(
    name = "ocamlcp",
    main = ":Ocamlcp",
    prologue = [
        "//config:Config",
        "//utils:Build_path_prefix_map",
        "//utils:Misc",
        "//utils:Profile",
        "//utils:Warnings",
        "//utils:Identifiable",
        "//utils:Numbers",
        "//utils:Arg_helper",
        "//utils:Clflags",
        "//utils:Local_store",
        "//utils:Terminfo",
        "//parsing:Location",
        "//utils:Load_path",
        "//utils:Ccomp",
        "//driver:Compenv",
        "//driver:Main_args",
        ":Ocamlcp_common"
    ]
)

# profiling compiler
ocaml_tool(
    name = "ocamloptp",
    main = ":Ocamloptp",
    prologue = [
        "//config:Config",
        "//utils:Build_path_prefix_map",
        "//utils:Misc",
        "//utils:Profile",
        "//utils:Warnings",
        "//utils:Identifiable",
        "//utils:Numbers",
        "//utils:Arg_helper",
        "//utils:Clflags",
        "//utils:Local_store",
        "//utils:Terminfo",
        "//parsing:Location",
        "//utils:Load_path",
        "//utils:Ccomp",
        "//driver:Compenv",
        "//driver:Main_args",
        ":Ocamlcp_common"
    ]
)

################################################################
# To help building mixed-mode libraries (OCaml + C)
ocaml_tool(
    name = "ocamlmklib",
    main = ":Ocamlmklib",
    prologue = [
        "//config:Config",
        "//utils:Build_path_prefix_map",
        "//utils:Misc",
    ]
)

################################################################
# To make custom toplevels
# OCAMLMKTOP=config.cmo build_path_prefix_map.cmo misc.cmo \
#        identifiable.cmo numbers.cmo arg_helper.cmo clflags.cmo \
#        local_store.cmo load_path.cmo profile.cmo ccomp.cmo ocamlmktop.cmo
# ocamlmktop$(EXE): $(OCAMLMKTOP)
# ocamlmktop.opt$(EXE): $(call byte2native, $(OCAMLMKTOP))
ocaml_tool(
    name = "ocamlmktop",
    main = ":Ocamlmktop",
    prologue = [
        "//config:Config",
        "//utils:Build_path_prefix_map",
        "//utils:Misc",
        "//utils:Identifiable",
        "//utils:Numbers",
        "//utils:Arg_helper",
        "//utils:Clflags",
        "//utils:Local_store",
        "//utils:Load_path",
        "//utils:Profile",
        "//utils:Ccomp",
    ]
)

################################################################
# The preprocessor for asm generators
# cvt_emit := cvt_emit$(EXE)
# $(eval $(call PROGRAM_SYNONYM,cvt_emit))
# $(cvt_emit): cvt_emit.cmo
# 	$(CAMLC) $(LINKFLAGS) -o $@ $^

##FIXME: this should only be built as a vm executable
# ocaml_tool(
build_tool(
    name = "cvt_emit.exe",
    main = ":Cvt_emit",
    visibility = ["//asmcomp:__subpackages__"]
)

build_module(
    name   = "Cvt_emit",
    struct = "cvt_emit_ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        "//stdlib:Stdlib.Lexing",
        "//stdlib:Stdlib.Printf",
        "//stdlib:Stdlib.Sys",
        "//bytecomp:Bytesections",
        "//stdlib:Stdlib.Array",
    ],
)

boot_lexer(
    name = "cvt_emit_ml",
    src  = "cvt_emit.mll"
)

################################################################
# Reading cmt files
ocaml_tool(
    name = "ocamlcmt",
    main = ":Ocamlcmt",
    prologue = [
        "//compilerlibs:ocamlcommon",
        "//bytecomp:ocamlbytecomp",
    ]
)

################################################################
# The bytecode disassembler
# DUMPOBJ= \
#           $(ROOTDIR)/compilerlibs/ocamlcommon.cma \
#           $(ROOTDIR)/compilerlibs/ocamlbytecomp.cma \
#           opnames.cmo dumpobj.cmo
# dumpobj$(EXE): $(DUMPOBJ)
# dumpobj.opt$(EXE): $(call byte2native, $(DUMPOBJ))

build_tool(
    name = "dumpobj",
    main = ":Dumpobj",
    prologue = [
        "//compilerlibs:ocamlcommon",
        "//bytecomp:ocamlbytecomp",
        ":Opnames",
        ":Dumpobj"
    ],
)

################################################################
## ocamlobjinfo - Display info on compiled files
ocaml_tool(
    name = "ocamlobjinfo",
    main = ":Objinfo",
    prologue = [
        # "//stdlib",
        # "//utils:Ccomp",
        "//compilerlibs:ocamlcommon",
        "//bytecomp:ocamlbytecomp",
        "//middle_end:ocamlmiddleend",
    ],
    opts = [
        "-linkall",
        "-nostdlib",
        "-I", "bazel-out/darwin-fastbuild/bin/utils/_vmvm1",
        "-I", "bazel-out/darwin-fastbuild/bin/driver/_vmvm1"
    ],
    # warnings = [w.MODULE_LINKED_TWICE]
)

################################################################
# # Scan object files for required primitives
# PRIMREQ=$(ROOTDIR)/compilerlibs/ocamlcommon.cma \
#         $(ROOTDIR)/compilerlibs/ocamlbytecomp.cma \
#         primreq.cmo
# primreq$(EXE): $(PRIMREQ)
# primreq.opt$(EXE): $(call byte2native, $(PRIMREQ))
ocaml_tool(
    name = "primreq",
    main = ":Primreq",
    prologue = [
        "//compilerlibs:ocamlcommon",
        "//bytecomp:ocamlbytecomp",
    ]
)

################
# Copy a bytecode executable, stripping debug info
ocaml_tool(
    name = "stripdebug",
    main = ":Stripdebug",
    prologue = [
        "//compilerlibs:ocamlcommon",
        "//bytecomp:ocamlbytecomp",
    ]
)

################
# make_opcodes, opnames.ml
# OCAMLRUN ?= $(ROOTDIR)/boot/ocamlrun$(EXE)
# NEW_OCAMLRUN ?= $(ROOTDIR)/runtime/ocamlrun$(EXE)
# opnames.ml: $(ROOTDIR)/runtime/caml/instruct.h $(make_opcodes)
# 	$(NEW_OCAMLRUN) $(make_opcodes) -opnames < $< > $@
compiler_module(
    name = "Opnames",
    struct = "opnames.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI]
)


# ./runtime/ocamlrun tools/make_opcodes -opcodes < runtime/caml/instruct.h > bytecomp/opcodes.ml

genrule(
    name = "gen_opnames",
    outs = ["opnames.ml"],
    srcs = ["//runtime/caml:instruct.h", ":make_opcodes"],
    tools = ["//boot/baseline:ocamlrun"],
    cmd   = " ".join([
        "$(execpath //boot/baseline:ocamlrun) $(location :make_opcodes)",
        "-opcodes < $(location //runtime/caml:instruct.h)",
        "> $@"
    ])
)

################################################################
# LINTAPIDIFF=$(ROOTDIR)/compilerlibs/ocamlcommon.cmxa \
#         $(ROOTDIR)/compilerlibs/ocamlbytecomp.cmxa \
#         $(ROOTDIR)/compilerlibs/ocamlmiddleend.cmxa \
#         $(ROOTDIR)/otherlibs/str/str.cmxa \
#         lintapidiff.cmx

# lintapidiff.opt$(EXE): INCLUDES+= -I $(ROOTDIR)/otherlibs/str
# lintapidiff.opt$(EXE): $(LINTAPIDIFF)
# 	$(CAMLOPT_CMD) $(LINKFLAGS) -I $(ROOTDIR) -o $@ $(LINTAPIDIFF)

################
# checkstack tool
# checkstack$(EXE): checkstack.$(O)
# 	$(MKEXE) $(OUTPUTEXE)$@ $<

################
#Scan latex files, and run ocaml code examples
# caml_tex_files := \
#   $(ROOTDIR)/compilerlibs/ocamlcommon.cma \
#   $(ROOTDIR)/compilerlibs/ocamlbytecomp.cma \
#   $(ROOTDIR)/compilerlibs/ocamltoplevel.cma \
#   $(ROOTDIR)/otherlibs/str/str.cma \
#   $(ROOTDIR)/otherlibs/$(UNIXLIB)/unix.cma \
#   caml_tex.ml
# caml_tex := caml-tex$(EXE)
# caml-tex uses str.cma and unix.cma and so must be compiled with
# $(ROOTDIR)/ocamlc not $(ROOTDIR)/boot/ocamlc since the boot
# compiler does not necessarily have the correct shared library
# configuration.
# $(caml_tex): INCLUDES += $(addprefix -I $(ROOTDIR)/otherlibs/,str $(UNIXLIB))
# $(caml_tex): $(caml_tex_files)
# 	$(OCAMLRUN) $(ROOTDIR)/ocamlc$(EXE) -nostdlib -I $(ROOTDIR)/stdlib \
# 	  $(LINKFLAGS) -linkall -o $@ -no-alias-deps $^
# # we need str and unix which depend on the bytecode version of other tools
# # thus we delay building caml-tex to the opt.opt stage
# ifneq "$(WITH_CAMLTEX)" ""
# opt.opt: $(caml_tex)
# endif


##########################################################
################  ocaml modules and sigs  ################
## TODO: get the unix stuff set up
# compiler_module(
#     name   = "Caml_tex",
#     struct = "caml_tex.ml",
#     opts = MODULE_OPTS,
#     deps   = [
#         "//driver:Compenv",
#         "//driver:Compmisc",
#         "//otherlibs/str:Str",
#         "//parsing:Ast_helper",
#         "//parsing:Ast_iterator",
#         "//parsing:Lexer",
#         "//parsing:Location",
#         "//parsing:Parse",
#         "//parsing:Parsetree_cmi",
#         "//parsing:Syntaxerr",
#         "//stdlib:Stdlib.Arg",
#         "//stdlib:Stdlib.Buffer",
#         "//stdlib:Stdlib.Bytes",
#         "//stdlib:Stdlib.Filename",
#         "//stdlib:Stdlib.Format",
#         "//stdlib:Stdlib.Lexing",
#         "//stdlib:Stdlib.List",
#         "//stdlib:Stdlib.Printexc",
#         "//stdlib:Stdlib.StdLabels",
#         "//stdlib:Stdlib.String",
#         "//stdlib:Stdlib.Sys",
#         "//toplevel:Toploop",
#         "//utils:Clflags",
#         "//utils:Misc",
#         ## (Unix)
#         #### (Mtd)
#         #### (Mty)
#     ],
# )

compiler_module(
    name   = "Cmpbyt",
    struct = "cmpbyt.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        "//stdlib:Stdlib.Sys",
        "//stdlib:Stdlib.Printf",
        "//bytecomp:Bytesections",
        "//stdlib:Stdlib.Array",
    ],
)

compiler_module(
    name   = "Dumpobj",
    # target_compatible_with = ["//platform/target:sys?"],
    struct = "dumpobj.ml",
    opts = MODULE_OPTS,
    deps   = [
        "//stdlib:Stdlib.Sys",
        "//bytecomp:Symtable",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Printf",
        ":Opnames",
        "//bytecomp:Opcodes",
        "//stdlib:Stdlib.Obj",
        "//parsing:Location",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Lexing",
        "//bytecomp:Instruct",
        "//typing:Ident",
        "//stdlib:Stdlib.Hashtbl",
        "//config:Config",
        # "//file_formats:Cmo_format_cmi",
        "//bytecomp:Bytesections",
        # "//parsing:Asttypes_cmi",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.Arg",
    ],
)

# eqparsetree.ml", line 66, characters 7-22:
# 66 |     | (Const_string a0, Const_string b0) -> eq_string (a0, b0)
#             ^^^^^^^^^^^^^^^
# Error: The constructor Const_string expects 3 argument(s),
#        but is applied here to 1 argument(s)
# compiler_module(
#     name   = "Eqparsetree",
#     struct = "eqparsetree.ml",
#     opts = MODULE_OPTS,
#     deps   = [
#         # "//parsing:Asttypes_cmi",
#         "//parsing:Parsetree_cmi",
#         # "//parsing:Longident",
#         # "//parsing:Location",
#     ],
# # )

# lintapidiff.ml", line 41, characters 15-29:
# 41 | module IdMap = Misc.StringMap
#                     ^^^^^^^^^^^^^^
# Error: Unbound module Misc.StringMap
# compiler_module(
#     name   = "Lintapidiff.opt",
#     mode   = "native",
#     struct = "lintapidiff.ml",
#     opts = MODULE_OPTS,
#     deps   = [
#         "//driver:Pparse",
#         "//otherlibs/str:Str",
#         "//parsing:Location",
#         "//parsing:Parse",
#         "//parsing:Parsetree_cmi",
#         "//stdlib:Stdlib.Array",
#         "//stdlib:Stdlib.Filename",
#         "//stdlib:Stdlib.Format",
#         "//stdlib:Stdlib.List",
#         "//stdlib:Stdlib.Printf",
#         "//stdlib:Stdlib.Scanf",
#         "//stdlib:Stdlib.String",
#         "//stdlib:Stdlib.Sys",
#         "//typing:Ident",
#         "//typing:Path",
#         "//typing:Printtyp",
#         "//utils:Misc",
#     ],
# # )

compiler_module(
    name   = "Objinfo",
    struct = "objinfo.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        "//stdlib:Stdlib.Sys",
        "//bytecomp:Symtable",
        "//middle_end:Symbol",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Printf",
        "//middle_end:Printclambda",
        "//utils:Misc",
        "//stdlib:Stdlib.List",
        "//middle_end:Linkage_name",
        "//typing:Ident",
        "//stdlib:Stdlib.Format",
        "//stdlib:Stdlib.Filename",
        "//middle_end/flambda:Export_info",
        "//stdlib:Stdlib.Digest",
        "//middle_end:Compilation_unit",
        "//bytecomp:Bytesections",
        "//utils:Binutils",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.Arg",

        "//file_formats:Cmi_format_cmi",
        "//file_formats:Cmo_format_cmi",
        "//file_formats:Cmt_format_cmi",
        "//file_formats:Cmx_format_cmi",
        "//file_formats:Cmxs_format_cmi",
    ],
)

compiler_module(
    name   = "Ocamlcmt",
    struct = "ocamlcmt.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        "//typing:Untypeast",
        "//typing:Stypes",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Printf",
        "//parsing:Pprintast",
        "//parsing:Location",
        "//utils:Load_path",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Lexing",
        "//stdlib:Stdlib.Format",
        "//stdlib:Stdlib.Filename",
        "//typing:Envaux",
        "//stdlib:Stdlib.Digest",
        "//driver:Compmisc",
        "//file_formats:Cmt_format",
        "//typing:Cmt2annot",
        "//utils:Clflags",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.Arg",
        # "//typing:Annot_cmi",
    ],
)

compiler_module(
    name   = "Ocamlcp",
    struct = "ocamlcp.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        "//stdlib:Stdlib.Sys",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Printf",
        "//driver:Main_args",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Filename",
        "//driver:Compenv",
        "//stdlib:Stdlib.Arg",
        ":Ocamlcp_common"
    ],
)

compiler_module(
    name   = "Ocamlcp_common",
    struct = "ocamlcp_common.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        # "//stdlib:Stdlib.Sys",
        # "//stdlib:Stdlib.String",
        # "//stdlib:Stdlib.Printf",
        "//driver:Main_args",
        # "//stdlib:Stdlib.List",
        # "//stdlib:Stdlib.Filename",
        # "//driver:Compenv",
        # "//stdlib:Stdlib.Arg",
    ],
)

compiler_module(
    name   = "Ocamldep",
    struct = "ocamldep.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        "//driver:Makedepend"
    ],
)

compiler_module(
    name   = "Ocamlmklib",
    struct = "ocamlmklib.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        "//stdlib:Stdlib.Sys",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Stack",
        "//stdlib:Stdlib.Printf",
        "//utils:Misc",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Filename",
        "//config:Config",
        "//stdlib:Stdlib.Bytes",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.Arg",
    ],
)

compiler_module(
    name   = "Ocamlmktop",
    struct = "ocamlmktop.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        "//stdlib:Stdlib.Sys",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Filename",
        "//config:Config",
        "//utils:Ccomp",
        "//stdlib:Stdlib.Array",
    ],
)

compiler_module(
    name   = "Ocamloptp",
    struct = "ocamloptp.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        "//driver:Compenv",
        "//driver:Main_args",
        "//stdlib:Stdlib.Arg",
        "//stdlib:Stdlib.Filename",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Printf",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Sys",
        ":Ocamlcp_common"
    ],
)

compiler_module(
    name   = "Ocamlprof",
    struct = "ocamlprof.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        "//parsing:Location",
        "//parsing:Parse",
        # "//parsing:Parsetree_cmi",
        "//stdlib:Stdlib.Arg",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.Bytes",
        "//stdlib:Stdlib.Filename",
        "//stdlib:Stdlib.Format",
        "//stdlib:Stdlib.Int",
        "//stdlib:Stdlib.Lexing",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Option",
        "//stdlib:Stdlib.Printf",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Sys",
        "//utils:Warnings",
    ],
)

compiler_module(
    name   = "Primreq",
    struct = "primreq.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        "//file_formats:Cmo_format_cmi",
        "//stdlib:Stdlib.Arg",
        "//stdlib:Stdlib.List",
        "//config:Config",
        "//utils:Misc",
    ],
)

compiler_module(
    name   = "Profiling",
    struct = "profiling.ml",
    sig    = "Profiling_cmi",
    opts = MODULE_OPTS,
    deps   = [
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Sys",
    ],
)

compiler_signature(
    name = "Profiling_cmi",
    src  = "profiling.mli",
    opts = SIG_OPTS,
    deps   = [
    ],
)

# ../boot/ocamlrun ../boot/ocamlc
compiler_module(
    name   = "Stripdebug",
    struct = "stripdebug.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI],
    deps   = [
        "//bytecomp:Bytesections",
        "//stdlib:Stdlib.Array",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Printf",
        "//stdlib:Stdlib.Sys",
        "//utils:Misc",
    ],
)

################
# Compare two bytecode executables
# CMPBYT=$(ROOTDIR)/compilerlibs/ocamlcommon.cma \
#        $(ROOTDIR)/compilerlibs/ocamlbytecomp.cma \
#        cmpbyt.cmo
# cmpbyt$(EXE): $(CMPBYT)
# cmpbyt.opt$(EXE): $(call byte2native, $(CMPBYT))
build_tool(
    name = "cmpbyt",
    main = ":Cmpbyt",
    prologue = [
        "//compilerlibs:ocamlcommon",
        "//bytecomp:ocamlbytecomp",
    ]
)

################################################################
## root Makefile: The numeric opcodes
# make_opcodes := tools/make_opcodes$(EXE)
# bytecomp/opcodes.ml: runtime/caml/instruct.h $(make_opcodes)
# 	$(NEW_OCAMLRUN) $(make_opcodes) -opcodes < $< > $@
# bytecomp/opcodes.mli: bytecomp/opcodes.ml
# 	$(CAMLC) -i $< > $@
# $(make_opcodes): tools/make_opcodes.mll
# 	$(MAKE) -C tools make_opcodes

## tools/Makefile
# CAMLC = $(BOOT_OCAMLC) -g -nostdlib -I $(ROOTDIR)/boot \
#         -use-prims $(ROOTDIR)/runtime/primitives -I $(ROOTDIR)
# make_opcodes := make_opcodes$(EXE)
# $(eval $(call PROGRAM_SYNONYM,make_opcodes))
# $(make_opcodes): make_opcodes.ml
# 	$(CAMLC) $< -o $@

## macos make.log:
# cd stdlib - stdlib includes links to runtime/libcamlrun.a, runtime/libasmrun.a
# ../boot/ocamlrun ../boot/ocamllex -q make_opcodes.mll
## compile and link:
# ../boot/ocamlrun ../boot/ocamlc -nostdlib -I ../boot -g -use-prims ../runtime/primitives -I .. make_opcodes.ml -o make_opcodes
## run:
# ./runtime/ocamlrun tools/make_opcodes -opcodes < runtime/caml/instruct.h > bytecomp/opcodes.ml

# baseline_executable(
#     name = "baseline_opcodes",
#     main = ":Make_opcodes",
#     visibility = ["//bytecomp:__pkg__"]
# )

build_tool(
    name = "make_opcodes",
    data = ["//stdlib:camlheaders"],
    main = ":Make_opcodes",
    prologue = [
        # "//stdlib:Std_exit",
        "//stdlib"
    ],
    visibility = ["//bytecomp:__pkg__"]
)

compiler_module(
    name   = "Make_opcodes",
    struct = "make_opcodes_ml",
    nocopts = True,
    deps = [
        "//stdlib:Stdlib",
        "//stdlib:Stdlib.Arg",
        "//stdlib:Stdlib.Lexing",
        "//stdlib:Stdlib.Printf",
    ],
    opts = ["-nostdlib"],
    warnings = [w.MISSING_MLI]
)

boot_lexer(
    name = "make_opcodes_ml",
    src  = "make_opcodes.mll",
)

################################################################
load("@bazel_skylib//rules:build_test.bzl", "build_test")
build_test(
    name = "tools",
    targets = [
        # ":Caml_tex",
        ":cmpbyt",
        # ":dumpobj",   ## sys target only
        # ":Eqparsetree",
        ":ocamlobjinfo",
        ":ocamlcmt",
        ":ocamlcp",
        ":ocamldep",
        ":ocamlmklib",
        ":ocamlmktop",
        ":ocamloptp",
        ":ocamlprof",
        ":primreq",
        ":stripdebug",
    ]
    ## TODO:
    # ] + select({
    #     "//compilers/mode:native": [":Lintapidiff.opt"]
    #     "//conditions:default": []
    # })
)

