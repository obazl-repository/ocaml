= OCaml: Proof-of-Concept OBazl Build
:toc: auto
:toclevels: 3

See the link:https://github.com/ocaml/ocaml[upstream repository] for the original OCaml README.

==== Quickstart

WARNING: (11/14/22) These instructions are outdated.  Refreshed instructions will be posted soon.

1. Install Bazel.  Recommendation: link:https://github.com/bazelbuild/bazelisk[Bazelisk]

2. Clone link:https://github.com/obazl-repository/ocaml[this repo].

3. `cd` into the root directory of the cloned repo and run configure: `$ ./configure`

4. Build the principal tools: `$ bazel test :toolchain`
+
Target `:toolchain` builds all main targets; it's defined in
link:BUILD.bazel[BUILD.bazel]. The main build targets are listed there.
+
5. Use Zig:  `$ bazel build boot/compiler --config=maczig` (or `--config=linuxzig`)

6. Use a debug variant of the runtime (instead of `build boot/baseline:ocamlrund`):

    $ bazel build boot/baseline:ocamlrun -c dbg

6. Cross-compile:

  a. mac->linux:  `$ bazel build boot/baseline:ocamlrun --config=mac_linuxamd64`
  a. linux->mac:  `$ bazel build boot/baseline:ocamlrun --config=linuxamd64_macamd64`

You can build and run executables under Bazel by using the `run` command instead of `build`; put arguments after `--`. For example:

     $ bazel run boot/compiler --config=maczig -- -version

To get more verbose output pass `--config=show`

See link:bzl/docs/usage.adoc[usage] for more information.

== Overview

OBazl is a Bazel Language Support Pack for OCaml. This fork of the
OCaml compiler toolset repository contains a Proof-of-Concept build
program written in OBazl. As a Proof-of-Concept whose primary purpose
is to demonsrate the capabilities of OBazl, it only builds a subset of
the targets supported by the Makefile-based production build program,
and it does not support the full range of configuration options.

It can build (bootstrap):

* compilers: `ocamlc`, `ocamlopt`
* tools: `ocamllex`, `ocamlyacc`, `ocamlobjinfo`, etc.

These targets can be built on Macos and Linux.

The OBazl ruleset used is a stripped-down, minimal version of the
standard ruleset called the `bootstrap` ruleset. It includes only the
functionality required to build the compiler. This means it contains
no direct support for PPX processing or for generalized namespaces
(automatic renaming of subcomponents, generation of resolver module),
for example. Furthermore, since the bootstrap ruleset is intended
solely for the purpose of bootstrapping the OCaml compilers and tools,
it is included in this repository (i.e. is not downloaded as an
external repository.)

More detailed documentation is in link:bzl/docs[bzl/docs].

Why use a minimal ruleset? Several reasons. Bootstrapping requires
some special support that is never needed for ordinary OCaml builds,
so we do not want to add that overhead to the standard ruleset. The
bootstrap ruleset is easy to understand and modify, so it serves as a
useful intro to the standard OBazl ruleset.

The build structure of the compilers is actually fairly
straightforward, in most places. It uses only one namespace (what Dune
calls a "wrapped" library), the Standard Library, whose resolver (or
"mapping") module is hand-coded. The bootstrapping process is a little
more complicated, but understandable. The most complicated part is
probably the preprocessing; but even the more complicated bits of
preprocessing are handled fairly easily by standard Bazel facilities.
It involves C interfacing. All of this makes this a useful starting
point for people interested in learning how to build OCaml software
using Obazl.


link:https://obazl.github.io/docs_obazl/[The OBazl Toolsuite] - outdated but still useful.


== Goals

=== Baseline version

The minimal Bazel build program needed to produce usable versions of the core compilers and tools.

Core compilers: `ocamlc.byte`, `ocamlc.opt`, `ocamlopt.byte`, `ocamlopt.opt`.

Core tools: bytecode and native versions of: `ocamllex`, `ocamlyacc`, `ocamlobjinfo`, etc.

=== Bootstrap the bootstrappers

Build new versions of the precompiled bootstrap tools (`ocamlc` and
`ocamllex`) that come with the distribution.


=== Minimal configuration

Configuration is the most complex part of the build. The legacy build
system (Makefiles) supports many configuration options. The initial
goal is to support the minimum configuration options required to build
baseline versions of the compilers and tools.

Configuration involves:

* Auto-detected feature options set by `./configure` by interrogating
  the system. This usually results in setting `#define` macros or `-D`
  build flags in source files or headers; e.g.
+
    #define HAS_MACH_ABSOLUTE_TIME 1      #  in runtime/caml/s.h
    let ocamlc_cppflags = "-D_FILE_OFFSET_BITS=64 "  # in utils/config_ml.generated
+
* User-controllable configuration options exposed by `./configure`, e.g.
+
    --disable-debug-runtime
+
* User-controllable build options - arguments or env variables passed
  to `make`; e.g. `CC`, `CFLAGS`, etc. Many such make/compiler/linker
  variables are set to default values by `./configure`.

The OBazl rules always set such configuration items to default values.

In general configuration management under Bazel is very different (and
much easier) than it is with configure/make. I don't have detailed
documentation yet, but you can find lots of notes in link:bzl/docs[bzl/docs].

=== Debug builds

Support for link:https://github.com/google/sanitizers[sanitized]
builds of the C runtimes is a goal, but not a requirement.

=== Alternate C Compilers

Support for
link:https://sr.ht/~motiejus/bazel-zig-cc/[Zig] and link:https://github.com/grailbio/bazel-toolchain[LLVM].

=== Cross-compiling

Bazel has excellent support for cross-compilation via link:https://bazel.build/extending/platforms[platforms] and link:https://bazel.build/extending/toolchains[toolchains]; for an overview see link:https://bazel.build/concepts/platforms[Building with platforms].

Goal: cross-compile non-cross-compilers. For example, to build, on an
x86 Mac, an arm Mac compiler, an x86 Linux compiler, an arm Linux compiler, etc.

Goal: cross-compile cross-compilers. For example, to build,
on an x86 Mac, a Linux x86 -> Linux arm OCaml compiler.

=== Mainainability

Eventually the code will be simplified and easy to read.

=== Persistent Workers

Bazel supports link:https://bazel.build/remote/persistent[persistent
workers] - tools that effectively run as service providers. Without
persistent workers, the compiler must startup, run, and shutdown once
for each file it compiles. With a persistent worker, the compiler
starts up once and stays loaded; clients then pass it source files to
compile.

Implementing OCaml compilers as persistent workers is really a
separate project, but I list it here as a general goal anyway.


== Non-Goals

* Configuration completeness: it is not a goal to support all configuration
settings supported by the legacy build system. That is, it is not a
goal to expose such settings as user-controllable build options.
+
For example, here are some settings supported by `./configure` that will not be exposed:
+
** `--disable-str-lib`
** `--disable-unix-lib`* `
** `--enable-frame-pointers`
** `--disable-cfi`
** etc.
+
Bazel is certainly capable of supporting such options, but for the
baseline version it is not a goal to do so.
+

* Documentation builds.

* Simultaneous builds of multiple variants. The legacy build system
  builds `ocamlrun`, `ocamlrund`, as well as bytecode and native
  variants of the compilers and tools.  OBazl builds one thing at a time.  See below, <<parameterized_build_targets>>.

* OPAM support

* Distribution: packaging builds for distribution is not a goal. No
point in supporting release builds unless and until the maintainers
decide they want to use Bazel in production. Such packaging logic is
generally not included in Bazel language rules, whose job is solely to
build things. Instead it is provided by separate rulesets such as:
+
** link:https://github.com/bazelbuild/rules_pkg[rules_pkg]
** link:https://github.com/vaticle/bazel-distribution[bazel-distribution]

== Status  (2022/11/8)

=== Legacy versions

The OBazl code suffices to build some earlier versions, e.g. 4.14.0,
5.0. Work is underway to upgrade it to support the latest version
(5.1.x).  The 5.1.x code has a lot of changes that I do not plan to backport.

IMPORTANT: The code does not yet support the "fixpoint" build
expressed by the Makefiles. Instead it uses "stages": the bootstrap
compiler (the precompiled `ocamlc` that comes with the distribution)
is used to build the stage1 `ocamlc`, which is used to build the
stage2 `ocamlc`.  This mechanism is still under development.

==== branch: bazel/4.14.0

All the compilers and tools build.

=== bazel/trunk

The main branch of this repository is `bazel/trunk`; it tracks the
`trunk` branch of the upstream repository (and so may be outdated at
any given point in time).

==== Configuration

The Bazel build program supports command-line options to control:

* Platform-based toolchain selection - see link:bzl/docs/toolchains.adoc[toolchains] for more information
* Build subvariants - standard, debug, and instrumented builds - see link:bzl/docs/build_variants.adoc[build_variants]
* Debugging profiles. Debugging configuration is rather involved,
  since the C runtimes and the OCaml tools can be debugged separately.
  Furthermore, there are two kinds of debugging: one involves building
  with `-g` and use of the debugger, and other (for C) involves
  setting preproccessor macros (typically `-DDEBUG`) whether or not
  `-g` is used. The Bazel build program affords fine-grained control
  of debug profiles - see link:bzl/docs/debugging.adoc[debugging] for details.
* Compile/link flags - by default, bootstrapping builds use flags like
  `-nostdlib`, `-use-prims`, `-principal`, etc. These are globally
  controllable. For example during development one might want to use
  `-no-principal`, or use a customize `primitives` file. These
  configurations can be set on the command line (or via `.bazelrc`).
  See link:bzl/docs/configuration.adoc[configuration] for more
  information.
* Build structure configuration. For lack of a better term. For
  example, configuration setting `--//config:sig_src` (subject to
  renaming) can be used to control whether or not `.mli` files are
  separately compiled, if the build targets are configured to use it.  For an example see target link:https://github.com/obazl-repository/ocaml/blob/1cef348aa2fd3536883169ad8b371d5c36870736/stdlib/BUILD.bazel#L2320-L2328[Stdlib.Weak].

==== Baseline builds

Baseline builds use the bootstrap toolchain. The build targets are in
`//boot/baseline` and `//boot/lib`.

The main build targets are listed in link:Build.bazel[Build.bazel].
Target `//:toolchain` is a test target that builds all of them.

Docs and the debugger are not yet bazelized.

==== Cross-builds

Cross-compilation of the runtimes works: you can build a Linux x86_64
runtime on a MacOS x86_64 build host, for example. Cross-compilation
of the OCaml tools is currently limited to what can be produced by the
`vm>vm` bootstrap compiler, i.e. `ocamlopt.byte`, which runs on the VM
and emits native code. But support for variants of `ocamlopt.byte`
targeting different native platforms is not yet supported. Only the
variant targeting the local native platform is supported.

For more information see link:bzl/docs/cross_compilation.adoc[bzl/docs/cross_compilation.adoc]



== The OBazl Build: concepts and structure

WARNING: You must run `./configure` before running Bazel builds.

Just some notes to help the reader of the code:

=== Notation and Terminology

* *bootstrap compiler* (aka boot compiler) - the precompiled `ocamlc`
  compiler that comes with the distribution, or one produced by the
  bootstrap build described below. A bootstrap compiler is "vanilla",
  with a fixed, minimal configuration. Bootstrap compilers are used to
   compile local compilers.

* *local compiler* - a compiler produced by the bootstrap compiler. May have a custom configuration.
+
NOTE: the distinction between bootstrap and local compilers gives us
two distinct build protocols.
+
* *baseline environment* - the bootstrap compiler plus the initial
   build of the (unedited sources of) the runtime libs and programs
   (e.g. ocamlrun, ocamllex), plus the initial build of the stdlib.
   The legacy build system keeps all this sequestered by copying it
   into `boot/`. Everything except the bootstrap compiler, is built by
   the bootstrap compiler, so its bytecode is interpretable by the
   initial build of the runtime. I.e anything the bootstrap compiler
   builds must be interpreted by the initial build of `ocamlrun`.

* *compiler types* - notation: `(platform>platform)`

  ** platforms: `vm`, `sys` (native arch of the local machine), or a
     specific architecture name, e.g. `amd64`, `arm`.

  ** OCaml provides four compiler types:

    *** `(vm>vm)` - `ocamlc.byte`
    *** `(sys>vm)` - `ocamlc.opt`
    *** `(sys>sys)` - `ocamlopt.opt`
    *** `(vm>sys)`     - `ocamlopt.byte`


=== Build variants: parametric build targets [[parameterized_build_targets]]

The legacy build system defines a different build target for each
compiler type: `ocamlc.byte`, `ocamlc.opt`, `ocamlopt.byte`, and
`ocamlopt.opt`, and similarly for other tools. The Bazel program
treats these as build variants of a single target: `//boot/compiler`.
The variant built is controlled by configuration settings that may be
passed on the command line or saved in a `.bazelrc` file.

The runtimes also come in variants: standard, debug, and instrumented.
Each gets a separate build target in the legacy system, and has a
separate name (`ocamlrun`, `ocamlrund`, `ocamlruni` etc.). Bazel
treats these too as variants of a parameterized build target. For
example, passing `--//runtime:instr` tells Bazel to build
the instrumented variant of the runtime (i.e. `ocamlruni`)

A consequence of this approach is that different variants are not
distinguished by name; for example the debug runtime would be
`ocamlrun` built with debugging enabled, not `ocamlrund`. This should
be fine during development, where there is no point in building a
variant you do not plan to use. For distribution, this would require
that the distribution build include logic to build and rename all
required variants. Since Bazel is designed for scriptability this
should not be a problem.

Simultaneous building of multiple variants can be done, but it is not
a goal for the baseline build program.


For example:

* `runtime/libcamlrun.a`
* `runtime/libcamlrund.a`
* `runtime/libcamlruni.a`
* `runtime/libcamlrun_pic.a`
* `runtime/libcamlrun_shared.a`

NOTE: below we use `libcamlrun*.a` to indicate any of the variants.

In this case OBazl instead defines a single target,
`//runtime:camlrun`, controlled by a set of build arguments. For
example, to build a debug version of `libocamlrun.a`:

```
    $ bazel build runtime:camlrun -c dbg
```

To build an instrumented version:

```
    $ bazel build runtime:camlrun --//runtime=instr
```

NOTE: the pic and shared versions are not supported in the baseline OBazl version.

=== Bootstrapping a Bootstrap Compiler [[bootstrapp]]

==== The Bootstrapping Problem


To build a new bootstrap compiler.

In a nutshell:

1. Use the old bootstrap compiler to:
  ** build a new vm runtime lib (`libcamlrun*.a`) and link it into `boot/`
  ** build a new runtime pgm (ocamlrun) and copy it to `boot/`
  ** build a new stdlib copy the files to `boot/`
+
This gives us a `boot` directory containing the "old" compiler, runtime, and stdlib.
+
2. Then build all the other stuff, using the old runtime, compiler and stdlib
+
The new compiler is `./ocamlc`. It was emitted by the bootstrap
  compiler, so it must be run by `boot/ocamlrun`. But it emits
  bytecode for `runtime/ocamlrun`, so any program it compiles must be
  run by `runtime/ocamlrun`.
+
The distinction between `boot/ocamlrun` and `runtime/ocamlrun` is
essential, since the new boot compiler may involve changes to the
runtime. This might involve changes in the way the interpreter works,
so there would be changes in the C code in `runtime` as well as
changes in the OCaml sources of the compiler - for example, in the OCaml
code in `bytecomp` responsible for emitting bytecode.

The initial (coldstart) build of `ocamlrun` interprets bytecode
emitted by `boot/ocamlc`. If we change the runtime we do not want to
copy it into `boot/` since we need that "old" runtime to interpret
what the boot compiler emits - and we'll need that to run the new
`ocamlc`, which will be built by the old bootstrap compiler. So we
leave it in `runtime`. We then use the boot compiler to build a
new version of `ocamlc`. This version, presumably, is designed to emit
bytecode for the new runtime.  Obviously we do not want to copy it into `boot`.

 So `boot/ocamlrun` was built by the
bootstrap compiler, and interprets bytecode emitted by
+
2. Edit the code, building `coreall`to rebuild the runtime, compiler, tools, etc.
3. Once the code is good, build a new bootstrap compile by
  * 

But once we're sure our new version of `ocamlc` works, we will copy it into
`boot`, overwriting the old version.

==== Legacy bootstrapping

===== coldstart

Targets are `world` and `world.opt`.  Here we address only the former.

```
world: coldstart
	$(MAKE) all
```

```
COLDSTART:
	$(MAKE) runtime-all
	$(MAKE) -C stdlib \
	  OCAMLRUN='$$(ROOTDIR)/runtime/ocamlrun$(EXE)' \
	  CAMLC='$$(BOOT_OCAMLC) $(USE_RUNTIME_PRIMS)' all
	rm -f boot/ocamlrun$(EXE)
	cp runtime/ocamlrun$(EXE) boot/ocamlrun$(EXE)
	cd boot; rm -f $(LIBFILES)
	cd stdlib; cp $(LIBFILES) ../boot
	cd boot; $(LN) ../runtime/libcamlrun.$(A) .
```

Target `coldstart` expresses the initial step of any build (bootstrap or local):

1. Build all vm runtime variants (libocamlrun*.a, ocamlrun*.a plus a few other pieces)
2. Build all stdlib targets (using newly build runtime/ocamlrun and boot/ocamlc)
3. Delete any previously built `boot/ocamlrun`
4. Copy `runtime/ocamlrun` to `boot/ocamlrun`
5. Copy the stdlib files to `boot/`
6. link newly built vm runtime lib variant (`libcamlrun*.a`) into `boot/`

The result is a `boot` directory containing the "old" (i.e. bootstrap)
compiler `boot/ocamlc` plus newly a built vm runtime and stdlib.

The build then proceeds with `make all`, which builds the following:

1. Link `runtime/libcamlrun*.a` into  `stlib/`  (why?)
  ** NB: `stdlib/header.c` is "The launcher for bytecode executables
     (if #! is not working)", which presumably needs libocamlrun.a.
2. Build `ocamlc`
3. `ocamlyacc`
4. `ocamllex`
5. etc.

The dev can now edit, then `make coreall`. Note that target `all`
depends on `coreall`. Target `coreall` builds the "core" system - the
minimal parts needed for a functioning compiler. Since we're assuming
that the developer is working on a new bootstrap compiler (and not,
say the toplevel program `ocaml`) `make coreall` should suffice. It builds:

* vm runtime libs and programs in `runtime/`
  ** recall that `coldstart` also did this, but it then linked `runtime/libcamlrun*.a` into `boot/`
  ** also links `runtime/libcamlrun*.a` into `stdlib/`
* ocamlc
* ocamllex
* ocamltools
  ** ocamlc
  ** ocamllex
  ** compilerlibs/ocamlmiddleend.cma
  ** target `all` in `tools/Makefile`: ocamldep, ocamlprof, ocamlcp, ocamloptp,
     ocamlmklib, ocamlmktop, ocamlcmt, dumpobj, ocamlobjinfo, primreq,
     stripdebug, cmpbyt
* the stdlib - note that this was also built by target `coldstart`

The remaining targets built by `make all` are not essential to working with the compiler:

* `ocaml` - toplevel (repl)
* otherlibraries: dynlink, str, systhreads, unix, runtime_events (in `otherlibs/`)
* othertools: target `othertools` in `tools/Makefile`,  builds `ocamlmktop_init.cmo`, ocamltex
* manpages

Once everything is hunky-dory the bootstrap
target will build the new bootstrap compiler.

===== The bootstrap step


```
bootstrap: cobaseline
# utils/config.ml must be restored to config.status's configuration
# lex/ocamllex$(EXE) was stripped in order to compare it
	rm -f utils/config.ml lex/ocamllex$(EXE)
	$(MAKE) all
```

Target `cobaseline` is the "Core bootstrapping cycle". Bootstrapping
here involves the notion of "promoting" (i.e. copying) newly built
stuff into the `boot/` subdir, and recursively (kinda) using the
compiler to build itself until it reaches a fixed point (where the
build output is equal to its input).

First step of cobaseline is to "promote" the new compiler and runtime -
copy (not link) them into `boot`, overwriting the original `ocamlc` (and
`ocamllex`). It also copies stdlib files into `boot`. (Why?)

Then it rebuilds ocamlc, ocamllex, ocamltools, using the newly
installed boot compiler, and using the "fixed" config.ml file. Then
the stdlib is rebuilt with the new compiler and runtime, and these new
new versions are promoted again. Then the whole shmear (target core)
is rebuilt.

Note that `bootstrap` depends on `cobaseline`, then runs `make all`, and
target `all` depends on `coreall`.

What's the difference between `cobaseline` and `coreall`? The former
makes target `partialclean`, which deletes a bunch of stuff, then
rebuilds things and "promotes" them. Both build `ocamlc`, `ocamllex`,
and `ocamltools`, but `cobaseline` does this with flag
`IN_COREBOOT_CYCLE` enabled. They also both build the stdlib, but
`cobaseline` does this using `runtime/ocamlrun`, whereas `coreall` does
it using `boot/ocamlrun`. Why? Remember that the `coldstart` target
built `runtime/ocamlrun` and then linked it into `boot/`. But
`bootstrap` then (by running `make all`) rebuilds `runtime/ocamlrun`
_without_ copying it into `boot`.

(IOW: `boot/ocamlrun` was built with the old bootstrap compiler;
`runtime/ocamlrun` is built by the new bootstrap compiler?)

(Only `coldstart` copies `runtime/ocamlrun` into `boot/ocamlrun`)

Note that target `bootstrap`, like target `world`, runs `$(MAKE) all`.
But it depends on `cobaseline` instead of `coldstart`. The former is
responsible for "promoting" stuff

IMPORTANT: the result of target cobaseline is a new bootstrap compiler,
not a local compiler.

in the root Makefile:

```
cobaseline:
# Promote the new compiler but keep the old runtime
# This compiler runs on boot/ocamlrun and produces bytecode for
# runtime/ocamlrun
	$(MAKE) promote-cross

# Rebuild ocamlc and ocamllex (run on runtime/ocamlrun)
# utils/config.ml will have the fixed bootstrap configuration
	$(MAKE) partialclean
	$(MAKE) IN_COREBOOT_CYCLE=true ocamlc ocamllex ocamltools  # almost same as coreall: actions

	$(MAKE) library-cross   # Rebuild the library (using runtime/ocamlrun ./ocamlc)

        # Promote the new compiler and the new runtime (??? runtime only?)
	$(MAKE) OCAMLRUN=runtime/ocamlrun$(EXE) promote

# Rebuild the core system
# utils/config.ml must still have the fixed bootstrap configuration
	$(MAKE) partialclean
	$(MAKE) IN_COREBOOT_CYCLE=true core
# Check if fixpoint reached
	$(MAKE) compare
```

NB: target core depends on coldstart, then runs coreall


```
promote-cross: promote-common
# NOTE: promote-common just repeats some of what target coldstart did
PROMOTE ?= cp
promote-common:
	$(PROMOTE) ocamlc$(EXE) boot/ocamlc
	$(PROMOTE) lex/ocamllex$(EXE) boot/ocamllex
	cd stdlib; cp $(LIBFILES) ../boot
```

```
# NB: library-cross: is same as library:, except the latter has
# OCAMLRUN = boot/ocamlrun, which is the ocamlrun copied to boot by
# target coldstart.  Why?

library-cross:
	$(MAKE) -C stdlib OCAMLRUN=../runtime/ocamlrun$(EXE) all
```

```
promote: PROMOTE = $(OCAMLRUN) tools/stripdebug
promote: promote-common
	rm -f boot/ocamlrun$(EXE)
	cp runtime/ocamlrun$(EXE) boot/ocamlrun$(EXE)
```

```
\## remove generated files:
partialclean::
	rm -f ocamlopt$(EXE)
partialclean::
	rm -f ocaml$(EXE)
partialclean::
	rm -f parsing/lexer.ml
partialclean::
	rm -f utils/config.ml \
	      utils/config_main.ml utils/config_main.mli \
	      utils/config_boot.ml utils/config_boot.mli \
        utils/domainstate.ml utils/domainstate.mli
etc.
```

```
compare:
# The core system has to be rebuilt after bootstrap anyway, so strip ocamlc
# and ocamllex, which means the artefacts should be identical.
```

==== Bootstrapping under OBazl

With Bazel we can dispense with the business of copying and linking
files into the `boot` subdirectory.

All we need do is get the dependency structure right, and things will
always be built in the correct order.

VM builds:

In general: all (OCaml) build targets depend on a runtime (VM) and a
compiler that runs on it (i.e. a vm>vm compiler).

The stdlib build depends only on the runtime and compiler. Other
builds depend on the stdlib as well as the runtime and compiler.

The first thing built after the runtime and stdlib is a new `ocamlc` compiler.


`utils/config.ml` - special role. Dynamically created from either
`confg_boot.ml` or `config_main.ml`, depending on flag
`IN_COREBOOT_CYCLE`.
