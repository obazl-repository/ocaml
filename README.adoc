= OCamlCC:  Bazel-enabled OCaml toolchain (PoC, alpha)
:toc: auto
:toclevels: 3

See the link:https://github.com/ocaml/ocaml[upstream repository] for the original OCaml README.

Latest doc changes: 01/06/2023

== News (01/06/2023)

This version includes many major changes.  See <<overview>> for details.

== Quickstart

1. Install Bazel.  Recommendation: link:https://github.com/bazelbuild/bazelisk[Bazelisk]

2. Clone link:https://github.com/obazl-repository/ocaml[this repo].

3. `cd` into the root directory of the cloned repo and run configure: `$ ./configure`

4. Build some compilers:

  $ bazel build bin:ocamlc.byte
  $ bazel build bin:ocamlopt.opt

5. Build some tools:

  $ bazel build tools:ocamldep.byte
  $ bazel build tools:ocamlobjinfo.opt

5. Run some of the queries demonstrated in
link:bzl/docs/queries.adoc[queries] to see what build targets are
available.

6. Build and store the baseline compilers (built using `boot/ocamlc`
and the current source code state), so they can be used to rebuild the
compilers after source code changes:

    $ bazel run boot:coldstart

7. After running coldstart, edit some code and run some tests:

    $ bazel test testsuite/tests/basic:Boxedints_test   ## four tests, one for each compiler
    $ bazel test testsuite/tests/basic:Boxedints_vv_test   ## just the ocamlc.byte test
    $ bazel test testsuite/tests/basic:tests --test_tag_filters=vv ## all ocamlc.byte tests in pkg
+
Bazel has very strong test magic; see link:bzl/docs/testing.adoc[testing] for details.

8.  Take a look at the docs.  Start with link:bzl/docs/terminology[symbols & terminology]

To build debug or instrumented variants add `--//runtime:DEBUG`,
`--//runtime:CAML_INSTR`. See link:bzl/docs/debugging.adoc[debugging]
for more info.

The build code for using alternate CC toolchains and cross-compiling
has not yet been updated.


== Overview

This fork of the OCaml compiler toolset repository contains
Proof-of-Concept build programs written in Bazel. The code that builds
the tools and compilers is identical to the upstream code; however
some of the source code related to configuration has been reorganized.
The changes affect the preprocessing used to generate source code; it
does not change the source code itself.

The Bazel ruleset - which we may call `rules_ocamlcc` - is a
stripped-down, minimal version of the standard
link:https://github.com/obazl/rules_ocaml[rules_ocaml] ruleset. It
includes only the functionality required to build the compiler. This
means it contains no direct support for PPX processing or for
generalized namespaces (automatic renaming of subcomponents,
generation of resolver module), for example. Furthermore, since the
ruleset is heavily customized for the sole purpose of building the
OCaml compilers and tools, it is included in this repository and is
not intended for use as a free-standing ruleset.

More detailed documentation is in link:bzl/docs[bzl/docs].

Why use a minimal ruleset? Several reasons. Bootstrapping requires
some special support that is never needed for ordinary OCaml builds,
so we do not want to add that overhead to the standard ruleset. The
bootstrap ruleset is easy to understand and modify, so it serves as a
useful intro to the standard OBazl ruleset.

The build structure of the compilers is actually fairly
straightforward, in most places. It uses only a few namespaces (what
Dune calls a "wrapped" library), most prominently the Standard Library
(`Stdlib`), whose resolver (or "wrapper") module is hand-coded. The
bootstrapping process is a little more complicated, but
understandable. The most complicated part is probably the
preprocessing; but even the more complicated bits of preprocessing are
handled fairly easily by standard Bazel facilities. It involves C
interfacing. All of this makes this a useful starting point for people
interested in learning how to build OCaml software using Obazl.

Highlights:

Compiler build targets:: Previous versions defined a single
parameterized build target for the compilers: `//bin:ocamlcc
--config=ocamlc.byte`. This proved to be error-prone and difficult to
debug, so it has been replaced with specialized targets, e.g.
`//bin:ocamlc.byte`, `//bin:ocamlopt.byte`, etc. Targets are defined
for the standard "Big Four" compilers, profiling versions of same, and
flambda-enabled variants.

Build protocols & stacks:: Compiler build targets are implemented by
(possibly recursive) "build stacks", whose structure depends on the
link:bzl/docs/build_protocols.adoc[build protocol] in effect. For example, the build stack for build `ocamlc.byte` under the `std` protocol is:
+
    boot/ocamlc > ocamlc.byte
+
Under the `boot` protocol:
+
    boot/ocamlc > ocamlc.byte > ocamlc.byte
+
Different build protocols are used for different purposes (e.g.
testing v. deployment); defining them is not difficult, so if the
current configurations prove to be unsatisfactory they can be changed
relatively easily.

Archiveless builds:: Archive files (`.cma/.cmxa`) are for
distribution; for internal use they are unecesssary and wasteful.
Archiving of the libraries used in the (development) builds (i.e.
stdlib, ocamlcommon, etc.) is controlled by a boolean configuration
variable. By default it is false, so the libraries are not packaged
into archive files; this can be changed globally by passing a command-line
flag. See link:bzl/docs/libraries.adoc[libraries & archives] for more
information.

Default: `-nopervasives`:: By default the build rules always use
`-nopervasives`. This requires that otherwise implicit dependencies
(`stdlib.cmx?a`, `std_exit.cm[o,x]`) be explicitly listed on the
command line, along with `-open stdlib`.

Fine-grained dependencies:: All dependencies are expressed as module
(or signature) dependencies, rather than archive dependencies. For
example, `asmcomp:Asmgen` depends on three `Stdlib` submodules. They
rather than the (archived) library are listed as dependencies. Along
with archiveless builds and `-nopervasives` , this means that changing
a `Stdlib` submodule will _not_ force a rebuild of a stdlib archive
and thus anything that depends on it. Only targets that depend
directly or indirectly on the changed code will be rebuilt.

Dependency types:: The Bazel rules also enforce a rudimentary type
discipline on dependencies. Signatures may only depend on signatures;
modules may depend on signatures, but such dependencies must be listed
in the `sig_deps` attribute.
+
Dependencies on `stdlib` submodules must be listed in attribute
`stdlib_deps`; others are listed in `deps`. For module rules (e.g.
`compiler_module`), only module dependencies are allowed in attributes
`deps` and `stdlib_deps`; modules that depend on signatures with no
corresponding structure file must list them separately in the
`sig_deps` attribute. For signature rules, by contrast (e.g.
`compiler_signature`), only signature dependencies are allowed.
+
This forces a separation between module and signature dependencies,
and allows Bazel to catch violations at analysis time.

CC Toolchain Integration:: The OCaml compilers are configured with
command strings they use to drive the C compiler, assembler, and
linker. The legacy system uses the `.configure` script to set these
strings. This introduces a risk, since there is no guarantee that the
C toolchain detected and used by `.configure` will be the one seen at
runtime. The Bazel code sets these configurations at build-time rather
than configure-time; it derives them from the selected Bazel
toolchain. This guarantees that the correct C toolchain will be used
as runtime (that is, when the compilers are run under Bazel's
control). See link:bzl/docs/ocaml_cc_config.adoc[ocamlcc config] for
more info.

Testing support:: The legacy build system uses a custom test tool,
`ocamltest`, that orchestrates a variety of tasks that are usually
handled by a build system and/or testing framework. Under Bazel it is
not needed, so it is completely replaced by a few customized Bazel
test rules. The tests in `testsuite/tests` are completely under the
control of Bazel
+
WARNING: Only of a subset of the tests (174 of them, to be exact) have
been converted. See link:bzl/docs/testing.adoc[testing] for more
information.

Platform support:: Tested on MacOS and Linux (Ubuntu)

link:https://obazl.github.io/docs_obazl/[The OBazl Toolsuite] - outdated but still useful.


== Goals

The original goals were modest: just build the compilers, mostly. That
went so well that more ambitious goals are in order.

=== Compilers

Produce all compilers, in all variants:

* The Big Four: `ocamlc.byte`, `ocamlc.opt`, `ocamlopt.byte`, `ocamlopt.opt`.
* Flambda compilers: `ocamloptx.byte`, `ocamloptx.opt`, `ocamlc.optx`, `ocamlopt.optx`, `ocamloptx.otpx`.
* Profiling compilers: `ocamlcp.byte`, `ocamloptp.byte`, `ocamloptp.byte`, `ocamloptp.opt`
* Debug builds
* Instrumented builds

=== Fixed-point Bootstrapping

Ability to recursively build the endo-compilers (`ocamlc.byte`, ocamlopt.opt`) to reach a fixed point.

=== No hidden stuff

To the extend possible, everything in the build should be explicit. In
particular, `-nopervasives` is the default.

=== Complete, optimized configuration

Complete: support for all configuration settings supported by the legacy system

Optimized: the legacy system sets most configuration variables at
configure-time (when `./configure`` is run). A substantial portion of
those settings can and should be specifiable at build-time; they
involve data that can be derived by Bazel.

Configuration support is a Work-in-Progress; it's fairly complicated.
On the other hand, in general configuration management under Bazel is
very different (and much easier) than it is with configure/make. I
don't have detailed documentation yet, but you can find lots of notes
in link:bzl/docs[bzl/docs].

See xref:bzl/docs/configuration.adoc[Configuration] for more information.


=== Preprocessing: portability and optimization

The legacy build involves a certain amount of moderately complex
preprocessing, most of which depends on shell scripts/tools (sed, awk,
etc.) This is a portability problem; it just won't work on Windows,
and can be troublesome even in Unixworld.

The Bazel code has replaced most but not all of this by
link:https://mustache.github.io/mustache.5.html[mustache] template
processing. The engine used,
link:https://gitlab.com/jobol/mustach[mustach] (note the dropped `e`),
is written in portable C. It also uses
link:https://github.com/DaveGamble/cJSON[cJSON], a JSON library
written in portable C.

=== Ergonomics

It should be easy for developers to understand, use, and modify the Bazel system.

=== Efficiency

It should be at least as efficient _overall_ as the legacy system,
although for particular tasks the makefiles may be faster.

=== Alternate C Compilers

Support for
link:https://sr.ht/~motiejus/bazel-zig-cc/[Zig] and link:https://github.com/grailbio/bazel-toolchain[LLVM].

=== Cross-compiling

Bazel has excellent support for cross-compilation via link:https://bazel.build/extending/platforms[platforms] and link:https://bazel.build/extending/toolchains[toolchains]; for an overview see link:https://bazel.build/concepts/platforms[Building with platforms].

Goal: cross-compile non-cross-compilers. For example, to build, on an
x86 Mac, an arm Mac compiler, an x86 Linux compiler, an arm Linux compiler, etc.

Goal: cross-compile cross-compilers. For example, to build,
on an x86 Mac, a Linux x86 -> Linux arm OCaml compiler.

=== Mainainability

Eventually the code will be simplified and easy to read.

=== Persistent Workers

Bazel supports link:https://bazel.build/remote/persistent[persistent
workers] - tools that effectively run as service providers. Without
persistent workers, the compiler must startup, run, and shutdown once
for each file it compiles. With a persistent worker, the compiler
starts up once and stays loaded; clients then pass it source files to
compile.

Implementing OCaml compilers as persistent workers is really a
separate project, but I list it here as a general goal anyway.


== Non-Goals

NOTE: These could turn into goals. It depends on adoption. If nobody
  wants to use Bazel to develop the compilers and tools, then there
  would be no point in enhancing it. If you _do_ use it, and you need
  this stuff, please file an issue!

* Documentation builds.

* OPAM support

* Distribution: packaging builds for distribution is not a current goal. No
point in supporting release builds unless and until the maintainers
decide they want to use Bazel in production. Such packaging logic is
generally not included in Bazel language rules, whose job is solely to
build things. Instead it is provided by separate rulesets such as:
+
** link:https://github.com/bazelbuild/rules_pkg[rules_pkg]
** link:https://github.com/vaticle/bazel-distribution[bazel-distribution]

== Status  (01/06/2023)

=== Legacy versions

==== branch: bazel/4.14.0

All the compilers and tools build. The bazel code on this branch is
very different from the latest version on `bazel/trunk`, and will not
be upgraded.

=== bazel/trunk, bazel/dev

The main branch of this repository is `bazel/trunk`; it tracks the
`trunk` branch of the upstream repository (and so may be outdated at
any given point in time).

The `bazel/dev` is where development happens.


==== Configuration

The Bazel build program supports command-line options to control:

* Platform-based toolchain selection. Sorry I don't have better docs
  on this - you'll have to root around in the sources and link:bzl/docs[] for more information
* Build subvariants - debug and instrumented builds are enabled via command-line flags
* Debugging profiles. Debugging configuration is rather involved,
  since the C runtimes and the OCaml tools can be debugged separately.
  Furthermore, there are two kinds of debugging: one involves building
  with `-g` and use of the debugger, and other (for C) involves
  setting preproccessor macros (typically `-DDEBUG`) whether or not
  `-g` is used. The Bazel build program affords fine-grained control
  of debug profiles - see link:bzl/docs/debugging.adoc[debugging] for details.
* Compile/link flags - by default, bootstrapping builds use flags like
  `-nostdlib`, `-use-prims`, `-principal`, etc. These are globally
  controllable. For example during development one might want to use
  `-no-principal`, or use a customize `primitives` file. These
  configurations can be set on the command line (or via `.bazelrc`).
  See link:bzl/docs/configuration.adoc[configuration] for more
  information.
* Build structure configuration. For lack of a better term. For
  example, configuration setting `--//config:sig_src` (subject to
  renaming) can be used to control whether or not `.mli` files are
  separately compiled, if the build targets are configured to use it.  For an example see target link:https://github.com/obazl-repository/ocaml/blob/1cef348aa2fd3536883169ad8b371d5c36870736/stdlib/BUILD.bazel#L2320-L2328[Stdlib.Weak].

==== Bootstrapping

The legacy makefile-based build defines multiple targets, one for each
of the Big Four compilers, and more for variants.

The original Bazel build had a single parameterized compiler target,
`//bin:ocamlcc`. Build variants were selected by passing arguments
controlling build and target platforms and some other build
parameters.

The current version is more like the makefile system, in that it has
distinct targets for each compiler (and also for each tool we have one
target for the vm version and one for the native version.) But these
targets are OCaml-ish: they are effectively interfaces on shared
implementation code.

See link:bzl/docs/build_protocols.adoc[build protocols] for more info.

==== Cross-builds

NOTE: 12/01/2022: Cross-compiling has not yet been adapted to use the new bootstrapping discipline.

Cross-compilation of the runtimes works: you can build a Linux x86_64
runtime on a MacOS x86_64 build host, for example. Cross-compilation
of the OCaml tools is currently limited to what can be produced by the
`vm>vm` bootstrap compiler, i.e. `ocamlopt.byte`, which runs on the VM
and emits native code. But support for variants of `ocamlopt.byte`
targeting different native platforms is not yet supported. Only the
variant targeting the local native platform is supported.

For more information see link:bzl/docs/cross_compilation.adoc[bzl/docs/cross_compilation.adoc]



== The OBazl Build: concepts and structure

WARNING: You must run `./configure` before running Bazel builds.

Just some notes to help the reader of the code:

=== Notation and Terminology

12/01/2022: obsolete terminology, see instead
link:bzl/docs/terminology.adoc[terminology]

* *bootstrap compiler* (aka boot compiler) - the precompiled `ocamlc`
  compiler that comes with the distribution, or one produced by the
  bootstrap build described below. A bootstrap compiler is "vanilla",
  with a fixed, minimal configuration. Bootstrap compilers are used to
   compile local compilers.

* *local compiler* - a compiler produced by the bootstrap compiler. May have a custom configuration.
+
NOTE: the distinction between bootstrap and local compilers gives us
two distinct build protocols.
+
* *baseline environment* - the bootstrap compiler plus the initial
   build of the (unedited sources of) the runtime libs and programs
   (e.g. ocamlrun, ocamllex), plus the initial build of the stdlib.
   The legacy build system keeps all this sequestered by copying it
   into `boot/`. Everything except the bootstrap compiler, is built by
   the bootstrap compiler, so its bytecode is interpretable by the
   initial build of the runtime. I.e anything the bootstrap compiler
   builds must be interpreted by the initial build of `ocamlrun`.

* *compiler types* - notation: `(platform>platform)`

  ** platforms: `vm`, `sys` (native arch of the local machine), or a
     specific architecture name, e.g. `amd64`, `arm`.

  ** OCaml provides four compiler types:

    *** `(vm>vm)` - `ocamlc.byte`
    *** `(sys>vm)` - `ocamlc.opt`
    *** `(sys>sys)` - `ocamlopt.opt`
    *** `(vm>sys)`     - `ocamlopt.byte`


=== Build variants: parametric build targets [[parameterized_build_targets]]

The legacy build system defines a different build target for each
compiler type: `ocamlc.byte`, `ocamlc.opt`, `ocamlopt.byte`, and
`ocamlopt.opt`, and similarly for other tools. The Bazel program
treats these as build variants of a single target: `//bin:ocamlcc`.
The variant built is controlled by configuration settings that may be
passed on the command line or saved in a `.bazelrc` file.

The runtimes also come in variants: standard, debug, and instrumented.
Each gets a separate build target in the legacy system, and has a
separate name (`ocamlrun`, `ocamlrund`, `ocamlruni` etc.). Bazel
treats these too as variants of a parameterized build target. For
example, passing `--//runtime:instr` tells Bazel to build
the instrumented variant of the runtime (i.e. `ocamlruni`)

A consequence of this approach is that different variants are not
distinguished by name; for example the debug runtime would be
`ocamlrun` built with debugging enabled, not `ocamlrund`. This should
be fine during development, where there is no point in building a
variant you do not plan to use. For distribution, this would require
that the distribution build include logic to build and rename all
required variants. Since Bazel is designed for scriptability this
should not be a problem.

Simultaneous building of multiple variants can be done, but it is not
a goal for the baseline build program.


For example:

* `runtime/libcamlrun.a`
* `runtime/libcamlrund.a`
* `runtime/libcamlruni.a`
* `runtime/libcamlrun_pic.a`
* `runtime/libcamlrun_shared.a`

NOTE: below we use `libcamlrun*.a` to indicate any of the variants.

In this case OBazl instead defines a single target,
`//runtime:camlrun`, controlled by a set of build arguments. For
example, to build a debug version of `libocamlrun.a`:

```
    $ bazel build runtime:camlrun --//runtime:DEBUG
```

To build an instrumented version:

```
    $ bazel build runtime:camlrun --//runtime:INSTRUMENT
```

NOTE: the current OBazl version does not provide a means of specifying
some build variations, e.g. .pic or shared.

=== Bootstrapping a Bootstrap Compiler [[bootstrapp]]

==== The Bootstrapping Problem


To build a new bootstrap compiler.

In a nutshell:

1. Use the old bootstrap compiler to:
  ** build a new vm runtime lib (`libcamlrun*.a`) and link it into `boot/`
  ** build a new runtime pgm (ocamlrun) and copy it to `boot/`
  ** build a new stdlib copy the files to `boot/`
+
This gives us a `boot` directory containing the "old" compiler, runtime, and stdlib.
+
2. Then build all the other stuff, using the old runtime, compiler and stdlib
+
The new compiler is `./ocamlc`. It was emitted by the bootstrap
  compiler, so it must be run by `boot/ocamlrun`. But it emits
  bytecode for `runtime/ocamlrun`, so any program it compiles must be
  run by `runtime/ocamlrun`.
+
The distinction between `boot/ocamlrun` and `runtime/ocamlrun` is
essential, since the new boot compiler may involve changes to the
runtime. This might involve changes in the way the interpreter works,
so there would be changes in the C code in `runtime` as well as
changes in the OCaml sources of the compiler - for example, in the OCaml
code in `bytecomp` responsible for emitting bytecode.

The initial (coldstart) build of `ocamlrun` interprets bytecode
emitted by `boot/ocamlc`. If we change the runtime we do not want to
copy it into `boot/` since we need that "old" runtime to interpret
what the boot compiler emits - and we'll need that to run the new
`ocamlc`, which will be built by the old bootstrap compiler. So we
leave it in `runtime`. We then use the boot compiler to build a
new version of `ocamlc`. This version, presumably, is designed to emit
bytecode for the new runtime.  Obviously we do not want to copy it into `boot`.

 So `boot/ocamlrun` was built by the
bootstrap compiler, and interprets bytecode emitted by
+
2. Edit the code, building `coreall`to rebuild the runtime, compiler, tools, etc.
3. Once the code is good, build a new bootstrap compile by
  * 

But once we're sure our new version of `ocamlc` works, we will copy it into
`boot`, overwriting the old version.

==== Legacy bootstrapping

===== coldstart

Targets are `world` and `world.opt`.  Here we address only the former.

```
world: coldstart
	$(MAKE) all
```

```
COLDSTART:
	$(MAKE) runtime-all
	$(MAKE) -C stdlib \
	  OCAMLRUN='$$(ROOTDIR)/runtime/ocamlrun$(EXE)' \
	  CAMLC='$$(BOOT_OCAMLC) $(USE_RUNTIME_PRIMS)' all
	rm -f boot/ocamlrun$(EXE)
	cp runtime/ocamlrun$(EXE) boot/ocamlrun$(EXE)
	cd boot; rm -f $(LIBFILES)
	cd stdlib; cp $(LIBFILES) ../boot
	cd boot; $(LN) ../runtime/libcamlrun.$(A) .
```

Target `coldstart` expresses the initial step of any build (bootstrap or local):

1. Build all vm runtime variants (libocamlrun*.a, ocamlrun*.a plus a few other pieces)
2. Build all stdlib targets (using newly build runtime/ocamlrun and boot/ocamlc)
3. Delete any previously built `boot/ocamlrun`
4. Copy `runtime/ocamlrun` to `boot/ocamlrun`
5. Copy the stdlib files to `boot/`
6. link newly built vm runtime lib variant (`libcamlrun*.a`) into `boot/`

The result is a `boot` directory containing the "old" (i.e. bootstrap)
compiler `boot/ocamlc` plus newly a built vm runtime and stdlib.

The build then proceeds with `make all`, which builds the following:

1. Link `runtime/libcamlrun*.a` into  `stlib/`  (why?)
  ** NB: `stdlib/header.c` is "The launcher for bytecode executables
     (if #! is not working)", which presumably needs libocamlrun.a.
2. Build `ocamlc`
3. `ocamlyacc`
4. `ocamllex`
5. etc.

The dev can now edit, then `make coreall`. Note that target `all`
depends on `coreall`. Target `coreall` builds the "core" system - the
minimal parts needed for a functioning compiler. Since we're assuming
that the developer is working on a new bootstrap compiler (and not,
say the toplevel program `ocaml`) `make coreall` should suffice. It builds:

* vm runtime libs and programs in `runtime/`
  ** recall that `coldstart` also did this, but it then linked `runtime/libcamlrun*.a` into `boot/`
  ** also links `runtime/libcamlrun*.a` into `stdlib/`
* ocamlc
* ocamllex
* ocamltools
  ** ocamlc
  ** ocamllex
  ** compilerlibs/ocamlmiddleend.cma
  ** target `all` in `tools/Makefile`: ocamldep, ocamlprof, ocamlcp, ocamloptp,
     ocamlmklib, ocamlmktop, ocamlcmt, dumpobj, ocamlobjinfo, primreq,
     stripdebug, cmpbyt
* the stdlib - note that this was also built by target `coldstart`

The remaining targets built by `make all` are not essential to working with the compiler:

* `ocaml` - toplevel (repl)
* otherlibraries: dynlink, str, systhreads, unix, runtime_events (in `otherlibs/`)
* othertools: target `othertools` in `tools/Makefile`,  builds `ocamlmktop_init.cmo`, ocamltex
* manpages

Once everything is hunky-dory the bootstrap
target will build the new bootstrap compiler.

===== The bootstrap step


```
bootstrap: cobaseline
# utils/config.ml must be restored to config.status's configuration
# lex/ocamllex$(EXE) was stripped in order to compare it
	rm -f utils/config.ml lex/ocamllex$(EXE)
	$(MAKE) all
```

Target `cobaseline` is the "Core bootstrapping cycle". Bootstrapping
here involves the notion of "promoting" (i.e. copying) newly built
stuff into the `boot/` subdir, and recursively (kinda) using the
compiler to build itself until it reaches a fixed point (where the
build output is equal to its input).

First step of cobaseline is to "promote" the new compiler and runtime -
copy (not link) them into `boot`, overwriting the original `ocamlc` (and
`ocamllex`). It also copies stdlib files into `boot`. (Why?)

Then it rebuilds ocamlc, ocamllex, ocamltools, using the newly
installed boot compiler, and using the "fixed" config.ml file. Then
the stdlib is rebuilt with the new compiler and runtime, and these new
new versions are promoted again. Then the whole shmear (target core)
is rebuilt.

Note that `bootstrap` depends on `cobaseline`, then runs `make all`, and
target `all` depends on `coreall`.

What's the difference between `cobaseline` and `coreall`? The former
makes target `partialclean`, which deletes a bunch of stuff, then
rebuilds things and "promotes" them. Both build `ocamlc`, `ocamllex`,
and `ocamltools`, but `cobaseline` does this with flag
`IN_COREBOOT_CYCLE` enabled. They also both build the stdlib, but
`cobaseline` does this using `runtime/ocamlrun`, whereas `coreall` does
it using `boot/ocamlrun`. Why? Remember that the `coldstart` target
built `runtime/ocamlrun` and then linked it into `boot/`. But
`bootstrap` then (by running `make all`) rebuilds `runtime/ocamlrun`
_without_ copying it into `boot`.

(IOW: `boot/ocamlrun` was built with the old bootstrap compiler;
`runtime/ocamlrun` is built by the new bootstrap compiler?)

(Only `coldstart` copies `runtime/ocamlrun` into `boot/ocamlrun`)

Note that target `bootstrap`, like target `world`, runs `$(MAKE) all`.
But it depends on `cobaseline` instead of `coldstart`. The former is
responsible for "promoting" stuff

IMPORTANT: the result of target cobaseline is a new bootstrap compiler,
not a local compiler.

in the root Makefile:

```
cobaseline:
# Promote the new compiler but keep the old runtime
# This compiler runs on boot/ocamlrun and produces bytecode for
# runtime/ocamlrun
	$(MAKE) promote-cross

# Rebuild ocamlc and ocamllex (run on runtime/ocamlrun)
# utils/config.ml will have the fixed bootstrap configuration
	$(MAKE) partialclean
	$(MAKE) IN_COREBOOT_CYCLE=true ocamlc ocamllex ocamltools  # almost same as coreall: actions

	$(MAKE) library-cross   # Rebuild the library (using runtime/ocamlrun ./ocamlc)

        # Promote the new compiler and the new runtime (??? runtime only?)
	$(MAKE) OCAMLRUN=runtime/ocamlrun$(EXE) promote

# Rebuild the core system
# utils/config.ml must still have the fixed bootstrap configuration
	$(MAKE) partialclean
	$(MAKE) IN_COREBOOT_CYCLE=true core
# Check if fixpoint reached
	$(MAKE) compare
```

NB: target core depends on coldstart, then runs coreall


```
promote-cross: promote-common
# NOTE: promote-common just repeats some of what target coldstart did
PROMOTE ?= cp
promote-common:
	$(PROMOTE) ocamlc$(EXE) boot/ocamlc
	$(PROMOTE) lex/ocamllex$(EXE) boot/ocamllex
	cd stdlib; cp $(LIBFILES) ../boot
```

```
# NB: library-cross: is same as library:, except the latter has
# OCAMLRUN = boot/ocamlrun, which is the ocamlrun copied to boot by
# target coldstart.  Why?

library-cross:
	$(MAKE) -C stdlib OCAMLRUN=../runtime/ocamlrun$(EXE) all
```

```
promote: PROMOTE = $(OCAMLRUN) tools/stripdebug
promote: promote-common
	rm -f boot/ocamlrun$(EXE)
	cp runtime/ocamlrun$(EXE) boot/ocamlrun$(EXE)
```

```
\## remove generated files:
partialclean::
	rm -f ocamlopt$(EXE)
partialclean::
	rm -f ocaml$(EXE)
partialclean::
	rm -f parsing/lexer.ml
partialclean::
	rm -f utils/config.ml \
	      utils/config_main.ml utils/config_main.mli \
	      utils/config_boot.ml utils/config_boot.mli \
        utils/domainstate.ml utils/domainstate.mli
etc.
```

```
compare:
# The core system has to be rebuilt after bootstrap anyway, so strip ocamlc
# and ocamllex, which means the artefacts should be identical.
```

==== Bootstrapping under OBazl

With Bazel we can dispense with the business of copying and linking
files into the `boot` subdirectory.

All we need do is get the dependency structure right, and things will
always be built in the correct order.

VM builds:

In general: all (OCaml) build targets depend on a runtime (VM) and a
compiler that runs on it (i.e. a vm>vm compiler).

The stdlib build depends only on the runtime and compiler. Other
builds depend on the stdlib as well as the runtime and compiler.

The first thing built after the runtime and stdlib is a new `ocamlc` compiler.


`utils/config.ml` - special role. Dynamically created from either
`confg_boot.ml` or `config_main.ml`, depending on flag
`IN_COREBOOT_CYCLE`.

WARNING: the config stuff is now in link:config[//config]
