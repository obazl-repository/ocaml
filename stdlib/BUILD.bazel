load("//bzl:rules.bzl",
     "boot_archive",
     "boot_camlheaders",
     "boot_library",
     "boot_module",
     "boot_signature")

load(":BUILD_RULES.bzl",
     "stdlib_boot_module", "stdlib_module",
     "stdlib_boot_signature", "stdlib_signature")

load(":BUILD.bzl", "STDLIB_MANIFEST")

package(default_visibility = ["//visibility:public"])

exports_files(["expand_module_aliases.awk", "weak.ml", "weak.mli"])

MODULE_OPTS = []
SIG_OPTS    = []

NO_CMI_FILE = "-49"

LABEL_OPTS = ["-nolabels"]

# Std_exit is at the bottom of this file.


## NB: we do not need to define an ocaml_ns_resolver (or rather
## bootstrap_ns_resolver), since Stdlib serves as our ns_resolver
## module. Each submodule includes itself by attribution ns=":Stdlib".
## This library target just aggregates the resolver and submodules.
## They can be listed in any order.

# NB: boot_library will not work. The compilers expect to find
# stdlib.cm[x]a - this is hardcoded.

# stdlib_archive(
boot_archive(
    name       = "stdlib",
    ## makefiles pass -use-prims. does that make sense, for an archive?
    manifest   = STDLIB_MANIFEST,
    data = ["//runtime:asmrun"],
    visibility = ["//visibility:public"],
)

## We use several different rules:

# stdlib_boot_[module|signature] - for Stdlib, Std_exit and
# CamlinternalFormatBasics only. These are not in the ns but the
# submodules of the ns depend on them; they "bootstrap" the ns.

# (I.e. 'stdlib_boot_' corresponds to 'Camlinternal')

# stdlib_[module|signature] for the submodules of the Stdlib namespace.

# That leaves five modules essential that are not in the Stdlib
# namespace, but that depend on submodules, and are depended on by
# submodules. These are the Camlinternal* modules. The use the
# stdlib_boot_* rules but pass '-open Stdlib' explicitly.

##################################################################
##############  Main Resolver Module: Stdlib  ####################
# The resolver is not itself a member of the namespace; it does not
# depend on itself! So it can build independently of stdlib.cma.

#stdlib_resolver(
stdlib_boot_module(
    name   = "Stdlib",
    struct = "_build/stdlib.ml",
    sig    = "Stdlib_cmi", # doesn't work with stdlib.mli
    # use_prims = True,
    opts = [
        "-nopervasives",
        "-no-alias-deps",
    ],
    warnings = [NO_CMI_FILE],
    deps = [":CamlinternalFormatBasics",],
    # pp_deps = ["//stdlib:expand_module_aliases.awk"],
)

# WARNING: if we run this as a separate task (instead of passing the
# cmd to the compiler via -pp) we must write to a subdir, since the
# input filename is the same as the output filename. Ditto for
# stdlib.mli.

genrule(
    name = "stdlib_ml_awk",
    outs = ["_build/stdlib.ml"], ## FIXME
    srcs = ["stdlib.ml", "//stdlib:expand_module_aliases.awk"],
    cmd_bash  = " ".join([
        "awk -f $(location //stdlib:expand_module_aliases.awk) $(location :stdlib.ml)",
        "> $@"
    ]),
)

stdlib_boot_signature(
    name = "Stdlib_cmi",
    src  = "_build/stdlib.mli",
    opts = SIG_OPTS + [
        "-nopervasives",
        "-no-alias-deps",
    ],
    warnings = [NO_CMI_FILE],
    deps   = [
        ":CamlinternalFormatBasics", #_cmi",
    ],
)

# bootstrap_preprocess(
#     name = "stdlib_ml_awk",
#     outs = ["stdlib.ml"],
#     srcs = ["stdlib.ml", "//stdlib:expand_module_aliases.awk"],
#     cmd_bash  = " ".join([
#         "awk -f $(location //stdlib:expand_module_aliases.awk) $(location :stdlib.ml)",
#         "> $@"
#     ]),
# )

genrule(
    name = "stdlib_mli_awk",
    outs = ["_build/stdlib.mli"],
    srcs = ["stdlib.mli", "//stdlib:expand_module_aliases.awk"],
    cmd_bash  = " ".join([
        "awk -f $(location //stdlib:expand_module_aliases.awk) $(location :stdlib.mli)",
        "> $@"
    ]),
)

################################################################
############  Non-namespaced Components of Stdlib ##############

## camlinternal* modules:
# All are in the Stdlib archive but none are in the Stdlib ns.
# Atomic and FormatBasic are deps of the nslib but do not depend on
# any other modules.
# The other camlinternal* are submodules but they are not renamed.
# They depend on other subcomponents, but since they are not renamed
# such deps must not be listed; instead just list :Stdlib.

stdlib_boot_module(
    name   = "CamlinternalFormatBasics",
    struct = "camlinternalFormatBasics.ml",
    sig    = "CamlinternalFormatBasics_cmi",
    opts   = ["-nopervasives"]
    # sig    = select({
    #     "//config:sig_src?": "camlinternalFormatBasics.mli",
    #     "//conditions:default": "CamlinternalFormatBasics_cmi",
    # }),
)

stdlib_boot_signature(
    name = "CamlinternalFormatBasics_cmi",
    src  = "camlinternalFormatBasics.mli",
    opts   = ["-nopervasives"]
 )


stdlib_boot_module(
    name   = "CamlinternalFormat",
    struct = "camlinternalFormat.ml",
    sig    = "CamlinternalFormat_cmi",
    # sig    = select({
    #     "//config:sig_src?"   : "camlinternalformat.mli",
    #     "//conditions:default": "CamlinternalFormat_cmi"
    # }),
    opts = ["-open", "Stdlib"],
    warnings = ["fragile-match"],
    deps   = [
        ":CamlinternalFormatBasics",
        ":Stdlib.Buffer", ## (Stdlib Buffer)
        ":Stdlib.Bytes", ## (Stdlib Bytes)
        ":Stdlib.Char", ## (Stdlib Char)
        ":Stdlib.Int", ## (Stdlib Int)
        ":Stdlib.Sys", ## (Stdlib Sys)
        ":Stdlib.String", ## (Stdlib String)
    ],
)

stdlib_boot_signature(
    name = "CamlinternalFormat_cmi",
    src  = "camlinternalFormat.mli",
    opts = ["-open", "Stdlib"],
    warnings = ["fragile-match"],
    deps   = [
        ":CamlinternalFormatBasics",

        # Depends on Buffer, but we need to go through the ns Stdlib.
        # The problem is we cannot express a dependency on an ns
        # submodule using a namespaced symbol like ":Stdlib.Buffer";
        # we can only depend on build targets.

        # Depending directly on :Buffer cause it (and its deps) to be
        # built w/o namespacing, so we'll have the same stuff built
        # with and without namespacing. Which is bad.
        ":Stdlib.Buffer_cmi",

        # :Stdlib (the resolver) itself is not renamed, but it
        # contains the alias for Buffer => Stdlib__Buffer. We get:
        ## "Error: The module Buffer is an alias for module
        ##  Stdlib__Buffer, which is missing."
        # ":Stdlib",

        # That's because the Stdlib (resolver) module, unlike the NS
        # lib, does not depend on the submodules, because it is
        # compiled with '-no-alias-deps'. So they do not get built
        # unless the NS target is built. But we cannot depend on
        # :ocaml-stdlib on pain of circularity.

        # What we need is to make CamlinternalFormat a component but
        # not a submodule of the namespace, without renaming. Then we
        # could list sibling deps directly.
    ],
)

stdlib_boot_module(
    name   = "CamlinternalLazy",
    struct = "camlinternalLazy.ml",
    sig    = select({
        "//config:sig_src?": "camlinternalLazy.mli",
        "//conditions:default": "CamlinternalLazy_cmi"
    }),
    opts = select({
        # "//platform/target:sys?": ["-afl-inst-ratio", "0"],
        "//conditions:default": []
    }),
    deps   = [
        ":Stdlib.Obj",
        ":Stdlib.Sys",
    ],
)

stdlib_boot_signature(
    name = "CamlinternalLazy_cmi",
    src  = "camlinternalLazy.mli",
    deps = [":Stdlib_cmi"]
)

stdlib_boot_module(
    name   = "CamlinternalMod",
    struct = "camlinternalMod.ml",
    sig    = "CamlinternalMod_cmi",
    opts = ["-open", "Stdlib"],
    deps   = [
        ":CamlinternalOO", ## (CamlinternalOO)
        ":CamlinternalLazy", ## (CamlinternalOO)
        ":Stdlib.Obj", ## (Stdlib Obj)
        ":Stdlib.Lazy", ## (Stdlib Lazy)
        ":Stdlib.Array", ## (Stdlib Array)
    ],
)

stdlib_boot_signature(
    name = "CamlinternalMod_cmi",
    src  = "camlinternalMod.mli",
    opts = ["-open", "Stdlib"],
    deps   = [
        ":Stdlib.Obj",
    ],
)

stdlib_boot_module(
    name   = "CamlinternalOO",
    struct = "camlinternalOO.ml",
    sig    = "CamlinternalOO_cmi",
    opts = ["-open", "Stdlib"],
    # + select({
    #     # "//platform/target:vm?": [],
    #     # "//platform/target:sys?": [
    #     #     "-inline", "0",
    #     #     "-afl-inst-ratio", "0"
    #     # ],
    #     "//conditions:default": []
    # }),
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Obj",
        ":Stdlib.List",
        ":Stdlib.Char",
        ":Stdlib.Array",
        ":Stdlib.Map"
    ],
)

stdlib_boot_signature(
    name = "CamlinternalOO_cmi",
    src  = "camlinternalOO.mli",
    opts = ["-open", "Stdlib"],
    deps   = [":Stdlib.Obj"]
)

#########################################################
################  Namespaced Submodules  ################

stdlib_module(
    name   = "Stdlib.Arg",
    struct = "arg.ml",
    sig    = "Stdlib.Arg_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Printf",
        ":Stdlib.List",
        ":Stdlib.Int",
        ":Stdlib.Buffer",
        ":Stdlib.Array",
    ],
)

stdlib_signature(
    name = "Stdlib.Arg_cmi",
    src  = "arg.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Printf",
        ":Stdlib.List",
        ":Stdlib.Int",
        ":Stdlib.Buffer",
        ":Stdlib.Array",
    ],
)

stdlib_module(
    name   = "Stdlib.Array",
    struct = "array.ml",
    sig    = "Stdlib.Array_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
)

stdlib_signature(
    name = "Stdlib.Array_cmi",
    src  = "array.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
)

stdlib_module(
    name   = "Stdlib.ArrayLabels",
    struct = "arrayLabels.ml",
    sig    = "Stdlib.ArrayLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    deps   = [
        ":Stdlib.Array"
    ],
)

## WARNING: output name same as input name, so write to tmp dir:
genrule(
    name = "array_labels_mli_awk",
    outs = ["_build/arrayLabels.mli"],
    srcs = ["arrayLabels.mli", "//stdlib:expand_module_aliases.awk"],
    cmd_bash  = " ".join([
        "awk -f $(location //stdlib:expand_module_aliases.awk)",
        "$(location :arrayLabels.mli)",
        "> $@"
    ]),
)

stdlib_signature(
    name = "Stdlib.ArrayLabels_cmi",
    src  = "_build/arrayLabels.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
)

stdlib_module(
    struct = "atomic.ml",
    name   = "Stdlib.Atomic",
    sig    = "Stdlib.Atomic_cmi",
    opts = MODULE_OPTS,
    deps   = [],
)

stdlib_signature(
    name = "Stdlib.Atomic_cmi",
    src  = "atomic.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.Bigarray",
    struct = "bigarray.ml",
    sig    = "Stdlib.Bigarray_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.Complex",
        ":Stdlib.Array",
        ## (Genarray)
        ## (Array3)
        ## (Array2)
        ## (Array1)
        ## (Array0)
    ],
)

stdlib_signature(
    name = "Stdlib.Bigarray_cmi",
    src  = "bigarray.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Complex", ## (Stdlib Complex)
        ## (Genarray)
        ## (Array3)
        ## (Array2)
        ## (Array1)
        ## (Array0)
    ],
)

stdlib_module(
    name   = "Stdlib.Bool",
    struct = "bool.ml",
    sig    = "Stdlib.Bool_cmi",
    opts = MODULE_OPTS,
)

stdlib_signature(
    name = "Stdlib.Bool_cmi",
    src  = "bool.mli",
    opts = SIG_OPTS,
)

stdlib_module(
    name   = "Stdlib.Buffer",
    struct = "buffer.ml",
    sig    = "Stdlib.Buffer_cmi",
    opts = MODULE_OPTS,
    # + select({
    #     mode:native :-inline 3
    #     mode:bc: ["-w" "+A"]
    # }),
    deps   = [
        ":Stdlib.Uchar",
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Seq",
        ":Stdlib.Char",
        ":Stdlib.Bytes",
    ],
)

stdlib_signature(
    name = "Stdlib.Buffer_cmi",
    src  = "buffer.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Uchar",
        ":Stdlib.Seq",
    ],
)

stdlib_module(
    name   = "Stdlib.Bytes",
    struct = "bytes.ml",
    sig    = "Stdlib.Bytes_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Char",
        ":Stdlib.Int",
        ":Stdlib.Seq",
        ":Stdlib.Sys",
        ":Stdlib.Uchar",
    ],
)

stdlib_signature(
    name = "Stdlib.Bytes_cmi",
    src  = "bytes.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Int_cmi",
        ":Stdlib.Seq_cmi",
        ":Stdlib.Uchar_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.BytesLabels",
    struct = "bytesLabels.ml",
    sig    = "Stdlib.BytesLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    deps   = [
        ":Stdlib.Bytes",
    ],
)

stdlib_signature(
    name = "Stdlib.BytesLabels_cmi",
    src  = "bytesLabels.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq_cmi",
        ":Stdlib.Uchar_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.Callback",
    struct = "callback.ml",
    sig    = "Stdlib.Callback_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Obj"
    ],
)

stdlib_signature(
    name = "Stdlib.Callback_cmi",
    src  = "callback.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.In_channel"
    ],
)

stdlib_module(
    name   = "Stdlib.Char",
    struct = "char.ml",
    sig    = "Stdlib.Char_cmi",
    opts = MODULE_OPTS,
    deps   = [":Stdlib"],
)

stdlib_signature(
    name = "Stdlib.Char_cmi",
    src  = "char.mli",
    opts = SIG_OPTS,
)

stdlib_module(
    name   = "Stdlib.Complex",
    struct = "complex.ml",
    sig    = "Stdlib.Complex_cmi",
    opts = MODULE_OPTS,
    deps   = ["Stdlib.Float"],
)

stdlib_signature(
    name = "Stdlib.Complex_cmi",
    src  = "complex.mli",
    opts = SIG_OPTS,
    deps   = [ ],
)

stdlib_module(
    name   = "Stdlib.Condition",
    struct = "condition.ml",
    sig    = "Stdlib.Condition_cmi",
    opts = MODULE_OPTS,
    deps   = [":Stdlib.Mutex"],
)

stdlib_signature(
    name = "Stdlib.Condition_cmi",
    src  = "condition.mli",
    opts = SIG_OPTS,
    deps   = [":Stdlib.Mutex_cmi"],
)

stdlib_module(
    name   = "Stdlib.Digest",
    struct = "digest.ml",
    sig    = "Stdlib.Digest_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.String",
        ":Stdlib.Char",
        ":Stdlib.Bytes",
    ],
)

stdlib_signature(
    name = "Stdlib.Digest_cmi",
    src  = "digest.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.In_channel_cmi"
        # ":Stdlib"
    ],
)

stdlib_module(
    name   = "Stdlib.Domain",
    struct = "domain.ml",
    sig    = "Stdlib.Domain_cmi",
    opts = MODULE_OPTS,
    deps   = [
        "Stdlib",
        "Stdlib.Array",
        "Stdlib.Atomic",
        "Stdlib.Condition",
        "Stdlib.List",
        "Stdlib.Mutex",
        "Stdlib.Obj",
        "Stdlib.Sys",
    ],
)

stdlib_signature(
    name = "Stdlib.Domain_cmi",
    src  = "domain.mli",
    opts = SIG_OPTS,
    deps   = [ ],
)

stdlib_module(
    name   = "Stdlib.Effect",
    struct = "effect.ml",
    sig    = "Stdlib.Effect_cmi",
    opts = MODULE_OPTS,
    warnings = ["41"],
    deps   = [
        "Stdlib.Callback",
        "Stdlib.Obj",
        "Stdlib.Printexc",
        "Stdlib.Printf",
    ],
)

stdlib_signature(
    name = "Stdlib.Effect_cmi",
    src  = "effect.mli",
    opts = SIG_OPTS,
    deps   = [":Stdlib.Printexc_cmi"],
)

stdlib_module(
    name   = "Stdlib.Either",
    struct = "either.ml",
    sig    = "Stdlib.Either_cmi",
)

stdlib_signature(
    name = "Stdlib.Either_cmi",
    src  = "either.mli",
)

stdlib_module(
    name   = "Stdlib.Ephemeron",
    struct = "ephemeron.ml",
    sig    = "Stdlib.Ephemeron_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Array",
        ":Stdlib.Hashtbl",
        ":Stdlib.Int",
        ":Stdlib.Lazy",
        ":Stdlib.List",
        ":Stdlib.Obj",
        ":Stdlib.Random",
        ":Stdlib.Seq",
        ":Stdlib.Sys",
    ],
)

stdlib_signature(
    name = "Stdlib.Ephemeron_cmi",
    src  = "ephemeron.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Hashtbl_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.Filename",
    struct = "filename.ml",
    sig    = "Stdlib.Filename_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Buffer",
        ":Stdlib.Domain",
        ":Stdlib.Fun",
        ":Stdlib.List",
        ":Stdlib.Printf",
        ":Stdlib.Random",
        ":Stdlib.String",
        ":Stdlib.Sys",
    ],
)

stdlib_signature(
    name = "Stdlib.Filename_cmi",
    src  = "filename.mli",
    opts = SIG_OPTS,
    deps   = [":Stdlib"],
)

stdlib_module(
    name   = "Stdlib.Float",
    struct = "float.ml",
    sig    = "Stdlib.Float_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib.List",
        ":Stdlib.Array",
    ],
)

stdlib_signature(
    name = "Stdlib.Float_cmi",
    src  = "float.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib"
    ],
)

stdlib_module(
    name   = "Stdlib.Format",
    struct = "format.ml",
    sig    = "Stdlib.Format_cmi",
    opts = MODULE_OPTS,
    warnings = ["fragile-match"],
    deps   = [
        ":CamlinternalFormat",
        ":CamlinternalFormatBasics",
        ":Stdlib",
        ":Stdlib.Array",
        ":Stdlib.Buffer",
        ":Stdlib.Bytes",
        ":Stdlib.Domain",
        ":Stdlib.Either",
        ":Stdlib.Int",
        ":Stdlib.List",
        ":Stdlib.Queue",
        ":Stdlib.Seq",
        ":Stdlib.Stack",
        ":Stdlib.String",
    ],
)

stdlib_signature(
    name = "Stdlib.Format_cmi",
    src  = "format.mli",
    opts = SIG_OPTS,
    warnings = ["fragile-match"],
    deps   = [
        ":Stdlib_cmi",
        ":Stdlib.Buffer_cmi",
        ":Stdlib.Domain_cmi",
        ":Stdlib.Either_cmi",
        ":Stdlib.Seq_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.Fun",
    struct = "fun.ml",
    sig    = "Stdlib.Fun_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Printexc",
    ],
)

stdlib_signature(
    name = "Stdlib.Fun_cmi",
    src  = "fun.mli",
    opts = SIG_OPTS,
    deps   = [
    ],
)

stdlib_module(
    name   = "Stdlib.Gc",
    struct = "gc.ml",
    sig    = "Stdlib.Gc_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Printf",
        ":Stdlib.Printexc",
    ],
)

stdlib_signature(
    name = "Stdlib.Gc_cmi",
    src  = "gc.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Printexc",
    ],
)

stdlib_module(
    name   = "Stdlib.Genlex",
    struct = "genlex.ml",
    sig    = "Stdlib.Genlex_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Bytes",
        ":Stdlib.Char",
        ":Stdlib.Hashtbl",
        ":Stdlib.List",
        ":Stdlib.Stream",
        ":Stdlib.String",
    ],
)

stdlib_signature(
    name = "Stdlib.Genlex_cmi",
    src  = "genlex.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib",
        ":Stdlib.Stream"
    ],
)

stdlib_module(
    name   = "Stdlib.Hashtbl",
    struct = "hashtbl.ml",
    sig    = "Stdlib.Hashtbl_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Array",
        ":Stdlib.Int",
        ":Stdlib.Lazy",
        ":Stdlib.Obj",
        ":Stdlib.Random",
        ":Stdlib.Seq",
        ":Stdlib.String",
        ":Stdlib.Sys",
        # ":CamlinternalLazy",
        ## (MakeSeeded)
        ## (H)
    ],
)

stdlib_signature(
    name = "Stdlib.Hashtbl_cmi",
    src  = "hashtbl.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ## (H)
    ],
)

stdlib_module(
    name   = "Stdlib.In_channel",
    struct = "in_channel.ml",
    sig    = "Stdlib.In_channel_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Fun"
    ],
)

stdlib_signature(
    name = "Stdlib.In_channel_cmi",
    src  = "in_channel.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib"
    ],
)

stdlib_module(
    name   = "Stdlib.Int",
    struct = "int.ml",
    sig    = "Stdlib.Int_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib"
    ],
)

stdlib_signature(
    name = "Stdlib.Int_cmi",
    src  = "int.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib"
    ],
)

stdlib_module(
    name   = "Stdlib.Int32",
    struct = "int32.ml",
    sig    = "Stdlib.Int32_cmi",
    opts = MODULE_OPTS + ["-no-alias-deps"],
    deps   = [
        # ":Stdlib_cmi",
        ":Stdlib.Sys",
    ],
)

stdlib_signature(
    name = "Stdlib.Int32_cmi",
    src  = "int32.mli",
    opts = SIG_OPTS + ["-no-alias-deps"],
    deps   = [
        # ":Stdlib_cmi",
        ":Stdlib.Sys",
    ],
)

stdlib_module(
    name   = "Stdlib.Int64",
    struct = "int64.ml",
    sig    = "Stdlib.Int64_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib",
    ],
)

stdlib_signature(
    name = "Stdlib.Int64_cmi",
    src  = "int64.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib"
    ],
)

stdlib_module(
    name   = "Stdlib.Lazy",
    struct = "lazy.ml",
    sig    = "Stdlib.Lazy_cmi",
    opts = MODULE_OPTS,
    # + select({
    #     mode:native : ["-afl-inst-ratio 0"]
    # })
    deps   = [
        ":Stdlib.Obj",
        ":CamlinternalLazy",
    ],
)

stdlib_signature(
    name = "Stdlib.Lazy_cmi",
    src  = "lazy.mli",
    opts = SIG_OPTS,
    deps   = [
        ":CamlinternalLazy",
    ],
)

stdlib_module(
    name   = "Stdlib.Lexing",
    struct = "lexing.ml",
    sig    = "Stdlib.Lexing_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Int",
        ":Stdlib.Bytes",
        ":Stdlib.Array",
        ":Stdlib"
    ],
)

stdlib_signature(
    name = "Stdlib.Lexing_cmi",
    src  = "lexing.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.List",
    struct = "list.ml",
    sig    = "Stdlib.List_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.Seq",
        ":Stdlib.Either",
    ],
)

stdlib_signature(
    name = "Stdlib.List_cmi",
    src  = "list.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib.Either",
    ],
)

stdlib_module(
    name   = "Stdlib.ListLabels",
    struct = "listLabels.ml",
    sig    = "Stdlib.ListLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    deps   = [
        ":Stdlib.List",
    ],
)

stdlib_signature(
    name = "Stdlib.ListLabels_cmi",
    src  = "listLabels.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib.Either",
    ],
)

stdlib_module(
    name   = "Stdlib.Map",
    struct = "map.ml",
    sig    = "Stdlib.Map_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.List",
        ":Stdlib.Seq",
    ],
)

stdlib_signature(
    name = "Stdlib.Map_cmi",
    src  = "map.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
)

stdlib_module(
    name   = "Stdlib.Marshal",
    struct = "marshal.ml",
    sig    = "Stdlib.Marshal_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Bytes",
    ],
)

stdlib_signature(
    name = "Stdlib.Marshal_cmi",
    src  = "marshal.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib"
    ],
)

stdlib_module(
    name   = "Stdlib.MoreLabels",
    struct = "moreLabels.ml",
    sig    = "Stdlib.MoreLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    deps   = [
        ":Stdlib.Set",
        ":Stdlib.Map",
        ":Stdlib.Hashtbl"
    ],
)

stdlib_signature(
    name = "Stdlib.MoreLabels_cmi",
    src  = "moreLabels.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Set",
        ":Stdlib.Seq",
        # ":Stdlib.Ord",
        ":Stdlib.Map",
        ":Stdlib.Hashtbl"
        # H
    ],
)

stdlib_module(
    name   = "Stdlib.Mutex",
    struct = "mutex.ml",
    sig    = "Stdlib.Mutex_cmi",
    opts = MODULE_OPTS,
    deps   = [
        # ":Stdlib.Set",
        # ":Stdlib.Map",
        # ":Stdlib.Hashtbl"
    ],
)

stdlib_signature(
    name = "Stdlib.Mutex_cmi",
    src  = "mutex.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib.Set",
        # ":Stdlib.Seq",
        # # ":Stdlib.Ord",
        # ":Stdlib.Map",
        # ":Stdlib.Hashtbl"
        # # H
    ],
)

stdlib_module(
    name   = "Stdlib.Nativeint",
    struct = "nativeint.ml",
    sig    = "Stdlib.Nativeint_cmi",
    opts = MODULE_OPTS,
    deps   = [
        # ":Stdlib_cmi",
        ":Stdlib.Sys",
    ],
)

stdlib_signature(
    name = "Stdlib.Nativeint_cmi",
    src  = "nativeint.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib_cmi",
        ":Stdlib.Sys",
    ],
)

stdlib_module(
    name   = "Stdlib.Obj",
    struct = "obj.ml",
    sig    = "Stdlib.Obj_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.Nativeint",
        ":Stdlib.Int32",
    ],
)

stdlib_signature(
    name = "Stdlib.Obj_cmi",
    src  = "obj.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib_cmi",
        ":Stdlib.Int32",
    ],
)

stdlib_module(
    name   = "Stdlib.Oo",
    struct = "oo.ml",
    sig    = "Stdlib.Oo_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":CamlinternalOO",
    ],
)

stdlib_signature(
    name = "Stdlib.Oo_cmi",
    src  = "oo.mli",
    opts = SIG_OPTS + [
        "-no-principal" ## Only place this flag is used
    ],
    deps   = [
        ":CamlinternalOO",
    ],
)

stdlib_module(
    name   = "Stdlib.Option",
    struct = "option.ml",
    sig    = "Stdlib.Option_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
)

stdlib_signature(
    name = "Stdlib.Option_cmi",
    src  = "option.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
)

stdlib_module(
    name   = "Stdlib.Out_channel",
    struct = "out_channel.ml",
    sig    = "Stdlib.Out_channel_cmi",
    opts = MODULE_OPTS,
    deps   = [":Stdlib.Fun"],
)

stdlib_signature(
    name = "Stdlib.Out_channel_cmi",
    src  = "out_channel.mli",
    opts = SIG_OPTS,
    deps   = [":Stdlib"],
)

stdlib_module(
    name   = "Stdlib.Parsing",
    struct = "parsing.ml",
    sig    = "Stdlib.Parsing_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Obj",
        ":Stdlib.Lexing",
        ":Stdlib.Array",
        ":Stdlib"
    ],
)

stdlib_signature(
    name = "Stdlib.Parsing_cmi",
    src  = "parsing.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Obj_cmi",
        ":Stdlib.Lexing_cmi",
        # ":Stdlib_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.Pervasives",
    struct = "pervasives.ml",
    opts = MODULE_OPTS,
    deps   = [
        ":CamlinternalFormatBasics",
        ## (LargeFile)
    ],
)
# bootstrap_implicit_signature(
#     name    = "Stdlib.Parsing_cmi",
#     module  = "parsing.ml",
#     visibility = ["//visibility:public"]
# )

stdlib_module(
    name   = "Stdlib.Printexc",
    struct = "printexc.ml",
    sig    = "Stdlib.Printexc_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib",
        ":Stdlib.Array",
        ":Stdlib.Atomic",
        ":Stdlib.Buffer",
        ":Stdlib.Obj",
        ":Stdlib.Printf",
    ],
)

stdlib_signature(
    name = "Stdlib.Printexc_cmi",
    src  = "printexc.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Obj_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.Printf",
    struct = "printf.ml",
    sig    = "Stdlib.Printf_cmi",
    opts = MODULE_OPTS,
    warnings = ["fragile-match"],
    deps   = [
        # ":CamlinternalFormatBasics",
        ":CamlinternalFormat",
        ":Stdlib.Buffer",
    ],
)

stdlib_signature(
    name = "Stdlib.Printf_cmi",
    src  = "printf.mli",
    opts = SIG_OPTS,
    warnings = ["fragile-match"],
    deps   = [
        ":Stdlib.Buffer",
    ],
)

stdlib_module(
    name   = "Stdlib.Queue",
    struct = "queue.ml",
    sig    = "Stdlib.Queue_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib",
        ":Stdlib.Seq",
    ],
)

stdlib_signature(
    name = "Stdlib.Queue_cmi",
    src  = "queue.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
        # ":Stdlib",
    ],
)

stdlib_module(
    name   = "Stdlib.Random",
    struct = "random.ml",
    sig    = "Stdlib.Random_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib",
        ":Stdlib.Array",
        ":Stdlib.Bytes",
        ":Stdlib.Bigarray",
        # ":Stdlib.Char",
        ":Stdlib.Digest",
        ":Stdlib.Domain",
        ":Stdlib.Int",
        ":Stdlib.Int32",
        ":Stdlib.Int64",
        ":Stdlib.Nativeint",
        ":Stdlib.String",
    ],
)

stdlib_signature(
    name = "Stdlib.Random_cmi",
    src  = "random.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Nativeint",
        ":Stdlib.Int64",
        ":Stdlib.Int32",
    ],
)

stdlib_module(
    name   = "Stdlib.Result",
    struct = "result.ml",
    sig    = "Stdlib.Result_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Seq",
        # ":Stdlib"
    ],
)

stdlib_signature(
    name = "Stdlib.Result_cmi",
    src  = "result.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib",
        ":Stdlib.Seq"
    ],
)

stdlib_module(
    name   = "Stdlib.Scanf",
    struct = "scanf.ml",
    sig    = "Stdlib.Scanf_cmi",
    opts   = MODULE_OPTS,
    warnings = ["fragile-match"],
    # + select({
    #     mode:native  ["-inline", 9]
    # })
    deps   = [
        ":CamlinternalFormatBasics",
        ":CamlinternalFormat",
        ":Stdlib.Buffer",
        ":Stdlib.Bytes",
        ":Stdlib.Int",
        ":Stdlib.List",
        ":Stdlib.Printf",
        ":Stdlib.String",
    ],
)

stdlib_signature(
    name  = "Stdlib.Scanf_cmi",
    src   = "scanf.mli",
    opts  = SIG_OPTS,
    warnings = ["fragile-match"],
    deps  = [
        ":Stdlib_cmi",
        # ":CamlinternalFormatBasics_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.Semaphore",
    struct = "semaphore.ml",
    sig    = "Stdlib.Semaphore_cmi",
    opts   = MODULE_OPTS,
    # + select({
    #     mode:native  ["-inline", 9]
    # })
    deps   = [
        ":Stdlib.Condition",
        ":Stdlib.Mutex",
    ],
)

stdlib_signature(
    name  = "Stdlib.Semaphore_cmi",
    src   = "semaphore.mli",
    opts  = SIG_OPTS,
    deps  = [
    ],
)

stdlib_module(
    struct = "seq.ml",
    name   = "Stdlib.Seq",
    sig    = "Stdlib.Seq_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Atomic",
        ":Stdlib.Either",
        ":Stdlib.Lazy"
    ],
)

stdlib_signature(
    name = "Stdlib.Seq_cmi",
    src  = "seq.mli",
    opts = SIG_OPTS,
    deps   = [":Stdlib.Either_cmi"],
)

stdlib_module(
    name   = "Stdlib.Set",
    struct = "set.ml",
    sig    = "Stdlib.Set_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib.List",
    ],
)

stdlib_signature(
    name = "Stdlib.Set_cmi",
    src  = "set.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
)

stdlib_module(
    name   = "Stdlib.Stack",
    struct = "stack.ml",
    sig    = "Stdlib.Stack_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib.List",
    ],
)

stdlib_signature(
    name = "Stdlib.Stack_cmi",
    src  = "stack.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
)

stdlib_module(
    name   = "Stdlib.StdLabels",
    struct = "stdLabels.ml",
    sig    = "Stdlib.StdLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    deps   = [
        ":Stdlib.StringLabels",
        ":Stdlib.ListLabels",
        ":Stdlib.BytesLabels",
        ":Stdlib.ArrayLabels",
    ],
)

stdlib_signature(
    name = "Stdlib.StdLabels_cmi",
    src  = "stdLabels.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.StringLabels",
        ":Stdlib.ListLabels",
        ":Stdlib.BytesLabels",
        ":Stdlib.ArrayLabels",
    ],
)

stdlib_module(
    name   = "Stdlib.Stream",
    struct = "stream.ml",
    sig    = "Stdlib.Stream_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":CamlinternalLazy",
        ":Stdlib.String",
        ":Stdlib.List",
        ":Stdlib.Lazy",
        ":Stdlib.Bytes",
    ],
)

stdlib_signature(
    name = "Stdlib.Stream_cmi",
    src  = "stream.mli",
    opts = SIG_OPTS,
    deps   = [
    ],
)

stdlib_module(
    name   = "Stdlib.String",
    struct = "string.ml",
    sig    = "Stdlib.String_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Bytes",
    ],
)

stdlib_signature(
    name = "Stdlib.String_cmi",
    src  = "string.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq_cmi",
        ":Stdlib.Uchar_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.StringLabels",
    struct = "stringLabels.ml",
    sig    = "Stdlib.StringLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    deps   = [
        ":Stdlib.String",
    ],
)

stdlib_signature(
    name = "Stdlib.StringLabels_cmi",
    src  = "stringLabels.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq_cmi",
        ":Stdlib.Uchar_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.Sys",
    struct = "sys.ml",
    sig    = "Stdlib.Sys_cmi",
    # sig    = select({
    #     "//config:sig_src?"   : "sys.mli",
    #     "//conditions:default": ":Stdlib.Sys_cmi"
    # }),
    # deps    = select({
    #     "//config:sig_src?"   : ["//stdlib:Stdlib"],
    #     "//conditions:default": []
    # }),

    opts = MODULE_OPTS,
)

stdlib_signature(
    name = "Stdlib.Sys_cmi",
    src  = "sys.mli",
    opts = SIG_OPTS,
    deps = [":Stdlib"],
)

stdlib_module(
    name   = "Stdlib.Uchar",
    struct = "uchar.ml",
    sig    = "Stdlib.Uchar_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Char",
    ],
)

stdlib_signature(
    name = "Stdlib.Uchar_cmi",
    src  = "uchar.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Char",
    ],
)

stdlib_module(
    name   = "Stdlib.Unit",
    struct = "unit.ml",
    # sig    = "Stdlib.Unit_cmi",
    ## NOTE: compiling with --//config:sig_src requires
    ## "//stdlib:Stdlib" in deps
    sig    = select({
        "//config:sig_src?"   : "unit.mli",
        "//conditions:default": "Stdlib.Unit_cmi"
    }),
    deps    = select({
        "//config:sig_src?"   : ["//stdlib:Stdlib"],
        "//conditions:default": []
    }),
    opts = MODULE_OPTS,
)

stdlib_signature(
    name = "Stdlib.Unit_cmi",
    src  = "unit.mli",
    opts = SIG_OPTS,
    deps   = [
    ],
)

stdlib_module(
    name   = "Stdlib.Weak",
    struct = "weak.ml",
    # sig    = "Stdlib.Weak_cmi",
    sig    = select({
        "//config:sig_src?"   : "weak.mli",
        "//conditions:default": ":Stdlib.Weak_cmi"
    }),
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.Obj",
        ":Stdlib.Int",
        ":Stdlib.Array",
        ":Stdlib.Hashtbl",
        ## (H)
    ],
)

stdlib_signature(
    name = "Stdlib.Weak_cmi",
    src  = "weak.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Hashtbl",
    ],
)

################################################################
# HEADERPROGRAM = header
# HEADER_PATH = $(BINDIR)/
# HEADER_TARGET_PATH = $(TARGET_BINDIR)/
# TARGETHEADERPROGRAM = target_$(HEADERPROGRAM)

## on systems that support hashbang scripts, emits a hashbang header,
## e.g. '#!/usr/local/bin/ocamlrun', or does something I don't
## understand involving ocamlrun.

## on systems that do not support hashbang shell scripts, Makefile
## compiles header.c to tmpheader.exe, etc...

## so for PoC purposes we just emit a hard-coded shebang

## camlheader is required for compiling a bytecode executable. to get
## it into the deps list we add it to deps_runtime of stdlib.ml, until we
## figure out how best to do this.

## use --stamp and --workspace_status_command
## see .bazelrc, bzl/camlheader.sh

## FIXME: default uses sys install locn, e.g. /usr/local/bin/ocamlrun
## for dev, use path to internal dev ocamlrun instead

# stdlib/Makefile:
# $(HEADERPROGRAM)%$(O): \
#   OC_CPPFLAGS += -DRUNTIME_NAME='"$(HEADER_PATH)ocamlrun$(subst .,,$*)"'

SYSPATHS_CMD = " ".join([
    "cat bazel-out/stable-status.txt | ",
    "grep \"STABLE_CAMLHEADER \" | ",
    "cut -d ' ' -f 2 - ",
    "> $(location camlheader);",

        "cat bazel-out/stable-status.txt | ",
    "grep \"STABLE_TARGET_CAMLHEADER \" | ",
    "cut -d ' ' -f 2 - ",
    "> $(location target_camlheader);",

        "cat bazel-out/stable-status.txt | ",
    "grep \"STABLE_CAMLHEADERD \" | ",
    "cut -d ' ' -f 2 - ",
    "> $(location camlheaderd);",

        "cat bazel-out/stable-status.txt | ",
    "grep STABLE_TARGET_CAMLHEADERD | ",
    "cut -d ' ' -f 2 - ",
    "> $(location target_camlheaderd);",

        "cat bazel-out/stable-status.txt | ",
    "grep \"STABLE_CAMLHEADERI \" | ",
    "cut -d ' ' -f 2 - ",
    "> $(location camlheaderi);",

        "cat bazel-out/stable-status.txt | ",
    "grep \"STABLE_TARGET_CAMLHEADERI \" | ",
    "cut -d ' ' -f 2 - ",
    "> $(location target_camlheaderi);",
])

## IMPORTANT! For this to work, the following cli args must be passed:
# --stamp
# --workspace_status_command=$PWD/bzl/camlheader.sh

## FIXME: select camlheader content: for running under Bazel, null, otherwise installation path,
## not $(execpath //boot/baseline:ocamlrun)?
DEVPATHS_CMD = "\n".join([
    "cat bazel-out/stable-status.txt | ",
    "while read KEY VAL; do",
    "if [ $$KEY = \"STABLE_WORKSPACE_ROOT\" ]; then\n",
    "echo '#!'$$VAL/$(execpath //boot/baseline:ocamlrun) > $(location _build/camlheader);\n",
    "echo '#!'$$VAL/$(execpath //boot/baseline:ocamlrun)d > $(location _build/camlheaderd);\n",
    "echo '#!'$$VAL/$(execpath //boot/baseline:ocamlrun)i > $(location _build/camlheaderi);\n",
    # "touch $(location camlheader);\n",
    # "touch $(location camlheaderd);\n",
    # "touch $(location camlheaderi);\n",
    "fi",
    "done",

    "echo '#!$(execpath //boot/baseline:ocamlrun)' > $(location _build/target_camlheader);",
    "echo '#!$(execpath //boot/baseline:ocamlrun)d' > $(location _build/target_camlheaderd);",
    "echo '#!$(execpath //boot/baseline:ocamlrun)i' > $(location _build/target_camlheaderi);",
])

boot_camlheaders(
    name     = "camlheaders",
    template = "camlheader.template",
    runtimes  = [
        "//runtime:ocamlrun",
        # "//boot/baseline:ocamlrun",
        # "//boot/baseline:ocamlrund",  # if we had this
        # "//boot/baseline:ocamlruni",
    ],
    prefix   = "$PWD",
)

genrule(
    name = "Xcamlheaders",
    outs = [
        "_build/camlheader",
        "_build/camlheaderd",
        "_build/camlheaderi",
        # "camlheader_ur",
        "_build/target_camlheader",
        "_build/target_camlheaderd",
        "_build/target_camlheaderi"
    ],
    # srcs = [
    #     "//boot/baseline:ocamlrun",
    #     "//bzl/toolchain:ocamlrun"
    # ],
    srcs = [
        "//boot/baseline:ocamlrun",
        "//bzl/toolchain:ocamlrun"
    ],
    cmd = DEVPATHS_CMD,
    stamp = True,
    visibility = ["//visibility:public"]
)

################################################################
## cmigroup used by `//promote` targets
# filegroup(
#     name = "cmigroup",
#     srcs = [
#         ":Stdlib.Arg_cmi",
#         ":Stdlib.ArrayLabels_cmi",
#         ":Stdlib.Array_cmi",
#         ":Stdlib.Atomic_cmi",
#         ":Stdlib.Bigarray_cmi",
#         ":Stdlib.Bool_cmi",
#         ":Stdlib.Buffer_cmi",
#         ":Stdlib.BytesLabels_cmi",
#         ":Stdlib.Bytes_cmi",
#         ":Stdlib.Callback_cmi",
#         ":CamlinternalFormatBasics_cmi",
#         ":CamlinternalFormat_cmi",
#         ":CamlinternalLazy_cmi",
#         ":CamlinternalMod_cmi",
#         ":CamlinternalOO_cmi",
#         ":Stdlib.Char_cmi",
#         ":Stdlib.Complex_cmi",
#         ":Stdlib.Condition_cmi",
#         ":Stdlib.Digest_cmi",
#         ":Stdlib.Either_cmi",
#         ":Stdlib.Ephemeron_cmi",
#         ":Stdlib.Filename_cmi",
#         ":Stdlib.Float_cmi",
#         ":Stdlib.Format_cmi",
#         ":Stdlib.Fun_cmi",
#         ":Stdlib.Gc_cmi",
#         ":Stdlib.Hashtbl_cmi",
#         ":Stdlib.In_channel_cmi",
#         ":Stdlib.Int32_cmi",
#         ":Stdlib.Int64_cmi",
#         ":Stdlib.Int_cmi",
#         ":Stdlib.Lazy_cmi",
#         ":Stdlib.Lexing_cmi",
#         ":Stdlib.ListLabels_cmi",
#         ":Stdlib.List_cmi",
#         ":Stdlib.Map_cmi",
#         ":Stdlib.Marshal_cmi",
#         ":Stdlib.MoreLabels_cmi",
#         ":Stdlib.Mutex_cmi",
#         ":Stdlib.Nativeint_cmi",
#         ":Stdlib.Obj_cmi",
#         ":Stdlib.Oo_cmi",
#         ":Stdlib.Option_cmi",
#         ":Stdlib.Out_channel_cmi",
#         ":Stdlib.Parsing_cmi",
#         ":Stdlib.Printexc_cmi",
#         ":Stdlib.Printf_cmi",
#         ":Stdlib.Queue_cmi",
#         ":Stdlib.Random_cmi",
#         ":Stdlib.Result_cmi",
#         ":Stdlib.Scanf_cmi",
#         ":Stdlib.Semaphore_cmi",
#         ":Stdlib.Seq_cmi",
#         ":Stdlib.Set_cmi",
#         ":Stdlib.Stack_cmi",
#         ":Stdlib.StdLabels_cmi",
#         ":Stdlib.StringLabels_cmi",
#         ":Stdlib.String_cmi",
#         ":Stdlib.Sys_cmi",
#         ":Stdlib.Uchar_cmi",
#         ":Stdlib.Unit_cmi",
#         ":Stdlib.Weak_cmi",
#     ],
#     visibility = ["//promote:__pkg__"]
# )

################################################################
  ################  Module: Std_exit    ################
################################################################
## Module Std_exit is an "executive" module - it exports no symbols,
## and is used in executables for its side-effects. The bytecode
## compiler inserts module Std_exit at the end of every executable.

## (I.e. it is not required for building native executables?)

## Its signature is empty (it exports no symbols), and its structfile
## contains a single line of code:

# (* Ensure that [at_exit] functions are called at the end of every program *)
# let _ = do_at_exit()

# The module itself has no external dependencies, but it does depend
# on the internal Pervasives module, so it must be NOT be compiled
# with '-nopervasives'.

## Special case: our convention is the normalize file names to match
## canical module names. In this case that would yield Std_exit; but
## the compilers are hard-coded to look for 'std_exit'. So this rule
## special cases this.

stdlib_boot_signature(
    name = "Std_exit_cmi",
    src  = "std_exit.mli",
    deps = [":Stdlib"]
)

stdlib_boot_module(
    name   = "Std_exit",
    struct = "std_exit.ml",
    sig    = select({
        "//config:sig_src?": "std_exit.mli",
        "//conditions:default": "Std_exit_cmi"
    }),
    opts = ["-open", "Stdlib"],
    deps = [":Stdlib"]
)
