## NB: ocamldep does not show deps on the Stdlib module. So files with
## no deps according to ocamldep may in fact have a dependency on the
## Stdlib module (only). E.g. sys.mli. Some files in fact have no
## deps, e.g. bool.mli.

## make log: flags same for >vm and >sys, except the former adds -use-prims

## NB: camlinternal files differ from public submodules:
# compiled twice for >vm, with and without -use-prims

## NB:
# -nopervasives used ONLY for camlinternalFormatBasics, stdlib
# -fragile-match only for camlinternalFormat, printf, format, scanf

# ../runtime/ocamlrun ../boot/ocamlc
# -use-prims ../runtime/primitives
# -strict-sequence -absname -w +a-4-9-41-42-44-45-48 -g -warn-error +A -bin-annot -nostdlib -principal -nopervasives
# -c camlinternalFormatBasics.mli  (and .ml)

# ../boot/ocamlrun ../ocamlc
# -strict-sequence -absname -w +a-4-9-41-42-44-45-48 -g -warn-error +A -bin-annot -nostdlib -principal -nopervasives
# -c camlinternalFormatBasics.mli

# ../boot/ocamlrun ../ocamlopt  (NB: does not recompile mli files)
# -strict-sequence -absname -w +a-4-9-41-42-44-45-48 -g -warn-error +A -bin-annot -nostdlib -principal -nopervasives
# -c camlinternalFormatBasics.ml

# uses ocamlc to run awl using -pp

## resolver Stdlib: uses awk preprocessing to expand the module aliasing equations, once with -use-prims, once w/o

# ../runtime/ocamlrun ../boot/ocamlc
# -use-prims ../runtime/primitives
# -strict-sequence -absname -w +a-4-9-41-42-44-45-48 -g -warn-error +A -bin-annot -nostdlib -principal
# -nopervasives -no-alias-deps -w -49
# -pp "$AWK -f ./expand_module_aliases.awk"
# -c stdlib.mli

# ../boot/ocamlrun ../ocamlc
# -strict-sequence -absname -w +a-4-9-41-42-44-45-48 -g -warn-error +A -bin-annot -nostdlib -principal
# -nopervasives -no-alias-deps -w -49
# -pp "$AWK -f ./expand_module_aliases.awk"
# -c stdlib.mli

# ../boot/ocamlrun ../ocamlopt
# -strict-sequence -absname -w +a-4-9-41-42-44-45-48 -g -warn-error +A -bin-annot -nostdlib -principal
# -nopervasives -no-alias-deps -w -49
# -pp "$AWK -f ./expand_module_aliases.awk"
# -c stdlib.ml

## submodules:
# ../runtime/ocamlrun ../boot/ocamlc
# -use-prims ../runtime/primitives
# -strict-sequence -absname -w +a-4-9-41-42-44-45-48 -g -warn-error +A -bin-annot -nostdlib -principal
# -o stdlib__Either.cmi -c either.mli  (ditto either.ml)

# ../boot/ocamlrun ../ocamlc
# -strict-sequence -absname -w +a-4-9-41-42-44-45-48 -g -warn-error +A -bin-annot -nostdlib -principal
# -o stdlib__Either.cmi -c either.mli  (ditto either.ml)

load("//bzl:rules.bzl",
     "boot_archive",
     "boot_library",
     "boot_module",
     # "bootstrap_preprocess",
     "boot_signature")

load("//config:CONFIG.bzl",
     ## stdlib overrides OCAMLC, does not use ROOT_OCAMLC_OPTS
     ## "ROOT_CAMLC_OPTS",

     "OPTCOMPFLAGS",
     # "USE_PRIMS",
     # "DATA_PRIMS",
     # "PRIMITIVES"
     )

package(default_visibility = ["//visibility:public"])

exports_files(["expand_module_aliases.awk", "weak.ml", "weak.mli"])

# load("//config:CONFIG.bzl", "ROOT_MODULE_OPTS", "ROOT_SIG_OPTS")

# to match the makefile log:
# COMPFLAGS = [
#     "-strict-sequence", "-absname",
#     "-w", "+a-4-9-41-42-44-45-48",
#     # "-g",
#     "-warn-error", "+A",
#     "-bin-annot",
#     "-nostdlib", "-principal",
#     # "-safe-string", "-strict-formats"
# ]

MODULE_OPTS = [] ## COMPFLAGS

# MODULE_OPTS = ROOT_MODULE_OPTS
SIG_OPTS = MODULE_OPTS


LABEL_OPTS = ["-nolabels", "-no-alias-deps"]
LABEL_SIGOPTS = [
    ## this pp not needed by obazl?
    ## ' -pp "$AWK -f ./expand_module_aliases.awk"'
]

################################################################
  ################  Module: Std_exit    ################
################################################################
## Module Std_exit is an "executive" module - it exports no symbols,
## and is used in executables for its side-effects. The bytecode
## compiler inserts module Std_exit at the end of every executable.

## (I.e. it is not required for building native executables?)

## Its signature is empty (it exports no symbols), and its structfile
## contains a single line of code:

# (* Ensure that [at_exit] functions are called at the end of every program *)
# let _ = do_at_exit()

# The module itself has no external dependencies, but it does depend
# on the internal Pervasives module, so compiling with "-nopervasives"
# will fail with:

# 18 | let _ = do_at_exit()
#              ^^^^^^^^^^
# Error: Unbound value do_at_exit

# and stdlib.ml has:
# let _ = register_named_value "Pervasives.do_at_exit" do_at_exit

# The module itself has no dependencies, but the compilers induce a
# pseudo-dependency on the standard library archive and module Stdlib,
# so compilation does depend on Stdlib. Futhermore, if you
# bootstrap-link an executable with Std_exit at the end but omit
# stdlib.cm[x]a, you'll get:

#     Error: Module `Stdlib' is unavailable (required by `Std_exit')

# Compiling Std_exit with "-nostdlib" produces: "Error: Unbound module
# Stdlib". This is because this flag only tells OCaml to disregard its
# internal default path to Stdlib; it will still "-open Stdlib", which
# is what results in the error, and furthermore a dependency on the
# stdlib library (stdlib.cma, stdlib.cmxa) is hardcoded into the the
# compilers (bytelink.ml and asmlink.ml).

# So for a bootstrap compile we need to pass "-nostdlib" (so the
# compiler will not search its default stdlib path) and have a
# dependency on //stdlib:Stdlib.

## Make log below. Notice the ocamlc is not the boot version but the
## 1st gen version. This works with -nostdlib because it is run from
## within //stdlib. The other flags are not necessary, they're just an
## artifact of the Makefile build system.

# ../boot/ocamlrun ../ocamlc -strict-sequence -absname -w +a-4-9-41-42-44-45-48 -g -warn-error +A -bin-annot -nostdlib -principal   -c std_exit.mli
# ../boot/ocamlrun ../ocamlc -strict-sequence -absname -w +a-4-9-41-42-44-45-48 -g -warn-error +A -bin-annot -nostdlib -principal   -c std_exit.ml

boot_signature(
    name = "Std_exit_cmi",
    src  = "std_exit.mli",
    opts = ["-nostdlib"],
    deps   = ["//stdlib:Stdlib"]
)

boot_module(
    name   = "Std_exit",
    struct = "std_exit.ml",
    sig    = select({
        "//config:sig_src?": "std_exit.mli",
        "//conditions:default": "Std_exit_cmi"
    }),
    opts   = ["-nostdlib"],
    deps   = ["//stdlib:Stdlib"],
)

# using genrule we still get:
# Error: Unbound module Stdlib
# genrule(
#     name = "Std_exit",
#     outs = ["Std_exit.cmo"],
#     srcs = [
#         "//boot:ocamlc",
#         "std_exit.ml", "std_exit.mli"
#     ],
#     tools = ["//runtime:ocamlrun"],
#     cmd_bash  = " ".join([
#         "$(execpath //runtime:ocamlrun) $(location //boot:ocamlc)",
#         # "-use-prims ../runtime/primitives",
#         "-strict-sequence -absname -w +a-4-9-41-42-44-45-48 -g -warn-error +A -bin-annot -nostdlib -principal",
#         "$(location std_exit.mli)",
#         "$(location std_exit.ml)",
#         "> $@"
#     ]),
# )

####################################################
####    The Standard Library    ####
####################################################
## NB: "Error: Unbound module Stdlib".
# When bootstrapping there is no std lib yet; we pass -nostdlib to
# avoid putting its path in the search path. But the (bootstrap)
# compiler opens Stdlib by default, so we will always get the
# above-noted error. Pass -nopervasives to prevent this.
# This applies to:
# * camlinternalAtomic.ml[i],
# * camlinternalFormatBasics.ml[i]
# * stdlib.ml[i]

# Special cases: camlinternal* are not namespaced:
#   * camlinternaAtomic and camlinternalFormatBasics are deps of Stdlib.
#     they themselve have no deps, so -nopervasives
#   * the other camlinternal* depend on Stdlib, and may depend on
#     submodules in Stdlib ns

#   * when obazl builds submodules, it passes -open Stdlib. That's
#     enough to resolve symbols in the ns, but not their bindings. We
#     get errors like "Error: Unbound type constructor ref" and
#     "Error: Unbound value >=". I *think* that means the sym was
#     resolved in an interface the impl is missing.


## flags generated by $(shell ./Compflags $@) are added to individual
## targets

# ../runtime/ocamlrun ../boot/ocamlc -use-prims ../runtime/primitives -strict-sequence -absname -w +a-4-9-41-42-44-45-48-70 -g -warn-error +A -bin-annot -nostdlib -principal -safe-string -strict-formats   \
# 	         -o stdlib__Bigarray.cmi -c bigarray.mli

# camlinternal: Atomic, Format, FormatBasics, Lazy, Mod, OO
# CAMLINTERNAL_OPTS = [
#     # "-use-prims", "../runtime/primitives",
#     # "-nopervasives"
#     # "-open", "Stdlib"
# ] + COMPFLAGS

# Atomic, FormatBasics:  ["-nopervasives"]
#Format: ["-w", "+A", "-w", "-fragile-match"]

# OCAMLRUN = boot/ocamlrun
# COMPILER = ocamlc built in root dir (i.e. stage1?)
# CAMLC=$(OCAMLRUN) $(COMPILER)
# %.cmi: %.mli
# 	$(CAMLC) $(COMPFLAGS) $(shell ./Compflags $@) -c $<

# stdlib__%.cmo:
# 	$(CAMLC) $(COMPFLAGS) $(shell ./Compflags $@) \
# 	         -o $@ -c $(filter %.ml, $^)

# %.cmo: %.ml
# 	$(CAMLC) $(COMPFLAGS) $(shell ./Compflags $@) -c $<

# %.cmx: %.ml
# 	$(CAMLOPT) $(COMPFLAGS) $(OPTCOMPFLAGS) $(shell ./Compflags $@) -c $<

## NB: we do not need to define an ocaml_ns_resolver (or rather
## bootstrap_ns_resolver), since Stdlib serves as our ns_resolver
## module. Each submodule includes itself by attribution ns=":Stdlib".
## This library target just aggregates the resolver and submodules.
## They can be listed in any order.

boot_archive(
    name       = "test",
    manifest   = [
        ":Stdlib.Bool",
        ":Stdlib.Sys",
    ]
)

# NB: boot_library will not work. The compilers expect to find
# stdlib.cm[x]a - this is hardcoded.
boot_archive(
    name       = "stdlib",
    ## makefiles pass -use-prims. does that make sense, for an archive?
    # data       = ["//runtime:primitives"],
    # primitives = "//runtime:primitives",
    manifest   = [
        ":Stdlib", ## functions as the ns_resolver module
        ":CamlinternalFormat",
        ":CamlinternalFormatBasics",
        ":CamlinternalLazy",
        ":CamlinternalMod",
        ":CamlinternalOO",
        ":Stdlib.Arg",
        ":Stdlib.Array",
        ":Stdlib.ArrayLabels",
        ":Stdlib.Atomic",
        ":Stdlib.Bigarray",
        ":Stdlib.Bool",
        ":Stdlib.Buffer",
        ":Stdlib.Bytes",
        ":Stdlib.BytesLabels",
        ":Stdlib.Callback",
        ":Stdlib.Char",
        ":Stdlib.Complex",
        ":Stdlib.Condition",
        ":Stdlib.Digest",
        ":Stdlib.Domain",
        ":Stdlib.Effect",
        ":Stdlib.Either",
        ":Stdlib.Ephemeron",
        ":Stdlib.Filename",
        ":Stdlib.Float",
        ":Stdlib.Format",
        ":Stdlib.Fun",
        ":Stdlib.Gc",
        ":Stdlib.Hashtbl",
        ":Stdlib.In_channel",
        ":Stdlib.Int",
        ":Stdlib.Int32",
        ":Stdlib.Int64",
        ":Stdlib.Lazy",
        ":Stdlib.Lexing",
        ":Stdlib.List",
        ":Stdlib.ListLabels",
        ":Stdlib.Map",
        ":Stdlib.Marshal",
        ":Stdlib.MoreLabels",
        ":Stdlib.Mutex",
        ":Stdlib.Nativeint",
        ":Stdlib.Obj",
        ":Stdlib.Oo",
        ":Stdlib.Option",
        ":Stdlib.Out_channel",
        ":Stdlib.Parsing",
        ":Stdlib.Printexc",
        ":Stdlib.Printf",
        ":Stdlib.Queue",
        ":Stdlib.Random",
        ":Stdlib.Result",
        ":Stdlib.Scanf",
        ":Stdlib.Semaphore",
        ":Stdlib.Seq",
        ":Stdlib.Set",
        ":Stdlib.Stack",
        ":Stdlib.StdLabels",
        ":Stdlib.String",
        ":Stdlib.StringLabels",
        ":Stdlib.Sys",
        ":Stdlib.Uchar",
        ":Stdlib.Unit",
        ":Stdlib.Weak",
        #":Stdlib.Weak",
    ],
    visibility = ["//visibility:public"],
)

##################################################################
##############  Main Resolver Module: Stdlib  ####################

boot_module(
    name   = "Stdlib",
    struct = "x/stdlib.ml",
    sig    = "Stdlib_cmi", # doesn't work with stdlib.mli
    # use_prims = True,
    opts = [
        "-nopervasives",
        "-no-alias-deps",
        "-w", "-49",
        # "-pp", "awk -f expand_module_aliases.awk",
    ],
    deps = [
        ":CamlinternalFormatBasics",
    ],
    # pp_deps = ["//stdlib:expand_module_aliases.awk"],
    # visibility = ["//visibility:public"]
)

# ../runtime/ocamlrun ../boot/ocamlc
# -use-prims ../runtime/primitives
# -strict-sequence -absname -w +a-4-9-41-42-44-45-48-70
# -g -warn-error +A -bin-annot -nostdlib -principal
# -safe-string -strict-formats

## added to stdlib.cm[iox] only, by $(shell Comflags $@):
# -nopervasives -no-alias-deps -w -49
# -pp "$AWK -f ./expand_module_aliases.awk" -c stdlib.mli
## the awk script inserts the stdlib__ prefix in the module aliasing
## equations in stdlib.ml[i]

# WARNING: if we run this as a separate task (instead of passing the
# cmd to the compiler via -pp) we must write to a subdir, since the
# input filename is the same as the output filename. Ditto for
# stdlib.mli.

genrule(
    name = "stdlib_ml_awk",
    outs = ["x/stdlib.ml"], ## FIXME
    srcs = ["stdlib.ml", "//stdlib:expand_module_aliases.awk"],
    cmd_bash  = " ".join([
        "awk -f $(location //stdlib:expand_module_aliases.awk) $(location :stdlib.ml)",
        "> $@"
    ]),
)

boot_signature(
    name = "Stdlib_cmi",
    src  = "x/stdlib.mli",
    opts = SIG_OPTS + [
        "-nopervasives",
        "-no-alias-deps",
        "-w", "-49",
    ],
    deps   = [
        ":CamlinternalFormatBasics", #_cmi",
    ],
    # data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

# bootstrap_preprocess(
#     name = "stdlib_ml_awk",
#     outs = ["stdlib.ml"],
#     srcs = ["stdlib.ml", "//stdlib:expand_module_aliases.awk"],
#     cmd_bash  = " ".join([
#         "awk -f $(location //stdlib:expand_module_aliases.awk) $(location :stdlib.ml)",
#         "> $@"
#     ]),
# )

genrule(
    name = "stdlib_mli_awk",
    outs = ["x/stdlib.mli"],
    srcs = ["stdlib.mli", "//stdlib:expand_module_aliases.awk"],
    cmd_bash  = " ".join([
        "awk -f $(location //stdlib:expand_module_aliases.awk) $(location :stdlib.mli)",
        "> $@"
    ]),
)

################################################################
############  Non-namespaced Components of Stdlib ##############

## camlinternal* modules:
# All are in the Stdlib archive but none are in the Stdlib ns.
# Atomic and FormatBasic are deps of the nslib but do not depend on
# any other modules.
# The other camlinternal* are submodules but they are not renamed.
# They depend on other subcomponents, but since they are not renamed
# such deps must not be listed; instead just list :Stdlib.

boot_module(
    name   = "CamlinternalFormat",
    struct = "camlinternalFormat.ml",
    sig    = "CamlinternalFormat_cmi",
    # sig    = select({
    #     "//config:sig_src?"   : "camlinternalformat.mli",
    #     "//conditions:default": "CamlinternalFormat_cmi"
    # }),
    opts   = ["-open", "Stdlib"] + [
        "-w", "+A", "-w",
        "-fragile-match",
    ],
    deps   = [
        ":CamlinternalFormatBasics",
        # ":Stdlib",
        ":Stdlib.Buffer", ## (Stdlib Buffer)
        ":Stdlib.Bytes", ## (Stdlib Bytes)
        ":Stdlib.Char", ## (Stdlib Char)
        ":Stdlib.Int", ## (Stdlib Int)
        ":Stdlib.Sys", ## (Stdlib Sys)
        ":Stdlib.String", ## (Stdlib String)
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    name = "CamlinternalFormat_cmi",
    src  = "camlinternalFormat.mli",
    opts = [
        "-open", "Stdlib",
        "-w", "+A", "-w",
        "-fragile-match"
    ],
    deps   = [
        ":CamlinternalFormatBasics", #_cmi",

        # Depends on Buffer, but we need to go through the ns Stdlib.
        # The problem is we cannot express a dependency on an ns
        # submodule using a namespaced symbol like ":Stdlib.Buffer";
        # we can only depend on build targets.

        # Depending directly on :Buffer cause it (and its deps) to be
        # built w/o namespacing, so we'll have the same stuff built
        # with and without namespacing. Which is bad.
        ":Stdlib.Buffer_cmi",

        # :Stdlib (the resolver) itself is not renamed, but it
        # contains the alias for Buffer => Stdlib__Buffer. We get:
        ## "Error: The module Buffer is an alias for module
        ##  Stdlib__Buffer, which is missing."
        # ":Stdlib",

        # That's because the Stdlib (resolver) module, unlike the NS
        # lib, does not depend on the submodules, because it is
        # compiled with '-no-alias-deps'. So they do not get built
        # unless the NS target is built. But we cannot depend on
        # :ocaml-stdlib on pain of circularity.

        # What we need is to make CamlinternalFormat a component but
        # not a submodule of the namespace, without renaming. Then we
        # could list sibling deps directly.
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    name   = "CamlinternalFormatBasics",
    struct = "camlinternalFormatBasics.ml",
    sig    = "CamlinternalFormatBasics_cmi",
    opts   = ["-nopervasives"],
    # primitives = PRIMITIVES,
    # deps   = [],
    # visibility = ["//visibility:public"]
)

boot_signature(
    name = "CamlinternalFormatBasics_cmi",
    src  = "camlinternalFormatBasics.mli",
    opts   = ["-nopervasives"],
    # primitives = PRIMITIVES,
    # deps   = [],
    # visibility = ["//visibility:public"]
)

boot_module(
    name   = "CamlinternalLazy",
    struct = "camlinternalLazy.ml",
    sig    = select({
        "//config:sig_src?": "camlinternalLazy.mli",
        "//conditions:default": "CamlinternalLazy_cmi"
    }),
    opts   = [
        "-open", "Stdlib",
    ] + select({
        # "//platforms/target:sys?": ["-afl-inst-ratio", "0"],
        "//conditions:default": []
    }),
    deps   = [
        ":Stdlib",
        ":Stdlib.Obj",
        ":Stdlib.Sys",
    ],
)

boot_signature(
    name = "CamlinternalLazy_cmi",
    src  = "camlinternalLazy.mli",
    opts   = ["-open", "Stdlib"],
    deps   = [":Stdlib"],
)

boot_module(
    name   = "CamlinternalMod",
    struct = "camlinternalMod.ml",
    sig    = "CamlinternalMod_cmi",
    opts   = ["-open", "Stdlib"],
    deps   = [
        ":CamlinternalOO", ## (CamlinternalOO)
        ":CamlinternalLazy", ## (CamlinternalOO)
        ":Stdlib.Obj", ## (Stdlib Obj)
        ":Stdlib.Lazy", ## (Stdlib Lazy)
        ":Stdlib.Array", ## (Stdlib Array)
    ],
    # visibility = ["//visibility:public"]
)

boot_signature(
    name = "CamlinternalMod_cmi",
    src  = "camlinternalMod.mli",
    opts = ["-open", "Stdlib"],
    deps   = [
        # ":Stdlib",
        ":Stdlib.Obj",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    name   = "CamlinternalOO",
    struct = "camlinternalOO.ml",
    sig    = "CamlinternalOO_cmi",
    opts   = ["-open", "Stdlib"] + select({
        # "//platforms/target:vm?": [],
        # "//platforms/target:sys?": [
        #     "-inline", "0",
        #     "-afl-inst-ratio", "0"
        # ],
        "//conditions:default": []
    }),
    deps   = [
        # ":Stdlib",
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Obj",
        ":Stdlib.List",
        ":Stdlib.Char",
        ":Stdlib.Array",
        ":Stdlib.Map"
    ],
)

boot_signature(
    name = "CamlinternalOO_cmi",
    src  = "camlinternalOO.mli",
    opts = ["-open", "Stdlib"],
    deps   = [
        ":Stdlib.Obj"
    ],
)

#########################################################
################  Namespaced Submodules  ################

boot_module(
    name   = "Stdlib.Arg",
    ns    = ":Stdlib",
    struct = "arg.ml",
    sig    = "Stdlib.Arg_cmi",
    opts = MODULE_OPTS,
    # data = DATA_PRIMS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Printf",
        ":Stdlib.List",
        ":Stdlib.Int",
        ":Stdlib.Buffer",
        ":Stdlib.Array",
    ],
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Arg_cmi",
    src  = "arg.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Printf",
        ":Stdlib.List",
        ":Stdlib.Int",
        ":Stdlib.Buffer",
        ":Stdlib.Array",
    ],
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Array",
    struct = "array.ml",
    sig    = "Stdlib.Array_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Array_cmi",
    src  = "array.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.ArrayLabels",
    struct = "arrayLabels.ml",
    sig    = "Stdlib.ArrayLabels_cmi",
    opts = MODULE_OPTS + ["-nolabels", "-no-alias-deps"],
    deps   = [
        ":Stdlib.Array"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

## WARNING: output name same as input name, so write to tmp dir:
genrule(
    name = "array_labels_mli_awk",
    outs = ["x/arrayLabels.mli"],
    srcs = ["arrayLabels.mli", "//stdlib:expand_module_aliases.awk"],
    cmd_bash  = " ".join([
        "awk -f $(location //stdlib:expand_module_aliases.awk)",
        "$(location :arrayLabels.mli)",
        "> $@"
    ]),
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.ArrayLabels_cmi",
    src  = "x/arrayLabels.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    struct = "atomic.ml",
    name   = "Stdlib.Atomic",
    ns    = ":Stdlib",
    sig    = "Stdlib.Atomic_cmi",
    opts = MODULE_OPTS,
    deps   = [],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Atomic_cmi",
    src  = "atomic.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib_cmi"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Bigarray",
    struct = "bigarray.ml",
    sig    = "Stdlib.Bigarray_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.Complex",
        ":Stdlib.Array",
        ## (Genarray)
        ## (Array3)
        ## (Array2)
        ## (Array1)
        ## (Array0)
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Bigarray_cmi",
    src  = "bigarray.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Complex", ## (Stdlib Complex)
        ## (Genarray)
        ## (Array3)
        ## (Array2)
        ## (Array1)
        ## (Array0)
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Bool",
    struct = "bool.ml",
    sig    = "Stdlib.Bool_cmi",
    opts = MODULE_OPTS,
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Bool_cmi",
    src  = "bool.mli",
    opts = SIG_OPTS,
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Buffer",
    struct = "buffer.ml",
    sig    = "Stdlib.Buffer_cmi",
    opts = MODULE_OPTS + ["-w", "+A"],
    # + select({
    #     mode:native :-inline 3
    #     mode:bc: ["-w" "+A"]
    # }),
    deps   = [
        ":Stdlib.Uchar",
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Seq",
        ":Stdlib.Char",
        ":Stdlib.Bytes",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Buffer_cmi",
    src  = "buffer.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Uchar",
        ":Stdlib.Seq",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Bytes",
    struct = "bytes.ml",
    sig    = "Stdlib.Bytes_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Char",
        ":Stdlib.Int",
        ":Stdlib.Seq",
        ":Stdlib.Sys",
        ":Stdlib.Uchar",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Bytes_cmi",
    src  = "bytes.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Int_cmi",
        ":Stdlib.Seq_cmi",
        ":Stdlib.Uchar_cmi",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.BytesLabels",
    struct = "bytesLabels.ml",
    sig    = "Stdlib.BytesLabels_cmi",
    opts = MODULE_OPTS + ["-nolabels", "-no-alias-deps"],
    deps   = [
        ":Stdlib.Bytes",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.BytesLabels_cmi",
    src  = "bytesLabels.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq_cmi",
        ":Stdlib.Uchar_cmi"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Callback",
    struct = "callback.ml",
    sig    = "Stdlib.Callback_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Obj"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Callback_cmi",
    src  = "callback.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.In_channel"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    name   = "Stdlib.Char",
    ns    = ":Stdlib",
    struct = "char.ml",
    sig    = "Stdlib.Char_cmi",
    opts = MODULE_OPTS,
    deps   = [":Stdlib"],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Char_cmi",
    src  = "char.mli",
    opts = SIG_OPTS,
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Complex",
    struct = "complex.ml",
    sig    = "Stdlib.Complex_cmi",
    opts = MODULE_OPTS,
    deps   = ["Stdlib.Float"],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Complex_cmi",
    src  = "complex.mli",
    opts = SIG_OPTS,
    deps   = [ ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Condition",
    struct = "condition.ml",
    sig    = "Stdlib.Condition_cmi",
    opts = MODULE_OPTS,
    deps   = [":Stdlib.Mutex"],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Condition_cmi",
    src  = "condition.mli",
    opts = SIG_OPTS,
    deps   = [":Stdlib.Mutex_cmi"],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Digest",
    struct = "digest.ml",
    sig    = "Stdlib.Digest_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.String",
        ":Stdlib.Char",
        ":Stdlib.Bytes",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Digest_cmi",
    src  = "digest.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.In_channel_cmi"
        # ":Stdlib"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Domain",
    struct = "domain.ml",
    sig    = "Stdlib.Domain_cmi",
    opts = MODULE_OPTS,
    deps   = [
        "Stdlib",
        "Stdlib.Array",
        "Stdlib.Atomic",
        "Stdlib.Condition",
        "Stdlib.List",
        "Stdlib.Mutex",
        "Stdlib.Obj",
        "Stdlib.Sys",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Domain_cmi",
    src  = "domain.mli",
    opts = SIG_OPTS,
    deps   = [ ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Effect",
    struct = "effect.ml",
    sig    = "Stdlib.Effect_cmi",
    opts = MODULE_OPTS,
    deps   = [
        "Stdlib.Callback",
        "Stdlib.Obj",
        "Stdlib.Printexc",
        "Stdlib.Printf",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Effect_cmi",
    src  = "effect.mli",
    opts = SIG_OPTS,
    deps   = [":Stdlib.Printexc_cmi"],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Either",
    struct = "either.ml",
    sig    = "Stdlib.Either_cmi",
    # opts = MODULE_OPTS,
    # primitives = PRIMITIVES,
    # deps   = [
    # ],
    # data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Either_cmi",
    src  = "either.mli",
    # opts = SIG_OPTS,
    # primitives = PRIMITIVES,
    # deps   = [
    #     # ":Stdlib"
    # ],
    # data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Ephemeron",
    struct = "ephemeron.ml",
    sig    = "Stdlib.Ephemeron_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Array",
        ":Stdlib.Hashtbl",
        ":Stdlib.Int",
        ":Stdlib.Lazy",
        ":Stdlib.List",
        ":Stdlib.Obj",
        ":Stdlib.Random",
        ":Stdlib.Seq",
        ":Stdlib.Sys",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Ephemeron_cmi",
    src  = "ephemeron.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Hashtbl_cmi",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Filename",
    struct = "filename.ml",
    sig    = "Stdlib.Filename_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Buffer",
        ":Stdlib.Domain",
        ":Stdlib.Fun",
        ":Stdlib.List",
        ":Stdlib.Printf",
        ":Stdlib.Random",
        ":Stdlib.String",
        ":Stdlib.Sys",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Filename_cmi",
    src  = "filename.mli",
    opts = SIG_OPTS,
    deps   = [":Stdlib"],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Float",
    struct = "float.ml",
    sig    = "Stdlib.Float_cmi",
    opts = MODULE_OPTS + ["-nolabels", "-no-alias-deps"],
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib.List",
        ":Stdlib.Array",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Float_cmi",
    src  = "float.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Format",
    struct = "format.ml",
    sig    = "Stdlib.Format_cmi",
    opts = MODULE_OPTS + ["-w", "+A", "-w", "-fragile-match"],
    deps   = [
        ":CamlinternalFormat",
        ":CamlinternalFormatBasics",
        ":Stdlib",
        ":Stdlib.Array",
        ":Stdlib.Buffer",
        ":Stdlib.Bytes",
        ":Stdlib.Domain",
        ":Stdlib.Either",
        ":Stdlib.Int",
        ":Stdlib.List",
        ":Stdlib.Queue",
        ":Stdlib.Seq",
        ":Stdlib.Stack",
        ":Stdlib.String",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Format_cmi",
    src  = "format.mli",
    opts = SIG_OPTS + ["-w", "+A", "-w", "-fragile-match"],
    deps   = [
        ":Stdlib_cmi",
        ":Stdlib.Buffer_cmi",
        ":Stdlib.Domain_cmi",
        ":Stdlib.Either_cmi",
        ":Stdlib.Seq_cmi",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Fun",
    struct = "fun.ml",
    sig    = "Stdlib.Fun_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Printexc",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Fun_cmi",
    src  = "fun.mli",
    opts = SIG_OPTS,
    deps   = [
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Gc",
    struct = "gc.ml",
    sig    = "Stdlib.Gc_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Printf",
        ":Stdlib.Printexc",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Gc_cmi",
    src  = "gc.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Printexc",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Genlex",
    struct = "genlex.ml",
    sig    = "Stdlib.Genlex_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Bytes",
        ":Stdlib.Char",
        ":Stdlib.Hashtbl",
        ":Stdlib.List",
        ":Stdlib.Stream",
        ":Stdlib.String",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Genlex_cmi",
    src  = "genlex.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib",
        ":Stdlib.Stream"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Hashtbl",
    struct = "hashtbl.ml",
    sig    = "Stdlib.Hashtbl_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Array",
        ":Stdlib.Int",
        ":Stdlib.Lazy",
        ":Stdlib.Obj",
        ":Stdlib.Random",
        ":Stdlib.Seq",
        ":Stdlib.String",
        ":Stdlib.Sys",
        # ":CamlinternalLazy",
        ## (MakeSeeded)
        ## (H)
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Hashtbl_cmi",
    src  = "hashtbl.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ## (H)
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.In_channel",
    struct = "in_channel.ml",
    sig    = "Stdlib.In_channel_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Fun"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.In_channel_cmi",
    src  = "in_channel.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Int",
    struct = "int.ml",
    sig    = "Stdlib.Int_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Int_cmi",
    src  = "int.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Int32",
    struct = "int32.ml",
    sig    = "Stdlib.Int32_cmi",
    opts = MODULE_OPTS + ["-no-alias-deps"],
    deps   = [
        # ":Stdlib_cmi",
        ":Stdlib.Sys",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Int32_cmi",
    src  = "int32.mli",
    opts = SIG_OPTS + ["-no-alias-deps"],
    deps   = [
        # ":Stdlib_cmi",
        ":Stdlib.Sys",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Int64",
    struct = "int64.ml",
    sig    = "Stdlib.Int64_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Int64_cmi",
    src  = "int64.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Lazy",
    struct = "lazy.ml",
    sig    = "Stdlib.Lazy_cmi",
    opts = MODULE_OPTS,
    # + select({
    #     mode:native : ["-afl-inst-ratio 0"]
    # })
    deps   = [
        ":Stdlib.Obj",
        ":CamlinternalLazy",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Lazy_cmi",
    src  = "lazy.mli",
    opts = SIG_OPTS,
    deps   = [
        ":CamlinternalLazy",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Lexing",
    struct = "lexing.ml",
    sig    = "Stdlib.Lexing_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Int",
        ":Stdlib.Bytes",
        ":Stdlib.Array",
        ":Stdlib"
    ],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Lexing_cmi",
    src  = "lexing.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib_cmi"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    name   = "Stdlib.List",
    ns    = ":Stdlib",
    struct = "list.ml",
    sig    = "Stdlib.List_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.Seq",
        ":Stdlib.Either",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.List_cmi",
    src  = "list.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib.Either",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.ListLabels",
    struct = "listLabels.ml",
    sig    = "Stdlib.ListLabels_cmi",
    opts = MODULE_OPTS + ["-nolabels", "-no-alias-deps"],
    deps   = [
        ":Stdlib.List",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.ListLabels_cmi",
    src  = "listLabels.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib.Either",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Map",
    struct = "map.ml",
    sig    = "Stdlib.Map_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.List",
        ":Stdlib.Seq",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Map_cmi",
    src  = "map.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Marshal",
    struct = "marshal.ml",
    sig    = "Stdlib.Marshal_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Bytes",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Marshal_cmi",
    src  = "marshal.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.MoreLabels",
    struct = "moreLabels.ml",
    sig    = "Stdlib.MoreLabels_cmi",
    opts = MODULE_OPTS + ["-nolabels", "-no-alias-deps"],
    deps   = [
        ":Stdlib.Set",
        ":Stdlib.Map",
        ":Stdlib.Hashtbl"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.MoreLabels_cmi",
    src  = "moreLabels.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Set",
        ":Stdlib.Seq",
        # ":Stdlib.Ord",
        ":Stdlib.Map",
        ":Stdlib.Hashtbl"
        # H
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Mutex",
    struct = "mutex.ml",
    sig    = "Stdlib.Mutex_cmi",
    opts = MODULE_OPTS + ["-nolabels", "-no-alias-deps"],
    deps   = [
        # ":Stdlib.Set",
        # ":Stdlib.Map",
        # ":Stdlib.Hashtbl"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Mutex_cmi",
    src  = "mutex.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib.Set",
        # ":Stdlib.Seq",
        # # ":Stdlib.Ord",
        # ":Stdlib.Map",
        # ":Stdlib.Hashtbl"
        # # H
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Nativeint",
    struct = "nativeint.ml",
    sig    = "Stdlib.Nativeint_cmi",
    opts = MODULE_OPTS,
    deps   = [
        # ":Stdlib_cmi",
        ":Stdlib.Sys",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Nativeint_cmi",
    src  = "nativeint.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib_cmi",
        ":Stdlib.Sys",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Obj",
    struct = "obj.ml",
    sig    = "Stdlib.Obj_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.Nativeint",
        ":Stdlib.Int32",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Obj_cmi",
    src  = "obj.mli",
    opts = SIG_OPTS,
    deps   = [
        # ":Stdlib_cmi",
        ":Stdlib.Int32",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    name   = "Stdlib.Oo",
    ns    = ":Stdlib",
    struct = "oo.ml",
    sig    = "Stdlib.Oo_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":CamlinternalOO",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    name = "Stdlib.Oo_cmi",
    ns   = ":Stdlib",
    src  = "oo.mli",
    opts = SIG_OPTS + [
        "-no-principal" ## Only place this flag is used
    ],
    deps   = [
        ":CamlinternalOO",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Option",
    struct = "option.ml",
    sig    = "Stdlib.Option_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Option_cmi",
    src  = "option.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Out_channel",
    struct = "out_channel.ml",
    sig    = "Stdlib.Out_channel_cmi",
    opts = MODULE_OPTS,
    deps   = [":Stdlib.Fun"],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Out_channel_cmi",
    src  = "out_channel.mli",
    opts = SIG_OPTS,
    deps   = [":Stdlib"],
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Parsing",
    struct = "parsing.ml",
    sig    = "Stdlib.Parsing_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Obj",
        ":Stdlib.Lexing",
        ":Stdlib.Array",
        ":Stdlib"
    ],
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Parsing_cmi",
    src  = "parsing.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Obj_cmi",
        ":Stdlib.Lexing_cmi",
        # ":Stdlib_cmi"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Pervasives",
    struct = "pervasives.ml",
    opts = MODULE_OPTS,
    deps   = [
        ":CamlinternalFormatBasics",
        ## (LargeFile)
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)
# bootstrap_implicit_signature(
#     name    = "Stdlib.Parsing_cmi",
#     module  = "parsing.ml",
#     visibility = ["//visibility:public"]
# )

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Printexc",
    struct = "printexc.ml",
    sig    = "Stdlib.Printexc_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib",
        ":Stdlib.Array",
        ":Stdlib.Atomic",
        ":Stdlib.Buffer",
        ":Stdlib.Obj",
        ":Stdlib.Printf",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Printexc_cmi",
    src  = "printexc.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Obj_cmi"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Printf",
    struct = "printf.ml",
    sig    = "Stdlib.Printf_cmi",
    opts = MODULE_OPTS + ["-w", "+A", "-w", "-fragile-match"],
    deps   = [
        # ":CamlinternalFormatBasics",
        ":CamlinternalFormat",
        ":Stdlib.Buffer",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Printf_cmi",
    src  = "printf.mli",
    opts = SIG_OPTS + ["-w", "+A", "-w", "-fragile-match"],
    deps   = [
        ":Stdlib.Buffer",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Queue",
    struct = "queue.ml",
    sig    = "Stdlib.Queue_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib",
        ":Stdlib.Seq",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Queue_cmi",
    src  = "queue.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
        # ":Stdlib",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Random",
    struct = "random.ml",
    sig    = "Stdlib.Random_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib",
        ":Stdlib.Array",
        ":Stdlib.Bytes",
        ":Stdlib.Bigarray",
        # ":Stdlib.Char",
        ":Stdlib.Digest",
        ":Stdlib.Domain",
        ":Stdlib.Int",
        ":Stdlib.Int32",
        ":Stdlib.Int64",
        ":Stdlib.Nativeint",
        ":Stdlib.String",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Random_cmi",
    src  = "random.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Nativeint",
        ":Stdlib.Int64",
        ":Stdlib.Int32",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Result",
    struct = "result.ml",
    sig    = "Stdlib.Result_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Seq",
        # ":Stdlib"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Result_cmi",
    src  = "result.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib",
        ":Stdlib.Seq"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Scanf",
    struct = "scanf.ml",
    sig    = "Stdlib.Scanf_cmi",
    opts   = MODULE_OPTS + ["-w", "+A", "-w", "-fragile-match"],
    # + select({
    #     mode:native  ["-inline", 9]
    # })
    deps   = [
        ":CamlinternalFormatBasics",
        ":CamlinternalFormat",
        ":Stdlib.Buffer",
        ":Stdlib.Bytes",
        ":Stdlib.Int",
        ":Stdlib.List",
        ":Stdlib.Printf",
        ":Stdlib.String",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name  = "Stdlib.Scanf_cmi",
    src   = "scanf.mli",
    opts  = SIG_OPTS + [
        "-w", "+A", "-w", "-fragile-match"
    ],
    deps  = [
        ":Stdlib_cmi",
        # ":CamlinternalFormatBasics_cmi",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Semaphore",
    struct = "semaphore.ml",
    sig    = "Stdlib.Semaphore_cmi",
    opts   = MODULE_OPTS,
    # + select({
    #     mode:native  ["-inline", 9]
    # })
    deps   = [
        ":Stdlib.Condition",
        ":Stdlib.Mutex",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name  = "Stdlib.Semaphore_cmi",
    src   = "semaphore.mli",
    opts  = SIG_OPTS,
    deps  = [
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    struct = "seq.ml",
    name   = "Stdlib.Seq",
    sig    = "Stdlib.Seq_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Atomic",
        ":Stdlib.Either",
        ":Stdlib.Lazy"
    ],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Seq_cmi",
    src  = "seq.mli",
    opts = SIG_OPTS,
    deps   = [":Stdlib.Either_cmi"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Set",
    struct = "set.ml",
    sig    = "Stdlib.Set_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib.List",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Set_cmi",
    src  = "set.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Stack",
    struct = "stack.ml",
    sig    = "Stdlib.Stack_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Seq",
        ":Stdlib.List",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Stack_cmi",
    src  = "stack.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.StdLabels",
    struct = "stdLabels.ml",
    sig    = "Stdlib.StdLabels_cmi",
    opts = MODULE_OPTS + ["-nolabels", "-no-alias-deps"],
    deps   = [
        ":Stdlib.StringLabels",
        ":Stdlib.ListLabels",
        ":Stdlib.BytesLabels",
        ":Stdlib.ArrayLabels",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.StdLabels_cmi",
    src  = "stdLabels.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.StringLabels",
        ":Stdlib.ListLabels",
        ":Stdlib.BytesLabels",
        ":Stdlib.ArrayLabels",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Stream",
    struct = "stream.ml",
    sig    = "Stdlib.Stream_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":CamlinternalLazy",
        ":Stdlib.String",
        ":Stdlib.List",
        ":Stdlib.Lazy",
        ":Stdlib.Bytes",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Stream_cmi",
    src  = "stream.mli",
    opts = SIG_OPTS,
    deps   = [
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.String",
    struct = "string.ml",
    sig    = "Stdlib.String_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Bytes",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.String_cmi",
    src  = "string.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Seq_cmi",
        ":Stdlib.Uchar_cmi"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.StringLabels",
    struct = "stringLabels.ml",
    sig    = "Stdlib.StringLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    deps   = [
        ":Stdlib.String",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.StringLabels_cmi",
    src  = "stringLabels.mli",
    opts = SIG_OPTS + LABEL_SIGOPTS,
    deps   = [
        ":Stdlib.Seq_cmi",
        ":Stdlib.Uchar_cmi"
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Sys",
    struct = "sys.ml",
    # sig    = "Stdlib.Sys_cmi",
    sig    = select({
        "//config:sig_src?"   : "sys.mli",
        "//conditions:default": ":Stdlib.Sys_cmi"
    }),
    deps    = select({
        "//config:sig_src?"   : ["//stdlib:Stdlib"],
        "//conditions:default": []
    }),
    opts = MODULE_OPTS,
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Sys_cmi",
    src  = "sys.mli",
    opts = SIG_OPTS,
    deps = [":Stdlib"],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Uchar",
    struct = "uchar.ml",
    sig    = "Stdlib.Uchar_cmi",
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Char",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Uchar_cmi",
    src  = "uchar.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Char",
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Unit",
    struct = "unit.ml",
    # sig    = "Stdlib.Unit_cmi",
    ## NOTE: compiling with --//config:sig_src requires
    ## "//stdlib:Stdlib" in deps
    sig    = select({
        "//config:sig_src?"   : "unit.mli",
        "//conditions:default": "Stdlib.Unit_cmi"
    }),
    deps    = select({
        "//config:sig_src?"   : ["//stdlib:Stdlib"],
        "//conditions:default": []
    }),
    opts = MODULE_OPTS,
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Unit_cmi",
    src  = "unit.mli",
    opts = SIG_OPTS,
    deps   = [
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_module(
    ns    = ":Stdlib",
    name   = "Stdlib.Weak",
    struct = "weak.ml",
    # sig    = "Stdlib.Weak_cmi",
    sig    = select({
        "//config:sig_src?"   : "weak.mli",
        "//conditions:default": ":Stdlib.Weak_cmi"
    }),
    opts = MODULE_OPTS,
    deps   = [
        ":Stdlib.Sys",
        ":Stdlib.Obj",
        ":Stdlib.Int",
        ":Stdlib.Array",
        ":Stdlib.Hashtbl",
        ## (H)
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

boot_signature(
    ns   = ":Stdlib",
    name = "Stdlib.Weak_cmi",
    src  = "weak.mli",
    opts = SIG_OPTS,
    deps   = [
        ":Stdlib.Hashtbl",
        ## (H)
    ],
    data = ["//runtime:primitives"],
    # visibility = ["//visibility:public"]
)

################################################################
# HEADERPROGRAM = header
# HEADER_PATH = $(BINDIR)/
# HEADER_TARGET_PATH = $(TARGET_BINDIR)/
# TARGETHEADERPROGRAM = target_$(HEADERPROGRAM)

## on systems that support hashbang scripts, emits a hashbang header,
## e.g. '#!/usr/local/bin/ocamlrun', or does something I don't
## understand involving ocamlrun.

## on systems that do not support hashbang shell scripts, Makefile
## compiles header.c to tmpheader.exe, etc...

## so for PoC purposes we just emit a hard-coded shebang

## camlheader is required for compiling a bytecode executable. to get
## it into the deps list we add it to deps_runtime of stdlib.ml, until we
## figure out how best to do this.

## use --stamp and --workspace_status_command
## see .bazelrc, bzl/camlheader.sh

## FIXME: default uses sys install locn, e.g. /usr/local/bin/ocamlrun
## for dev, use path to internal dev ocamlrun instead

# stdlib/Makefile:
# $(HEADERPROGRAM)%$(O): \
#   OC_CPPFLAGS += -DRUNTIME_NAME='"$(HEADER_PATH)ocamlrun$(subst .,,$*)"'


SYSPATHS_CMD = " ".join([
    "cat bazel-out/stable-status.txt | ",
    "grep \"STABLE_CAMLHEADER \" | ",
    "cut -d ' ' -f 2 - ",
    "> $(location camlheader);",

        "cat bazel-out/stable-status.txt | ",
    "grep \"STABLE_TARGET_CAMLHEADER \" | ",
    "cut -d ' ' -f 2 - ",
    "> $(location target_camlheader);",

        "cat bazel-out/stable-status.txt | ",
    "grep \"STABLE_CAMLHEADERD \" | ",
    "cut -d ' ' -f 2 - ",
    "> $(location camlheaderd);",

        "cat bazel-out/stable-status.txt | ",
    "grep STABLE_TARGET_CAMLHEADERD | ",
    "cut -d ' ' -f 2 - ",
    "> $(location target_camlheaderd);",

        "cat bazel-out/stable-status.txt | ",
    "grep \"STABLE_CAMLHEADERI \" | ",
    "cut -d ' ' -f 2 - ",
    "> $(location camlheaderi);",

        "cat bazel-out/stable-status.txt | ",
    "grep \"STABLE_TARGET_CAMLHEADERI \" | ",
    "cut -d ' ' -f 2 - ",
    "> $(location target_camlheaderi);",
])

## IMPORTANT! For this to work, the following cli args must be passed:
# --stamp
# --workspace_status_command=$PWD/bzl/camlheader.sh
DEVPATHS_CMD = "\n".join([
    "cat bazel-out/stable-status.txt | ",
    "while read KEY VAL; do",
    "if [ $$KEY = \"STABLE_WORKSPACE_ROOT\" ]; then\n",
    "echo '#!'$$VAL/$(execpath //boot/bin:ocamlrun) > $(location camlheader);\n",
    "echo '#!'$$VAL/$(execpath //boot/bin:ocamlrun)d > $(location camlheaderd);\n",
    "echo '#!'$$VAL/$(execpath //boot/bin:ocamlrun)i > $(location camlheaderi);\n",
    "fi",
    "done",

    "echo '#!$(execpath //boot/bin:ocamlrun)' > $(location target_camlheader);",
    "echo '#!$(execpath //boot/bin:ocamlrun)d' > $(location target_camlheaderd);",
    "echo '#!$(execpath //boot/bin:ocamlrun)i' > $(location target_camlheaderi);",
])

genrule(
    name = "camlheaders",
    outs = [
        "camlheader",
        "camlheaderd",
        "camlheaderi",
        # "camlheader_ur",
        "target_camlheader",
        "target_camlheaderd",
        "target_camlheaderi"
    ],
    # srcs = [
    #     "//boot/bin:ocamlrun",
    #     "//bzl/toolchain:ocamlrun"
    # ],
    srcs = [
        "//boot/bin:ocamlrun",
        "//bzl/toolchain:ocamlrun"
    ],
    cmd = DEVPATHS_CMD,
    stamp = True,
    visibility = ["//visibility:public"]
)

################################################################
## cmigroup used by `//promote` targets
# filegroup(
#     name = "cmigroup",
#     srcs = [
#         ":Stdlib.Arg_cmi",
#         ":Stdlib.ArrayLabels_cmi",
#         ":Stdlib.Array_cmi",
#         ":Stdlib.Atomic_cmi",
#         ":Stdlib.Bigarray_cmi",
#         ":Stdlib.Bool_cmi",
#         ":Stdlib.Buffer_cmi",
#         ":Stdlib.BytesLabels_cmi",
#         ":Stdlib.Bytes_cmi",
#         ":Stdlib.Callback_cmi",
#         ":CamlinternalFormatBasics_cmi",
#         ":CamlinternalFormat_cmi",
#         ":CamlinternalLazy_cmi",
#         ":CamlinternalMod_cmi",
#         ":CamlinternalOO_cmi",
#         ":Stdlib.Char_cmi",
#         ":Stdlib.Complex_cmi",
#         ":Stdlib.Condition_cmi",
#         ":Stdlib.Digest_cmi",
#         ":Stdlib.Either_cmi",
#         ":Stdlib.Ephemeron_cmi",
#         ":Stdlib.Filename_cmi",
#         ":Stdlib.Float_cmi",
#         ":Stdlib.Format_cmi",
#         ":Stdlib.Fun_cmi",
#         ":Stdlib.Gc_cmi",
#         ":Stdlib.Hashtbl_cmi",
#         ":Stdlib.In_channel_cmi",
#         ":Stdlib.Int32_cmi",
#         ":Stdlib.Int64_cmi",
#         ":Stdlib.Int_cmi",
#         ":Stdlib.Lazy_cmi",
#         ":Stdlib.Lexing_cmi",
#         ":Stdlib.ListLabels_cmi",
#         ":Stdlib.List_cmi",
#         ":Stdlib.Map_cmi",
#         ":Stdlib.Marshal_cmi",
#         ":Stdlib.MoreLabels_cmi",
#         ":Stdlib.Mutex_cmi",
#         ":Stdlib.Nativeint_cmi",
#         ":Stdlib.Obj_cmi",
#         ":Stdlib.Oo_cmi",
#         ":Stdlib.Option_cmi",
#         ":Stdlib.Out_channel_cmi",
#         ":Stdlib.Parsing_cmi",
#         ":Stdlib.Printexc_cmi",
#         ":Stdlib.Printf_cmi",
#         ":Stdlib.Queue_cmi",
#         ":Stdlib.Random_cmi",
#         ":Stdlib.Result_cmi",
#         ":Stdlib.Scanf_cmi",
#         ":Stdlib.Semaphore_cmi",
#         ":Stdlib.Seq_cmi",
#         ":Stdlib.Set_cmi",
#         ":Stdlib.Stack_cmi",
#         ":Stdlib.StdLabels_cmi",
#         ":Stdlib.StringLabels_cmi",
#         ":Stdlib.String_cmi",
#         ":Stdlib.Sys_cmi",
#         ":Stdlib.Uchar_cmi",
#         ":Stdlib.Unit_cmi",
#         ":Stdlib.Weak_cmi",
#     ],
#     visibility = ["//promote:__pkg__"]
# )
