load("//bzl:rules.bzl",
     "compiler_library",
     )

load("//vendor/mustach:BUILD_RULES.bzl", "mustache")

load(":BUILD_RULES.bzl",
     "kernel_module", "kernel_module_cmx",
     "kernel_signature",
     "stdlib_library",
     "stdlib_library_cmxa",
     "stdlib_internal_signature",
     "stdlib_internal_module",
     "stdlib_module",
     "stdlib_signature")

load(":BUILD_STDLIB.bzl", "STDLIB_MANIFEST")

package(default_visibility = ["//visibility:public"])

exports_files(["expand_module_aliases.awk", "weak.ml", "weak.mli"])

MODULE_OPTS = []
SIG_OPTS    = []

LABEL_OPTS = ["-nolabels"]

# Std_exit is at the bottom of this file.


## NB: we do not need to define an ocaml_ns_resolver (or rather
## bootstrap_ns_resolver), since Stdlib serves as our ns_resolver
## module. Each submodule includes itself by attribution ns=":Stdlib".
## This target just aggregates the resolver and submodules.
## They can be listed in any order.

# WARNING: compiler is hard-coded to expect stdlib.cma if -pervasives

stdlib_library(
    name       = "stdlib",
    cmxa_eligible = True,
    # opts = ["-linkall"],
    ## makefiles pass -use-prims. does that make sense, for an archive?
    manifest   = STDLIB_MANIFEST,
    # data = ["//runtime:asmrun"],
    visibility = ["//visibility:public"],
)

stdlib_library_cmxa(
    name       = "stdlib.cmxa",
    # opts = ["-verbose"],
    ## makefiles pass -use-prims. does that make sense, for an archive?
    manifest   = STDLIB_MANIFEST,
    # data = ["//runtime:asmrun"],
    visibility = ["//visibility:public"],
)

## We use several different rules:

# stdlib_kernel_[module|signature] - for Stdlib, Std_exit and
# CamlinternalFormatBasics only. These are not in the ns but the
# submodules of the ns depend on them; they "bootstrap" the ns.

# (I.e. 'stdlib_boot_' corresponds to 'Camlinternal')

# stdlib_[module|signature] for the submodules of the Stdlib namespace.

# That leaves four modules that are not in the Stdlib
# namespace, but that depend on submodules, and are depended on by
# submodules. These are the Camlinternal* modules. The use the
# stdlib_internal_* rules but pass '-open Stdlib' explicitly.

##################################################################
##############  Main Resolver Module: Stdlib  ####################
# The resolver is not itself a member of the namespace; it does not
# depend on itself! So it can build independently of stdlib.cma.

#stdlib_resolver(
alias(name = "Primitives", actual = ":Stdlib")
kernel_module(
    name   = "Stdlib",
    struct = "stdlib_ml",
    sig    = "Stdlib_cmi", # doesn't work with stdlib.mli
    # use_prims = True,
    opts = ["-nopervasives", "-no-alias-deps"],
    warnings = {"disable": ["no-cmi-file"]}, # 49
    stdlib_deps = [":CamlinternalFormatBasics",],
)

# WARNING: if we run this as a separate task (instead of passing the
# cmd to the compiler via -pp) we must write to a subdir, since the
# input filename is the same as the output filename. Ditto for
# stdlib.mli.

mustache(
    name = "stdlib_ml",
    out  = "stdlib.ml",
    json = "stdlib.json",
    template = "stdlib.ml.mustache"
)

alias(name = "Primitives_cmi", actual = ":Stdlib_cmi")
kernel_signature(
    name = "Stdlib_cmi",
    src  = "stdlib.mli",
    opts = ["-nopervasives", "-no-alias-deps"],
    warnings = {"disable": ["no-cmi-file"]}, # 49
    stdlib_deps   = [
        ":CamlinternalFormatBasics_cmi",
    ],
)

mustache(
    name = "stdlib_mli",
    out  = "stdlib.mli",
    json = "stdlib.json",
    template = "stdlib.mli.mustache"
)

# genrule(
#     name = "stdlib_ml_awk",
#     outs = ["stdlib.ml"], ## FIXME
#     srcs = ["stdlib.raw.ml", "//stdlib:expand_module_aliases.awk"],
#     cmd_bash  = " ".join([
#         "awk -f $(location //stdlib:expand_module_aliases.awk)",
#         "$(location :stdlib.raw.ml)",
#         "> $@"
#     ]),
# )

# bootstrap_preprocess(
#     name = "stdlib_ml_awk",
#     outs = ["stdlib.ml"],
#     srcs = ["stdlib.ml", "//stdlib:expand_module_aliases.awk"],
#     cmd_bash  = " ".join([
#         "awk -f $(location //stdlib:expand_module_aliases.awk) $(location :stdlib.ml)",
#         "> $@"
#     ]),
# )

# genrule(
#     name = "stdlib_mli_awk",
#     outs = ["stdlib.mli"],
#     srcs = ["stdlib.raw.mli", "//stdlib:expand_module_aliases.awk"],
#     cmd_bash  = " ".join([
#         "awk -f $(location //stdlib:expand_module_aliases.awk)",
#         "$(location :stdlib.raw.mli)",
#         "> $@"
#     ]),
# )

################################################################
############  Non-namespaced Components of Stdlib ##############

## these contain "primitives?"

compiler_library(
    name = "primitives",
    manifest = [
        "CamlinternalFormat",
        "CamlinternalFormatBasics",
        "CamlinternalLazy",
        "CamlinternalMod",
        "CamlinternalOO",
    ]
)

## camlinternal* modules:
# All are in the Stdlib archive but none are in the Stdlib ns.
# Atomic and FormatBasic are deps of the nslib but do not depend on
# any other modules.
# The other camlinternal* are submodules but they are not renamed.
# They depend on other subcomponents, but since they are not renamed
# such deps must not be listed; instead just list :Stdlib.

kernel_module(
    name   = "CamlinternalFormatBasics",
    struct = "camlinternalFormatBasics.ml",
    sig    = "CamlinternalFormatBasics_cmi",
    opts   = ["-nopervasives"]
    # sig    = select({
    #     "//config:sig_src?": "camlinternalFormatBasics.mli",
    #     "//conditions:default": "CamlinternalFormatBasics_cmi",
    # }),
)

kernel_signature(
    name = "CamlinternalFormatBasics_cmi",
    src  = "camlinternalFormatBasics.mli",
    opts   = ["-nopervasives"]
 )


stdlib_internal_module(
    name   = "CamlinternalFormat",
    struct = "camlinternalFormat.ml",
    sig    = "CamlinternalFormat_cmi",
    warnings = {"disable": ["fragile-match"]},
    stdlib_deps   = [
        ":CamlinternalFormatBasics",
        ":Stdlib.Buffer",
        ":Stdlib.Bytes",
        ":Stdlib.Char",
        ":Stdlib.Int",
        ":Stdlib.Sys",
        ":Stdlib.String",
    ],
)

stdlib_internal_signature(
    name = "CamlinternalFormat_cmi",
    src  = "camlinternalFormat.mli",
    warnings = {"disable": ["fragile-match"]},
    stdlib_deps   = [
        ":CamlinternalFormatBasics_cmi",

        # Depends on Buffer, but we need to go through the ns Stdlib.
        # The problem is we cannot express a dependency on an ns
        # submodule using a namespaced symbol like ":Stdlib.Buffer";
        # we can only depend on build targets.

        # Depending directly on :Buffer cause it (and its deps) to be
        # built w/o namespacing, so we'll have the same stuff built
        # with and without namespacing. Which is bad.
        ":Stdlib.Buffer_cmi",

        # :Stdlib (the resolver) itself is not renamed, but it
        # contains the alias for Buffer => Stdlib__Buffer. We get:
        ## "Error: The module Buffer is an alias for module
        ##  Stdlib__Buffer, which is missing."
        # ":Stdlib",

        # That's because the Stdlib (resolver) module, unlike the NS
        # lib, does not depend on the submodules, because it is
        # compiled with '-no-alias-deps'. So they do not get built
        # unless the NS target is built. But we cannot depend on
        # :ocaml-stdlib on pain of circularity.

        # What we need is to make CamlinternalFormat a component but
        # not a submodule of the namespace, without renaming. Then we
        # could list sibling deps directly.
    ],
)

stdlib_internal_module(
    name   = "CamlinternalLazy",
    struct = "camlinternalLazy.ml",
    sig    = select({
        "//config:sig_src?": "camlinternalLazy.mli",
        "//conditions:default": "CamlinternalLazy_cmi"
    }),
    opts   = select({
        ##FIXME: detect target .cmx or .cmo
        # "//config/target/emitter:sys_emitter?": [
        #     "-afl-inst-ratio", "0"
        # ],
        "//conditions:default": []
    }),
    stdlib_deps   = [
        ":Stdlib.Obj",
        ":Stdlib.Sys",
    ],
)

stdlib_internal_signature(
    name = "CamlinternalLazy_cmi",
    src  = "camlinternalLazy.mli",
    stdlib_deps = [":Stdlib_cmi"]
)

stdlib_internal_module(
    name   = "CamlinternalMod",
    struct = "camlinternalMod.ml",
    sig    = "CamlinternalMod_cmi",
    warnings = {"disable": ["fragile-match"]},
    stdlib_deps   = [
        ":CamlinternalOO", ## (CamlinternalOO)
        ":CamlinternalLazy", ## (CamlinternalOO)
        ":Stdlib.Obj", ## (Stdlib Obj)
        ":Stdlib.Lazy", ## (Stdlib Lazy)
        ":Stdlib.Array", ## (Stdlib Array)
    ],
)

stdlib_internal_signature(
    name = "CamlinternalMod_cmi",
    src  = "camlinternalMod.mli",
    # opts = ["-nopervasives", "-open", "Stdlib"],
    stdlib_deps   = [
        ":Stdlib_cmi",
        ":Stdlib.Obj_cmi",
    ],
)

stdlib_internal_module(
    name   = "CamlinternalOO",
    struct = "camlinternalOO.ml",
    sig    = "CamlinternalOO_cmi",
    opts   = select({
        ##FIXME: detect target .cmx or .cmo
        # "//config/target/emitter:sys_emitter?": [
        #     "-inline", "0",
        #     "-afl-inst-ratio", "0"
        # ],
        "//conditions:default": []
    }),
    warnings = {"disable": ["ambiguous-name"]},
    stdlib_deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Obj",
        ":Stdlib.List",
        ":Stdlib.Char",
        ":Stdlib.Array",
        ":Stdlib.Map"
    ],
)

stdlib_internal_signature(
    name = "CamlinternalOO_cmi",
    src  = "camlinternalOO.mli",
    stdlib_deps   = [":Stdlib_cmi", ":Stdlib.Obj_cmi"]
)

#########################################################
################  Namespaced Submodules  ################

stdlib_module(
    name   = "Stdlib.Arg",
    struct = "arg.ml",
    sig    = "Stdlib.Arg_cmi",
    opts = MODULE_OPTS,
    warnings = {"disable": ["fragile-match"]},
    stdlib_deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Printf",
        ":Stdlib.List",
        ":Stdlib.Int",
        ":Stdlib.Buffer",
        ":Stdlib.Array",
    ],
)

stdlib_signature(
    name = "Stdlib.Arg_cmi",
    src  = "arg.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Sys_cmi",
        ":Stdlib.String_cmi",
        ":Stdlib.Printf_cmi",
        ":Stdlib.List_cmi",
        ":Stdlib.Int_cmi",
        ":Stdlib.Buffer_cmi",
        ":Stdlib.Array_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.Array",
    struct = "array.ml",
    sig    = "Stdlib.Array_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Seq",
    ],
)

stdlib_signature(
    name = "Stdlib.Array_cmi",
    src  = "array.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Seq_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.ArrayLabels",
    struct = "arrayLabels.ml",
    sig    = "Stdlib.ArrayLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    stdlib_deps   = [
        ":Stdlib.Array"
    ],
)

stdlib_signature(
    name = "Stdlib.ArrayLabels_cmi",
    src  = "arrayLabels.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Seq_cmi",
    ],
)

mustache(
    name = "arraymli",
    out  = "array.mli",
    json = "empty.json",
    template = "array.mli.mustache"
)

mustache(
    name = "arrayLabelsmli",
    out  = "arrayLabels.mli",
    json = "LABELS.json",
    template = "array.mli.mustache"
)

## WARNING: the purpose of 'expand_module_aliases.awk' in this
## context is replace the '@since' decls; e.g.
## from @since 4.03 (4.05 in ArrayLabels) to @since 4.05
# genrule(
#     name = "array_labels_mli_awk",
#     outs = ["arrayLabels.mli"],
#     srcs = ["arrayLabels.raw.mli", "//stdlib:expand_module_aliases.awk"],
#     cmd_bash  = " ".join([
#         "awk -f $(location //stdlib:expand_module_aliases.awk)",
#         "$(location :arrayLabels.raw.mli)",
#         "> $@"
#     ]),
# )

stdlib_module(
    struct = "atomic.ml",
    name   = "Stdlib.Atomic",
    sig    = "Stdlib.Atomic_cmi",
    stdlib_deps   = [":Stdlib"]
)

stdlib_signature(
    name = "Stdlib.Atomic_cmi",
    src  = "atomic.mli",
)

stdlib_module(
    name   = "Stdlib.Bigarray",
    struct = "bigarray.ml",
    sig    = "Stdlib.Bigarray_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Sys",
        ":Stdlib.Complex",
        ":Stdlib.Array",
        ## (Genarray)
        ## (Array3)
        ## (Array2)
        ## (Array1)
        ## (Array0)
    ],
)

stdlib_signature(
    name = "Stdlib.Bigarray_cmi",
    src  = "bigarray.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib_cmi",
        ":Stdlib.Complex_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.Bool",
    struct = "bool.ml",
    sig    = "Stdlib.Bool_cmi",
    opts   = MODULE_OPTS,
    stdlib_deps   = [":Stdlib"]
)

stdlib_signature(
    name = "Stdlib.Bool_cmi",
    src  = "bool.mli",
    opts = SIG_OPTS,
)

stdlib_module(
    name   = "Stdlib.Buffer",
    struct = "buffer.ml",
    sig    = "Stdlib.Buffer_cmi",
    opts   = select({
        ##FIXME: detect target .cmx or .cmo
        # "//config/target/emitter:sys_emitter?": ["-inline", "3"],
        # "//config/target/emitter:vm_emitter?": ["-w", "+A"],
        "//conditions:default": []
    }),
    stdlib_deps   = [
        ":Stdlib.Bytes",
        ":Stdlib.Seq",
        ":Stdlib.String",
        ":Stdlib.Sys",
    ],
)

stdlib_signature(
    name = "Stdlib.Buffer_cmi",
    src  = "buffer.mli",
    opts   = select({
        "//config/target/executor:vm_executor?": ["-w", "+A"],
        "//conditions:default": []
    }),
    stdlib_deps   = [
        ":Stdlib.Uchar_cmi",
        ":Stdlib.Seq_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.Bytes",
    struct = "bytes.ml",
    sig    = "Stdlib.Bytes_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Char",
        ":Stdlib.Int",
        ":Stdlib.Seq",
        ":Stdlib.Sys",
        ":Stdlib.Uchar",
    ],
)

stdlib_signature(
    name = "Stdlib.Bytes_cmi",
    src  = "bytes.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Int_cmi",
        ":Stdlib.Seq_cmi",
        ":Stdlib.Uchar_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.BytesLabels",
    struct = "bytesLabels.ml",
    sig    = "Stdlib.BytesLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    stdlib_deps   = [
        ":Stdlib.Bytes",
    ],
)

stdlib_signature(
    name = "Stdlib.BytesLabels_cmi",
    src  = "bytesLabels.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Seq_cmi",
        ":Stdlib.Uchar_cmi"
    ],
)

mustache(
    name = "bytesmli",
    out  = "bytes.mli",
    json = "empty.json",
    template = "bytes.mli.mustache"
)

mustache(
    name = "bytesLabelsmli",
    out  = "bytesLabels.mli",
    json = "LABELS.json",
    template = "bytes.mli.mustache"
)

stdlib_module(
    name   = "Stdlib.Callback",
    struct = "callback.ml",
    sig    = "Stdlib.Callback_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Obj"
    ],
)

stdlib_signature(
    name = "Stdlib.Callback_cmi",
    src  = "callback.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.In_channel_cmi"]
)

stdlib_module(
    name   = "Stdlib.Char",
    struct = "char.ml",
    sig    = "Stdlib.Char_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [":Stdlib"],
)

stdlib_signature(
    name = "Stdlib.Char_cmi",
    src  = "char.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib_cmi"],
)

stdlib_module(
    name   = "Stdlib.Complex",
    struct = "complex.ml",
    sig    = "Stdlib.Complex_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = ["Stdlib.Float"],
)

stdlib_signature(
    name = "Stdlib.Complex_cmi",
    src  = "complex.mli",
    opts = SIG_OPTS,
)

stdlib_module(
    name   = "Stdlib.Condition",
    struct = "condition.ml",
    sig    = "Stdlib.Condition_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [":Stdlib.Mutex"],
)

stdlib_signature(
    name = "Stdlib.Condition_cmi",
    src  = "condition.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib_cmi",
        ":Stdlib.Mutex_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.Digest",
    struct = "digest.ml",
    sig    = "Stdlib.Digest_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.String",
        ":Stdlib.Char",
        ":Stdlib.Bytes",
    ],
)

stdlib_signature(
    name = "Stdlib.Digest_cmi",
    src  = "digest.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.In_channel_cmi"]
)

stdlib_module(
    name   = "Stdlib.Domain",
    struct = "domain.ml",
    sig    = "Stdlib.Domain_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib",
        "Stdlib.Array",
        "Stdlib.Atomic",
        "Stdlib.Condition",
        "Stdlib.List",
        "Stdlib.Mutex",
        "Stdlib.Obj",
        "Stdlib.Sys",
    ],
)

stdlib_signature(
    name = "Stdlib.Domain_cmi",
    src  = "domain.mli",
    opts = SIG_OPTS,
)

stdlib_module(
    name   = "Stdlib.Effect",
    struct = "effect.ml",
    sig    = "Stdlib.Effect_cmi",
    opts = MODULE_OPTS,
    warnings = {"disable": ["ambiguous-name"]}, # 41
    stdlib_deps   = [
        "Stdlib.Callback",
        "Stdlib.Obj",
        "Stdlib.Printexc",
        "Stdlib.Printf",
    ],
)

stdlib_signature(
    name = "Stdlib.Effect_cmi",
    src  = "effect.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Printexc_cmi"],
)

stdlib_module(
    name   = "Stdlib.Either",
    struct = "either.ml",
    sig    = "Stdlib.Either_cmi",
)

stdlib_signature(
    name = "Stdlib.Either_cmi",
    src  = "either.mli",
    # stdlib_primitives = True
)

stdlib_module(
    name   = "Stdlib.Ephemeron",
    struct = "ephemeron.ml",
    sig    = "Stdlib.Ephemeron_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Array",
        ":Stdlib.Hashtbl",
        ":Stdlib.Int",
        ":Stdlib.Lazy",
        ":Stdlib.List",
        ":Stdlib.Obj",
        ":Stdlib.Random",
        ":Stdlib.Seq",
        ":Stdlib.Sys",
    ],
)

stdlib_signature(
    name = "Stdlib.Ephemeron_cmi",
    src  = "ephemeron.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Hashtbl_cmi"]
)

stdlib_module(
    name   = "Stdlib.Filename",
    struct = "filename.ml",
    sig    = "Stdlib.Filename_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Buffer",
        ":Stdlib.Domain",
        ":Stdlib.Fun",
        ":Stdlib.List",
        ":Stdlib.Printf",
        ":Stdlib.Random",
        ":Stdlib.String",
        ":Stdlib.Sys",
    ],
)

stdlib_signature(
    name = "Stdlib.Filename_cmi",
    src  = "filename.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib_cmi"],
)

stdlib_module(
    name   = "Stdlib.Float",
    struct = "float.ml",
    sig    = "Stdlib.Float_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    stdlib_deps   = [
        ":Stdlib.Seq",
        ":Stdlib.List",
        ":Stdlib.Array",
    ],
)

stdlib_signature(
    name = "Stdlib.Float_cmi",
    src  = "float.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Seq_cmi",
        ":Stdlib_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.Format",
    struct = "format.ml",
    sig    = "Stdlib.Format_cmi",
    opts = select({
        "//config/target/executor:vm_executor?": [],
        "//conditions:default": []
    }),
    warnings = {"disable": ["fragile-match"]},
    stdlib_deps   = [
        ":CamlinternalFormat",
        ":CamlinternalFormatBasics",
        ":Stdlib",
        ":Stdlib.Array",
        ":Stdlib.Buffer",
        ":Stdlib.Bytes",
        ":Stdlib.Domain",
        ":Stdlib.Either",
        ":Stdlib.Int",
        ":Stdlib.List",
        ":Stdlib.Queue",
        ":Stdlib.Seq",
        ":Stdlib.Stack",
        ":Stdlib.String",
    ],
)

stdlib_signature(
    name = "Stdlib.Format_cmi",
    src  = "format.mli",
    opts = select({
        "//config/target/executor:vm_executor?": ["-w", "+A"],
        "//conditions:default": []
    }),
    warnings = select({
        "//config/target/executor:vm_executor?":
        {"disable": ["fragile-match"]},
        "//conditions:default": {}
    }),
    stdlib_deps   = [
        ":Stdlib_cmi",
        ":Stdlib.Buffer_cmi",
        ":Stdlib.Domain_cmi",
        ":Stdlib.Either_cmi",
        ":Stdlib.Seq_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.Fun",
    struct = "fun.ml",
    sig    = "Stdlib.Fun_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Printexc",
    ],
)

stdlib_signature(
    name = "Stdlib.Fun_cmi",
    src  = "fun.mli",
    opts = SIG_OPTS,
)

stdlib_module(
    name   = "Stdlib.Gc",
    struct = "gc.ml",
    sig    = "Stdlib.Gc_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Printf",
        ":Stdlib.Printexc",
    ],
)

stdlib_signature(
    name = "Stdlib.Gc_cmi",
    src  = "gc.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Printexc_cmi"]
)

stdlib_module(
    name   = "Stdlib.Genlex",
    struct = "genlex.ml",
    sig    = "Stdlib.Genlex_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Bytes",
        ":Stdlib.Char",
        ":Stdlib.Hashtbl",
        ":Stdlib.List",
        ":Stdlib.Stream",
        ":Stdlib.String",
    ],
)

stdlib_signature(
    name = "Stdlib.Genlex_cmi",
    src  = "genlex.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Stream_cmi"]
)

stdlib_module(
    name   = "Stdlib.Hashtbl",
    struct = "hashtbl.ml",
    sig    = "Stdlib.Hashtbl_cmi",
    opts = MODULE_OPTS,
    warnings = {"disable": ["missing-record-field-pattern"]},
    stdlib_deps   = [
        ":Stdlib.Array",
        ":Stdlib.Int",
        ":Stdlib.Lazy",
        ":Stdlib.Obj",
        ":Stdlib.Random",
        ":Stdlib.Seq",
        ":Stdlib.String",
        ":Stdlib.Sys",
    ],
)

stdlib_signature(
    name = "Stdlib.Hashtbl_cmi",
    src  = "hashtbl.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Seq_cmi"]
)

mustache(
    name = "hashtbl_mli",
    out  = "hashtbl.mli",
    json = "empty.json",
    template = "hashtbl.mli.mustache"
)

stdlib_module(
    name   = "Stdlib.In_channel",
    struct = "in_channel.ml",
    sig    = "Stdlib.In_channel_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Fun"
    ],
)

stdlib_signature(
    name = "Stdlib.In_channel_cmi",
    src  = "in_channel.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib_cmi"]
)

stdlib_module(
    name   = "Stdlib.Int",
    struct = "int.ml",
    sig    = "Stdlib.Int_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [":Primitives"],
)

stdlib_signature(
    name = "Stdlib.Int_cmi",
    src  = "int.mli",
    # opts = ["-nopervasives"],
)

stdlib_module(
    name   = "Stdlib.Int32",
    struct = "int32.ml",
    sig    = "Stdlib.Int32_cmi",
    stdlib_deps   = [
        ":Stdlib",
        ":Stdlib.Sys",
    ],
)

stdlib_signature(
    name = "Stdlib.Int32_cmi",
    src  = "int32.mli",
    stdlib_deps   = [":Primitives_cmi"]
)

stdlib_module(
    name   = "Stdlib.Int64",
    struct = "int64.ml",
    sig    = "Stdlib.Int64_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib",
    ],
)

stdlib_signature(
    name = "Stdlib.Int64_cmi",
    src  = "int64.mli",
    opts = SIG_OPTS,
)

stdlib_module(
    name   = "Stdlib.Lazy",
    struct = "lazy.ml",
    sig    = "Stdlib.Lazy_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Obj",
        ":CamlinternalLazy",
    ],
)

stdlib_signature(
    name = "Stdlib.Lazy_cmi",
    src  = "lazy.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":CamlinternalLazy_cmi"]
)

stdlib_module(
    name   = "Stdlib.Lexing",
    struct = "lexing.ml",
    sig    = "Stdlib.Lexing_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Sys",
        ":Stdlib.String",
        ":Stdlib.Int",
        ":Stdlib.Bytes",
        ":Stdlib.Array",
        ":Stdlib"
    ],
)

stdlib_signature(
    name = "Stdlib.Lexing_cmi",
    src  = "lexing.mli",
    opts = SIG_OPTS,
    stdlib_deps = [":Stdlib_cmi"]
)

stdlib_module(
    name   = "Stdlib.List",
    struct = "list.ml",
    sig    = "Stdlib.List_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Sys",
        ":Stdlib.Seq",
        ":Stdlib.Either",
    ],
)

stdlib_signature(
    name = "Stdlib.List_cmi",
    src  = "list.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Seq_cmi",
        ":Stdlib.Either_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.ListLabels",
    struct = "listLabels.ml",
    sig    = "Stdlib.ListLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    stdlib_deps   = [
        ":Stdlib.List",
    ],
)

stdlib_signature(
    name = "Stdlib.ListLabels_cmi",
    src  = "listLabels.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Seq_cmi",
        ":Stdlib.Either_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.Map",
    struct = "map.ml",
    sig    = "Stdlib.Map_cmi",
    opts = MODULE_OPTS,
    warnings = {
        "disable": [
            "fragile-match",
            "missing-record-field-pattern"
        ]
    },
    stdlib_deps   = [
        ":Stdlib.List",
        ":Stdlib.Seq",
    ],
)

stdlib_signature(
    name = "Stdlib.Map_cmi",
    src  = "map.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Seq_cmi"]
)

stdlib_module(
    name   = "Stdlib.Marshal",
    struct = "marshal.ml",
    sig    = "Stdlib.Marshal_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Bytes",
    ],
)

stdlib_signature(
    name = "Stdlib.Marshal_cmi",
    src  = "marshal.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib_cmi"]
)

stdlib_module(
    name   = "Stdlib.MoreLabels",
    struct = "moreLabels.ml",
    sig    = "Stdlib.MoreLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    stdlib_deps   = [
        ":Stdlib.Set",
        ":Stdlib.Map",
        ":Stdlib.Hashtbl"
    ],
)

stdlib_signature(
    name = "Stdlib.MoreLabels_cmi",
    src  = "moreLabels.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Set_cmi",
        ":Stdlib.Seq_cmi",
        ":Stdlib.Map_cmi",
        ":Stdlib.Hashtbl_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.Mutex",
    struct = "mutex.ml",
    sig    = "Stdlib.Mutex_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        # ":Stdlib.Set",
        # ":Stdlib.Map",
        # ":Stdlib.Hashtbl"
    ],
)

stdlib_signature(
    name = "Stdlib.Mutex_cmi",
    src  = "mutex.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib_cmi"]
)

stdlib_module(
    name   = "Stdlib.Nativeint",
    struct = "nativeint.ml",
    sig    = "Stdlib.Nativeint_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        # ":Stdlib_cmi",
        ":Stdlib.Sys",
    ],
)

stdlib_signature(
    name = "Stdlib.Nativeint_cmi",
    src  = "nativeint.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Sys_cmi"]
)

stdlib_module(
    name   = "Stdlib.Obj",
    struct = "obj.ml",
    sig    = "Stdlib.Obj_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Sys",
        ":Stdlib.Nativeint",
        ":Stdlib.Int32",
    ],
)

stdlib_signature(
    name = "Stdlib.Obj_cmi",
    src  = "obj.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Int32_cmi"]
)

stdlib_module(
    name   = "Stdlib.Oo",
    struct = "oo.ml",
    sig    = "Stdlib.Oo_cmi",
    opts = select({
        "//config/target/executor:vm_executor?": [
            # preserve structure sharing in Oo.copy (PR#9767)
            "-no-principal"
        ],
        "//conditions:default": []
    }),
    stdlib_deps   = [
        ":CamlinternalOO",
    ],
)

stdlib_signature(
    name = "Stdlib.Oo_cmi",
    src  = "oo.mli",
    opts = SIG_OPTS + [
        "-no-principal" ## Only place this flag is used
    ],
    stdlib_deps   = [":CamlinternalOO_cmi"]
)

stdlib_module(
    name   = "Stdlib.Option",
    struct = "option.ml",
    sig    = "Stdlib.Option_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Seq",
    ],
)

stdlib_signature(
    name = "Stdlib.Option_cmi",
    src  = "option.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Seq_cmi"]
)

stdlib_module(
    name   = "Stdlib.Out_channel",
    struct = "out_channel.ml",
    sig    = "Stdlib.Out_channel_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [":Stdlib.Fun"],
)

stdlib_signature(
    name = "Stdlib.Out_channel_cmi",
    src  = "out_channel.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib_cmi"],
)

stdlib_module(
    name   = "Stdlib.Parsing",
    struct = "parsing.ml",
    sig    = "Stdlib.Parsing_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Obj",
        ":Stdlib.Lexing",
        ":Stdlib.Array",
        ":Stdlib"
    ],
)

stdlib_signature(
    name = "Stdlib.Parsing_cmi",
    src  = "parsing.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Obj_cmi",
        ":Stdlib.Lexing_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.Pervasives",
    struct = "pervasives.ml",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":CamlinternalFormatBasics",
        ## (LargeFile)
    ],
)
# bootstrap_implicit_signature(
#     name    = "Stdlib.Parsing_cmi",
#     module  = "parsing.ml",
#     visibility = ["//visibility:public"]
# )

stdlib_module(
    name   = "Stdlib.Printexc",
    struct = "printexc.ml",
    sig    = "Stdlib.Printexc_cmi",
    opts = MODULE_OPTS,
    warnings = {"disable": ["missing-record-field-pattern"]},
    stdlib_deps   = [
        ":Stdlib",
        ":Stdlib.Array",
        ":Stdlib.Atomic",
        ":Stdlib.Buffer",
        ":Stdlib.Obj",
        ":Stdlib.Printf",
    ],
)

stdlib_signature(
    name = "Stdlib.Printexc_cmi",
    src  = "printexc.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Obj_cmi"]
)

stdlib_module(
    name   = "Stdlib.Printf",
    struct = "printf.ml",
    sig    = "Stdlib.Printf_cmi",
    opts = select({
        "//config/target/executor:vm_executor?": ["-w", "+A"],
        "//conditions:default": []
    }),
    warnings = select({
        "//config/target/executor:vm_executor?":
        {"disable": ["fragile-match"]},
        "//conditions:default": {}
    }),
    stdlib_deps   = [
        # ":CamlinternalFormatBasics",
        ":CamlinternalFormat",
        ":Stdlib.Buffer",
    ],
)

stdlib_signature(
    name = "Stdlib.Printf_cmi",
    src  = "printf.mli",
    opts = select({
        "//config/target/executor:vm_executor?": ["-w", "+A"],
        "//conditions:default": []
    }),
    warnings = select({
        "//config/target/executor:vm_executor?":
        {"disable": ["fragile-match"]},
        "//conditions:default": {}
    }),
    stdlib_deps   = [":Stdlib.Buffer_cmi"]
)

stdlib_module(
    name   = "Stdlib.Queue",
    struct = "queue.ml",
    sig    = "Stdlib.Queue_cmi",
    opts = MODULE_OPTS,
    warnings = {"disable": ["missing-record-field-pattern"]},
    stdlib_deps   = [
        ":Stdlib",
        ":Stdlib.Seq",
    ],
)

stdlib_signature(
    name = "Stdlib.Queue_cmi",
    src  = "queue.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Seq_cmi"]
)

stdlib_module(
    name   = "Stdlib.Random",
    struct = "random.ml",
    sig    = "Stdlib.Random_cmi",
    opts = MODULE_OPTS,
    warnings = {"disable": ["open-shadow-identifier"]},
    stdlib_deps   = [
        ":Stdlib",
        ":Stdlib.Array",
        ":Stdlib.Bytes",
        ":Stdlib.Bigarray",
        # ":Stdlib.Char",
        ":Stdlib.Digest",
        ":Stdlib.Domain",
        ":Stdlib.Int",
        ":Stdlib.Int32",
        ":Stdlib.Int64",
        ":Stdlib.Nativeint",
        ":Stdlib.String",
    ],
)

stdlib_signature(
    name = "Stdlib.Random_cmi",
    src  = "random.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Nativeint_cmi",
        ":Stdlib.Int64_cmi",
        ":Stdlib.Int32_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.Result",
    struct = "result.ml",
    sig    = "Stdlib.Result_cmi",
    opts = MODULE_OPTS,
    warnings = {"disable": ["fragile-match"]},
    stdlib_deps   = [
        ":Stdlib.Seq",
        # ":Stdlib"
    ],
)

stdlib_signature(
    name = "Stdlib.Result_cmi",
    src  = "result.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Seq_cmi"]
)

stdlib_module(
    name   = "Stdlib.Scanf",
    struct = "scanf.ml",
    sig    = "Stdlib.Scanf_cmi",
    opts = select({
        ##FIXME: detect target .cmx or .cmo
        # "//config/target/emitter:vm_emitter?": ["-w", "+A"],
        # "//config/target/emitter:sys_emitter?": ["-inline", "9"],
        "//conditions:default": []
    }),
    warnings = select({
        "//config/target/emitter:vm_emitter?":
        {"disable": ["fragile-match"]},
        "//conditions:default": {}
    }),
    stdlib_deps   = [
        ":Stdlib",
        ":CamlinternalFormatBasics",
        ":CamlinternalFormat",
        ":Stdlib.Buffer",
        ":Stdlib.Bytes",
        ":Stdlib.Int",
        ":Stdlib.List",
        ":Stdlib.Printf",
        ":Stdlib.String",
    ],
)

stdlib_signature(
    name  = "Stdlib.Scanf_cmi",
    src   = "scanf.mli",
    opts  = SIG_OPTS,
    warnings = {"disable": ["fragile-match"]},
    stdlib_deps  = [":Stdlib_cmi"]
)

stdlib_module(
    name   = "Stdlib.Semaphore",
    struct = "semaphore.ml",
    sig    = "Stdlib.Semaphore_cmi",
    opts   = MODULE_OPTS,
    # + select({
    #     mode:native  ["-inline", 9]
    # })
    stdlib_deps   = [
        ":Stdlib.Condition",
        ":Stdlib.Mutex",
    ],
)

stdlib_signature(
    name  = "Stdlib.Semaphore_cmi",
    src   = "semaphore.mli",
    opts  = SIG_OPTS,
)

stdlib_module(
    struct = "seq.ml",
    name   = "Stdlib.Seq",
    sig    = "Stdlib.Seq_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Atomic",
        ":Stdlib.Either",
        ":Stdlib.Lazy"
    ],
)

stdlib_signature(
    name = "Stdlib.Seq_cmi",
    src  = "seq.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib_cmi",
        ":Stdlib.Either_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.Set",
    struct = "set.ml",
    sig    = "Stdlib.Set_cmi",
    opts = MODULE_OPTS,
    warnings = {"disable": [
        "fragile-match",
        "missing-record-field-pattern"
    ]},
    stdlib_deps   = [
        ":Stdlib.Seq",
        ":Stdlib.List",
    ],
)

stdlib_signature(
    name = "Stdlib.Set_cmi",
    src  = "set.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Seq_cmi"]
)

stdlib_module(
    name   = "Stdlib.Stack",
    struct = "stack.ml",
    sig    = "Stdlib.Stack_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Seq",
        ":Stdlib.List",
    ],
)

stdlib_signature(
    name = "Stdlib.Stack_cmi",
    src  = "stack.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Seq_cmi"],
)

stdlib_module(
    name   = "Stdlib.StdLabels",
    struct = "stdLabels.ml",
    sig    = "Stdlib.StdLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    stdlib_deps   = [
        ":Stdlib.StringLabels",
        ":Stdlib.ListLabels",
        ":Stdlib.BytesLabels",
        ":Stdlib.ArrayLabels",
    ],
    visibility = ["//testsuite:__subpackages__"]
)

stdlib_signature(
    name = "Stdlib.StdLabels_cmi",
    src  = "stdLabels.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.StringLabels_cmi",
        ":Stdlib.ListLabels_cmi",
        ":Stdlib.BytesLabels_cmi",
        ":Stdlib.ArrayLabels_cmi",
    ],
)

stdlib_module(
    name   = "Stdlib.Stream",
    struct = "stream.ml",
    sig    = "Stdlib.Stream_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":CamlinternalLazy",
        ":Stdlib.String",
        ":Stdlib.List",
        ":Stdlib.Lazy",
        ":Stdlib.Bytes",
    ],
)

stdlib_signature(
    name = "Stdlib.Stream_cmi",
    src  = "stream.mli",
    opts = SIG_OPTS,
)

stdlib_module(
    name   = "Stdlib.String",
    struct = "string.ml",
    sig    = "Stdlib.String_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Bytes",
    ],
)

stdlib_signature(
    name = "Stdlib.String_cmi",
    src  = "string.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Seq_cmi",
        ":Stdlib.Uchar_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.StringLabels",
    struct = "stringLabels.ml",
    sig    = "Stdlib.StringLabels_cmi",
    opts = MODULE_OPTS + LABEL_OPTS,
    stdlib_deps   = [
        ":Stdlib.String",
    ],
)

stdlib_signature(
    name = "Stdlib.StringLabels_cmi",
    src  = "stringLabels.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [
        ":Stdlib.Seq_cmi",
        ":Stdlib.Uchar_cmi"
    ],
)

stdlib_module(
    name   = "Stdlib.Sys",
    struct = "sys.ml",
    sig    = "Stdlib.Sys_cmi",
    # sig    = select({
    #     "//config:sig_src?"   : "sys.mli",
    #     "//conditions:default": ":Stdlib.Sys_cmi"
    # }),
    # stdlib_deps    = select({
    #     "//config:sig_src?"   : ["//stdlib:Stdlib"],
    #     "//conditions:default": []
    # }),
    opts = MODULE_OPTS,
    stdlib_deps = [":Stdlib"]
)

stdlib_signature(
    name = "Stdlib.Sys_cmi",
    src  = "sys.mli",
    stdlib_deps = [":Stdlib_cmi"]
)

stdlib_module(
    name   = "Stdlib.Uchar",
    struct = "uchar.ml",
    sig    = "Stdlib.Uchar_cmi",
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Char",
    ],
)

stdlib_signature(
    name = "Stdlib.Uchar_cmi",
    src  = "uchar.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Char_cmi"]
)

stdlib_module(
    name   = "Stdlib.Unit",
    struct = "unit.ml",
    # sig    = "Stdlib.Unit_cmi",
    ## NOTE: compiling with --//config:sig_src requires
    ## "//stdlib:Stdlib" in stdlib_deps
    sig    = select({
        "//config:sig_src?"   : "unit.mli",
        "//conditions:default": "Stdlib.Unit_cmi"
    }),
    stdlib_deps    = select({
        "//config:sig_src?"   : ["//stdlib:Stdlib"],
        "//conditions:default": []
    }) + [":Stdlib"],
    opts = MODULE_OPTS,
)

stdlib_signature(
    name = "Stdlib.Unit_cmi",
    src  = "unit.mli",
    opts = SIG_OPTS,
)

stdlib_module(
    name   = "Stdlib.Weak",
    struct = "weak.ml",
    # sig    = "Stdlib.Weak_cmi",
    sig    = select({
        "//config:sig_src?"   : "weak.mli",
        "//conditions:default": ":Stdlib.Weak_cmi"
    }),
    opts = MODULE_OPTS,
    stdlib_deps   = [
        ":Stdlib.Sys",
        ":Stdlib.Obj",
        ":Stdlib.Int",
        ":Stdlib.Array",
        ":Stdlib.Hashtbl",
        ## (H)
    ],
)

stdlib_signature(
    name = "Stdlib.Weak_cmi",
    src  = "weak.mli",
    opts = SIG_OPTS,
    stdlib_deps   = [":Stdlib.Hashtbl_cmi"],
)

################################################################
## cmigroup used by `//promote` targets
# filegroup(
#     name = "cmigroup",
#     srcs = [
#         ":Stdlib.Arg_cmi",
#         ":Stdlib.ArrayLabels_cmi",
#         ":Stdlib.Array_cmi",
#         ":Stdlib.Atomic_cmi",
#         ":Stdlib.Bigarray_cmi",
#         ":Stdlib.Bool_cmi",
#         ":Stdlib.Buffer_cmi",
#         ":Stdlib.BytesLabels_cmi",
#         ":Stdlib.Bytes_cmi",
#         ":Stdlib.Callback_cmi",
#         ":CamlinternalFormatBasics_cmi",
#         ":CamlinternalFormat_cmi",
#         ":CamlinternalLazy_cmi",
#         ":CamlinternalMod_cmi",
#         ":CamlinternalOO_cmi",
#         ":Stdlib.Char_cmi",
#         ":Stdlib.Complex_cmi",
#         ":Stdlib.Condition_cmi",
#         ":Stdlib.Digest_cmi",
#         ":Stdlib.Either_cmi",
#         ":Stdlib.Ephemeron_cmi",
#         ":Stdlib.Filename_cmi",
#         ":Stdlib.Float_cmi",
#         ":Stdlib.Format_cmi",
#         ":Stdlib.Fun_cmi",
#         ":Stdlib.Gc_cmi",
#         ":Stdlib.Hashtbl_cmi",
#         ":Stdlib.In_channel_cmi",
#         ":Stdlib.Int32_cmi",
#         ":Stdlib.Int64_cmi",
#         ":Stdlib.Int_cmi",
#         ":Stdlib.Lazy_cmi",
#         ":Stdlib.Lexing_cmi",
#         ":Stdlib.ListLabels_cmi",
#         ":Stdlib.List_cmi",
#         ":Stdlib.Map_cmi",
#         ":Stdlib.Marshal_cmi",
#         ":Stdlib.MoreLabels_cmi",
#         ":Stdlib.Mutex_cmi",
#         ":Stdlib.Nativeint_cmi",
#         ":Stdlib.Obj_cmi",
#         ":Stdlib.Oo_cmi",
#         ":Stdlib.Option_cmi",
#         ":Stdlib.Out_channel_cmi",
#         ":Stdlib.Parsing_cmi",
#         ":Stdlib.Printexc_cmi",
#         ":Stdlib.Printf_cmi",
#         ":Stdlib.Queue_cmi",
#         ":Stdlib.Random_cmi",
#         ":Stdlib.Result_cmi",
#         ":Stdlib.Scanf_cmi",
#         ":Stdlib.Semaphore_cmi",
#         ":Stdlib.Seq_cmi",
#         ":Stdlib.Set_cmi",
#         ":Stdlib.Stack_cmi",
#         ":Stdlib.StdLabels_cmi",
#         ":Stdlib.StringLabels_cmi",
#         ":Stdlib.String_cmi",
#         ":Stdlib.Sys_cmi",
#         ":Stdlib.Uchar_cmi",
#         ":Stdlib.Unit_cmi",
#         ":Stdlib.Weak_cmi",
#     ],
#     visibility = ["//promote:__pkg__"]
# )

################################################################
  ################  Module: Std_exit    ################
################################################################
## Module Std_exit is an "executive" module - it exports no symbols,
## and is used in executables for its side-effects. The bytecode
## compiler inserts module Std_exit at the end of every executable.

## (I.e. it is not required for building native executables?)

## Its signature is empty (it exports no symbols), and its structfile
## contains a single line of code:

# (* Ensure that [at_exit] functions are called at the end of every program *)
# let _ = do_at_exit()

# The module itself has no external dependencies, but it does depend
# on the internal Pervasives module, so it must be NOT be compiled
# with '-nopervasives'.

## Special case: our convention is the normalize file names to match
## canical module names. In this case that would yield Std_exit; but
## the compilers are hard-coded to look for 'std_exit'. So this rule
## special cases this.

kernel_signature(
    name = "Std_exit_cmi",
    src  = "std_exit.mli",
    opts = ["-nopervasives"]
)

kernel_module(
    name   = "Std_exit",
    struct = "std_exit.ml",
    sig    = ":Std_exit_cmi",
    ## std_exit depends on 'do_at_exit' which is defined in Stdlib
    stdlib_deps   = [":Stdlib"]
)

kernel_module_cmx(
    name   = "Std_exit.cmx",
    struct = "std_exit.ml",
    sig    = ":Std_exit_cmi",
    stdlib_deps = [":Stdlib"]
)

################
mustache(
    name = "listmli",
    out  = "list.mli",
    json = "empty.json",
    template = "list.mli.mustache"
)

mustache(
    name = "listLabelsmli",
    out  = "listLabels.mli",
    json = "LABELS.json",
    template = "list.mli.mustache"
)
