load("@bazel_skylib//rules:common_settings.bzl",
     "bool_flag", "bool_setting",
     "string_flag",
     "string_list_flag")

load("//bzl/rules:config_cc_toolchain.bzl", "config_cc_toolchain")
load("//bzl/rules:config_sys.bzl", "config_sys")

load("//bzl:rules.bzl",
     "compiler_module",
     "compiler_signature",
     "mustache"
)
package(default_visibility = ["//visibility:public"])

compiler_signature(
    name = "Config_cmi",
    src  = "config.mli",
    deps   = ["//stdlib:Stdlib"],
    visibility = [
        "//otherlibs/dynlink:__pkg__",
        "//utils:__pkg__",
    ]
)

compiler_module(
    name   = "Config",
    struct = "config.ml",
    sig    = "Config_cmi",
    deps   = [ # [
        # "//config:Config_cc",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Printf",
        "//stdlib:Stdlib.Option", # if not bootstrapping?
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Sys",

        # "//stdlib"
    ],
    visibility = [
        "//asmcomp:__subpackages__",
        "//bytecomp:__pkg__",
        "//driver:__pkg__",
        "//file_formats:__pkg__",
        "//lambda:__pkg__",
        "//middle_end:__subpackages__",
        "//otherlibs/dynlink:__pkg__",
        "//parsing:__pkg__",
        "//tools:__pkg__",
        "//toplevel:__subpackages__",
        "//typing:__pkg__",
        "//utils:__pkg__",
        "//compilerlibs:__pkg__"
    ]
)

## TODO: custom rule, to extract stdlib dir w/workdir and insert into
## Config. a mustache rule won't do since the stdlib dir changes with
## each stage of the bootstrap? Or figure out how to make the mustache
## rule depend on //stdlib. More generally the Config should reflect
## the configuration of the current build stage, since additional
## config settings may depend on boot stage. With the makefiles we get
## one Config, derived from ./configure.
#
## One option would be to convert config.ml.json itself to a template
## with "standard_library_default": "{{stdlib_dir}}". Then we would
## need to run mustache twice, once to generate config.ml.json, then
## to generate config.ml. Or for the first step we could use
## ctx.actions.expand_template.
mustache(
    name = "__config_ml__",
    out      = "config.ml",
    template = "config.ml.mustache",
    json     = "config.ml.json",
    # stdlib = "//stdlib"
)

compiler_module(
    name   = "Config_cc_toolchain",
    struct = "config_cc_toolchain.ml",
    deps   = ["//stdlib:Stdlib"]
)

mustache(
    name = "__config_cc_ml__",
    out  = "config_cc_toolchain.ml",
    json = "config_cc_toolchain.json",
    template = "config_cc_toolchain.ml.mustache"
)

config_cc_toolchain(
    name = "config.cc_toolchain",
    out  = "config_cc_toolchain.json"
)

config_sys(
    name = "config.sys",
    out  = "config_sys.json",
)

        ## GLOBAL CONFIGURABLE DEFAULTS
        # _debug           = attr.label(default = "@ocaml//debug"),
        # _cmt             = attr.label(default = "@ocaml//cmt"),
        # _keep_locs       = attr.label(default = "@ocaml//keep-locs"),
        # _noassert        = attr.label(default = "@ocaml//noassert"),
        # _opaque          = attr.label(default = "@ocaml//opaque"),
        # _short_paths     = attr.label(default = "@ocaml//short-paths"),
        # _strict_formats  = attr.label(default = "@ocaml//strict-formats"),
        # _strict_sequence = attr.label(default = "@ocaml//strict-sequence"),
        # _verbose         = attr.label(default = "@ocaml//verbose"),


string_flag(name = "target_host",
            values = ["vm", "sys", "amd64", "arm64"],
            build_setting_default = "vm")

string_list_flag(name = "manifest", build_setting_default = [])

bool_flag( name = "debug", build_setting_default = False)
config_setting(name = "debug?", flag_values = {":debug": "True"})

bool_flag( name = "instrumented", build_setting_default = False)
config_setting(name = "instrumented?", flag_values = {":instrumented": "True"})

bool_flag( name = "bin-annot", build_setting_default = True)
config_setting(name = "bin-annot?", flag_values = {":bin-annot": "True"})

bool_flag( name = "principal", build_setting_default = True)
config_setting(name = "principal?", flag_values = {":principal": "True"})

bool_flag( name = "sig_src", build_setting_default = False)
config_setting(name = "sig_src?", flag_values = {":sig_src": "True"})

bool_flag( name = "absname", build_setting_default = True)
config_setting(name = "absname?", flag_values = {":absname": "True"})

label_flag( name = "camlheaders", build_setting_default = "//stdlib:camlheaders")

label_flag( name = "primitives",
            build_setting_default = "//runtime:primitives")

string_list_flag(name = "warnings",
                 build_setting_default = [
                     # "-w", "+a-4-9-41-42-44-45-48",
                     "-warn-error", "+A"])

config_setting(
    name = "macos_fastbuild?",
    values = {"compilation_mode": "fastbuild"},
    constraint_values = [
        "@platforms//os:macos",
    ]
)

bool_flag( name = "verbose", build_setting_default = False)

################################################################
##FIXME: what is the optimal way to select for flambda?
bool_flag(
    name = "flambda",
    build_setting_default = False,
    visibility = ["//visibility:public"]
)
config_setting(
    name = "flambda?",
    flag_values = {":flambda": "True"},
)

################################################################
config_setting(
    name = "pic",
    constraint_values = [
        # "//config/pic" blah blah
        "@platforms//os:linux",
    ]
)
