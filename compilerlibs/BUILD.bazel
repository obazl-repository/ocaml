load("//bzl:rules.bzl",
     "bootstrap_archive",
     "bootstrap_library")

# COMMON_CMI = $(UTILS_CMI) $(PARSING_CMI) $(TYPING_CMI) $(LAMBDA_CMI) $(COMP_CMI)

# COMMON = $(UTILS) $(PARSING) $(TYPING) $(LAMBDA) $(COMP)

## no //middle_end stuff:
# bootstrap_library(
bootstrap_archive(
    name = "ocamlcommon",
    mode = "bytecode",
    opts = ["-linkall"],
    manifest  = [
        "//utils:ocamlcommon",
        "//parsing:ocamlcommon",
        "//typing:ocamlcommon",
        "//lambda:ocamlcommon",

        ## COMP = [
        "//bytecomp:ocamlcommon",
        "//driver:ocamlcommon",

        # "//file_formats:ocamlcommon",
        #  ]
    ],
    visibility = ["//:__pkg__"]
)

################
# compilerlibs/ocamlbytecomp.cma: $(BYTECOMP_CMI) $(BYTECOMP)
# 	$(CAMLC) -a -o $@ $(BYTECOMP)
bootstrap_archive(
    name = "ocamlbytecomp",
    manifest = [
        "//bytecomp:ocamlbytecomp",
        # "//bytecomp:ocamlbytecomp_cmi",
        "//driver:ocamlbytecomp",
    ],
    visibility = ["//:__pkg__"]
)

################
# compilerlibs/ocamlbytecomp.cmxa: $(BYTECOMP_CMI) $(BYTECOMP:.cmo=.cmx)
# 	$(CAMLOPT) -a $(OCAML_NATDYNLINKOPTS) -o $@ $(BYTECOMP:.cmo=.cmx)

##################
# ASMCOMP = \
#   $(ARCH_SPECIFIC_ASMCOMP) \
#   asmcomp/arch.cmo \
#   ...
# MIDDLE_END = \
#   middle_end/internal_variable_names.cmo \
#   ...
# OPTCOMP = $(MIDDLE_END) $(ASMCOMP)
# OPTCOMP_CMI = $(MIDDLE_END_CMI) $(ASMCOMP_CMI)
# compilerlibs/ocamloptcomp.cma: $(OPTCOMP_CMI) $(OPTCOMP)
# 	$(CAMLC) -a -o $@ $(OPTCOMP)

# bootstrap_library(
bootstrap_archive(
    name    = "ocamloptcomp",
    visibility = ["//visibility:public"],
    opts = ["-linkall"],
    manifest = [
        "//asmcomp:ocamloptcomp",
        "//middle_end:ocamloptcomp",
    ],
)

