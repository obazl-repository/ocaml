load("//test:rules.bzl",
     "test_archive",
     "test_executable",
     "vv_test_executable",
     "vs_test_executable",
     "ss_test_executable",
     "sv_test_executable",
     "test_library",
     "test_module",
     "test_signature",

     "compile_fail_test",
     "expect_test",
     "inline_expect_test",
     "ocaml_test",
)

test_suite(
    name = "tests",
    tests = [
        ":arrays_test",
        ":bigints_test",
        ":boxedints_test",
        ":constprop_test",
        ":divint_test",
        ":equality_test",
        ":eval_order_1_test",
        ":eval_order_2_test",
        ":eval_order_3_test",
        ":eval_order_4_test",
        ":eval_order_6_test",
        ":eval_order_7_test",
        ":eval_order_pr10283_test",
        ":float_test",
        ":float_physical_equality_test",
        ":includestruct_test",
        ":localexn_test",
        ":localfunction_test",
        ":maps_test",
        ":min_int_test",
        ":opt_variants_test",
        ":patmatch_test",
        ":patmatch_for_multiple_test",
        ":patmatch_incoherence_test",
        ":patmatch_split_no_or_test",
        ":pr7253_test",
        ":pr7533_test",
        ":pr7657_test",
        ":recvalues_test",
        ":sets_test",
        ":stringmatch_test",
        ":switch_opts_test",
        ":tailcalls_test",
        ":trigraph_test",
        ":tuple_match_test",
        # ":unit_naming_test",
        ":zero_divided_by_n_test",
    ],
)

############
## expect_test expands to: test_suite,
## expect_vv_test, expect_vs_test,
## expect_ss_test, expect_sv_test
expect_test(
    name    = "arrays_test",
    stdout  = "arrays.stdout",
    expected = "arrays.reference",
    # prologue = [
    #     ## FIXME: these are all deps of :Arrays;
    #     ## they should be added automatically.
    #     "//stdlib:primitives",
    #     "//stdlib:Stdlib",
    #     "//stdlib:Stdlib.Array",
    #     "//stdlib:Stdlib.Buffer",
    #     "//stdlib:Stdlib.Bytes",
    #     "//stdlib:Stdlib.Char",
    #     "//stdlib:Stdlib.Gc",
    #     "//stdlib:Stdlib.Atomic",
    #     "//stdlib:Stdlib.Int",
    #     "//stdlib:Stdlib.List",
    #     "//stdlib:Stdlib.Map",
    #     "//stdlib:Stdlib.Obj",
    #     "//stdlib:Stdlib.Sys",
    #     "//stdlib:Stdlib.Printf",
    #     "//stdlib:Stdlib.Seq",
    #     "//stdlib:Stdlib.Lazy",
    #     "//stdlib:Stdlib.String",
    #     "//stdlib:Stdlib.Uchar",
    # ],
    test_executable = ":arrays",
    timeout = "short",
)

## test_executable expands to <x>_test_executable and sh_binary
## targets (runners), where <x> = vv | vs | ss | sv indicates the
## compiler used to build the code; and sh_binary targets for vv, sv
## generated names. The sh_binary targets (arrays.vv.byte.sh,
## arrays.sv.byte.sh) may be used to run the vm executables from the
## cmd line (using 'bazel run' only). Test rules depend on the
## executable targets but not the sh_binary ones.

## NB: the arrays test emits nothing to stdout, so we demonstrate the
## expansion below, for bigints.ml, which does write to stdout.
test_executable(
    name    = "arrays.vv.byte",
    main    = ":Arrays",
)

test_module(
    name   = "Arrays",
    struct = "arrays.ml",
    stdlib_deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": ["//stdlib:Stdlib.Gc"]
    })
)

############
expect_test(
    name    = "bigints_test",
    stdout  = "bigints.stdout",
    expected = "bigints.reference",
    opts   = ["-nopervasives", "-open", "Stdlib"],
    # prologue = select({
    #     "//testsuite/tests:with-stdlib?":["//stdlib"],
    #     "//conditions:default": [
    #         "//stdlib:CamlinternalFormatBasics",
    #         "//stdlib:Stdlib",
    #         "//stdlib:Stdlib.Sys"
    #     ]
    # }),
    test_executable = ":Bigints",
)

# test_executable(
#     name    = "bigints",
#     main    = ":Bigints",
# )

## expansion:
vv_test_executable(
    ## note the trailing '_' in the name; this is so that the
    ## unadorned name can be used for the runnable (sh_binary) target
    ## below.
    name    = "bigints.vv.byte_",
    main    = ":Bigints",
)
## to run the vv.byte executable:
sh_binary(
    name = "bigints.vv.byte",
    srcs = ["//test/rules:test_executable.sh"],
    env  = select({
        "//test:verbose?": {"VERBOSE": "true"},
        "//conditions:default": {"VERBOSE": "false"}
    }),
    args = ["$(rootpath //runtime:ocamlrun)",
            "$(rootpath :bigints.vv.byte_)"],
    data = ["//runtime:ocamlrun",
            ":bigints.vv.byte_"],
    deps = ["@bazel_tools//tools/bash/runfiles"]
)

vs_test_executable(
    name    = "bigints.vs.opt",
    main    = ":Bigints",
)
ss_test_executable(
    name    = "bigints.ss.opt",
    main    = ":Bigints",
)
sv_test_executable(
    name    = "bigints.sv.byte_",
    main    = ":Bigints",
)
## to run the vv.byte executable:
sh_binary(
    name = "bigints.sv.byte",
    srcs = ["//test/rules:test_executable.sh"],
    env  = select({
        "//test:verbose?": {"VERBOSE": "true"},
        "//conditions:default": {"VERBOSE": "false"}
    }),
    args = ["$(rootpath //runtime:ocamlrun)",
            "$(rootpath :bigints.sv.byte_)"],
    data = ["//runtime:ocamlrun",
            ":bigints.sv.byte_"],
    deps = ["@bazel_tools//tools/bash/runfiles"]
)

test_module(
    name   = "Bigints",
    struct = "bigints.ml",
    open   = ["//stdlib:Stdlib"],
    stdlib_deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": ["//stdlib:Stdlib.Sys"]
    })
)

############
expect_test(
    name    = "boxedints_test",
    stdout  = "boxedints.stdout",
    expected = "boxedints.reference",
    test_executable    = ":Boxedints",
)

test_executable(
    name    = "boxedints",
    main    = ":Boxedints",
)

test_module(
    name   = "Boxedints",
    struct = "boxedints.ml",
    open   = ["//stdlib:Stdlib"],
    stdlib_deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": [
            "//stdlib:Stdlib.Hashtbl",
            "//stdlib:Stdlib.List",
            "//stdlib:Stdlib.Printf"
        ]
    })
)

################################################################
test_module( # not a test, used by unit_naming_test
    name   = "CamlCase",
    struct = "camlCase.ml",
)
################################################################

################################################################
## with C Preprocessing
# (* TEST
#    flags = "-pp '${c_preprocessor}'"
#    ocaml_filetype_flag = "-impl"
#    * bytecode
#      compare_programs = "false"
#    * native
# *)

############
expect_test(
    name    = "constprop_test",
    stdout  = "constprop.stdout",
    expected = "constprop.ml.reference",
    test_executable    = ":Constprop",
)

test_module(
    name   = "Constprop",
    struct = "constprop.ml.c",
    opts   = ["-pp", "cpp"],
    open   = ["//stdlib:Stdlib"],
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": [
            "//stdlib:Stdlib.Int64",
            "//stdlib:Stdlib.List",
            "//stdlib:Stdlib.Printf",
        ]
    })
)

################################################################

############
expect_test(
    name     = "divint_test",
    stdout   = "divint.stdout",
    expected = "divint.reference",
    test_executable     = ":Divint",
)

test_module(
    name   = "Divint",
    struct = "divint.ml",
    open   = ["//stdlib:Stdlib"],
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": [
            "//stdlib:Stdlib.List",
            "//stdlib:Stdlib.Printf"
        ]
    })
)

############
expect_test(
    name    = "equality_test",
    stdout  = "equality.stdout",
    expected = "equality.reference",
    test_executable    = ":Equality",
)

test_executable(
    name    = "equality",
    main    = ":Equality",
)

test_module(
    name   = "Equality",
    struct = "equality.ml",
    open   = ["//stdlib:Stdlib"],
    stdlib_deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": ["//stdlib:Stdlib.Fun"]
    })
)

############
expect_test(
    name    = "eval_order_1_test",
    stdout  = "eval_order_1.stdout",
    expected = "eval_order_1.reference",
    test_executable    = ":Eval_order_1",
)

test_module(
    name   = "Eval_order_1",
    struct = "eval_order_1.ml",
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": ["//stdlib:Stdlib.Printf"]
    })
)

############
expect_test(
    name    = "eval_order_2_test",
    stdout  = "eval_order_2.stdout",
    expected = "eval_order_2.reference",
    test_executable    = ":Eval_order_2",
)

test_module(
    name   = "Eval_order_2",
    struct = "eval_order_2.ml",
    deps   = ["//stdlib:Primitives"]
)

############
expect_test(
    name    = "eval_order_3_test",
    stdout  = "eval_order_3.stdout",
    expected = "eval_order_3.reference",
    test_executable    = ":Eval_order_3",
)

test_module(
    name   = "Eval_order_3",
    struct = "eval_order_3.ml",
    open   = ["//stdlib:Stdlib"],
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": ["//stdlib:Stdlib.Printf"]
    })
)

############
expect_test(
    name    = "eval_order_4_test",
    stdout  = "eval_order_4.stdout",
    expected = "eval_order_4.reference",
    test_executable    = ":Eval_order_4",
)

test_module(
    name   = "Eval_order_4",
    struct = "eval_order_4.ml",
    deps   = ["//stdlib:Primitives"]
)

############
expect_test(
    name    = "eval_order_6_test",
    stdout  = "eval_order_6.stdout",
    expected = "eval_order_6.reference",
    test_executable    = ":Eval_order_6",
)

test_module(
    name   = "Eval_order_6",
    struct = "eval_order_6.ml",
    open   = ["//stdlib:Stdlib"],
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": ["//stdlib:Stdlib.Int"]
    })
)

############
expect_test(
    name    = "eval_order_7_test",
    stdout  = "eval_order_7.stdout",
    expected = "eval_order_7.reference",
    test_executable    = ":Eval_order_7",
)

test_module(
    name   = "Eval_order_7",
    struct = "eval_order_7.ml",
    deps   = ["//stdlib:Primitives"],
    open   = ["//stdlib:Stdlib"],
)

############
expect_test(
    name    = "eval_order_pr10283_test",
    stdout  = "eval_order_pr10283.stdout",
    expected = "eval_order_pr10283.reference",
    test_executable    = ":Eval_order_pr10283",
)
test_module(
    name   = "Eval_order_pr10283",
    struct = "eval_order_pr10283.ml",
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": ["//stdlib:Stdlib.Printf"]
    })
)

############
expect_test(
    name    = "float_test",
    stdout  = "float.stdout",
    expected = "float.reference",
    test_executable    = ":Float",
)

test_module(
    name   = "Float",
    struct = "float.ml",
    open   = ["//stdlib:Stdlib"],
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": ["//stdlib:Stdlib.Printf"]
    })
)

############
expect_test(
    name    = "float_physical_equality_test",
    stdout  = "float_physical_equality.stdout",
    expected = "float_physical_equality.reference",
    test_executable    = ":Float_physical_equality",
)

test_module(
    name   = "Float_physical_equality",
    struct = "float_physical_equality.ml",
    deps   = ["//stdlib:Primitives"]
)

############
expect_test(
    name    = "includestruct_test",
    stdout  = "includestruct.stdout",
    expected = "includestruct.reference",
    test_executable    = ":Includestruct",
)

test_module(
    name   = "Includestruct",
    struct = "includestruct.ml",
    open   = ["//stdlib:Stdlib"],
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": [
            "//stdlib:CamlinternalOO",
            "//stdlib:Stdlib.Printexc",
            "//stdlib:Stdlib.Printf",
        ]
    })
)

############
expect_test(
    name    = "localexn_test",
    stdout  = "localexn.stdout",
    expected = "localexn.reference",
    test_executable    = ":Localexn",
)

test_module(
    name   = "Localexn",
    struct = "localexn.ml",
    deps   = ["//stdlib:Primitives"]
)

############
expect_test(
    name    = "localfunction_test",
    stdout  = "localfunction.stdout",
    expected = "localfunction.reference",
    test_executable    = ":Localfunction",
)

test_module(
    name   = "Localfunction",
    struct = "localfunction.ml",
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": ["//stdlib:Stdlib.Gc"]
    })
)

############
expect_test(
    name    = "maps_test",
    stdout  = "maps.stdout",
    expected = "maps.reference",
    test_executable    = ":Maps",
)

test_module(
    name   = "Maps",
    struct = "maps.ml",
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": [
            "//stdlib:Stdlib.Map",
            "//stdlib:Stdlib.Printf",
        ]
    })
)

############
expect_test(
    name    = "min_int_test",
    stdout  = "min_int.stdout",
    expected = "min_int.reference",
    test_executable    = ":Min_int",
)

test_module(
    name   = "Min_int",
    struct = "min_int.ml",
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": ["//stdlib:Stdlib.Int"]
    })
)

############
expect_test(
    name    = "opt_variants_test",
    stdout  = "opt_variants.stdout",
    expected = "opt_variants.reference",
    test_executable    = ":Opt_variants",
)

test_module(
    name   = "Opt_variants",
    struct = "opt_variants.ml",
    deps   = [
        "//stdlib:Stdlib.Int64",
        "//stdlib:Stdlib.Hashtbl",
        "//stdlib:Stdlib.List",
        "//stdlib:Stdlib.Map",
        "//stdlib:Stdlib.Queue",
        "//stdlib:Stdlib.Set",
        "//stdlib:Stdlib.Stack",
        "//stdlib:Stdlib.String",
        "//stdlib:Stdlib.Sys",
        "//stdlib:Stdlib.Weak",
    ]
)

############
expect_test(
    name    = "patmatch_test",
    stdout  = "patmatch.stdout",
    expected = "patmatch.reference",
    test_executable    = ":Patmatch",
)

test_module(
    name   = "Patmatch",
    struct = "patmatch.ml",
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": [
            "//stdlib:Stdlib.List",
            "//stdlib:Stdlib.Printf",
        ]
    })
)

###################
inline_expect_test(
    name = "patmatch_for_multiple_test",
    src  = "patmatch_for_multiple.ml",
    opts = ["-drawlambda", "-dlambda"], # "-pervasives"],
    deps = ["//stdlib"],
    timeout = "short",
    tags = ["inline_expect"]
)

###################
inline_expect_test(
    name = "patmatch_incoherence_test",
    src  = "patmatch_incoherence.ml",
    timeout = "short",
    tags = ["inline_expect"]
)

###################
inline_expect_test(
    name = "patmatch_split_no_or_test",
    src  = "patmatch_split_no_or.ml",
    opts = ["-nopervasives", "-dlambda"],
    timeout = "short",
    tags = ["inline_expect"]
)

############
expect_test(
    name    = "pr7253_test",
    stdout  = "pr7253.stdout",
    expected = "pr7253.reference",
    test_executable    = ":Pr7253",
)

test_module(
    name   = "Pr7253",
    struct = "pr7253.ml",
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": [
            "//stdlib:Stdlib.Printexc",
        ]
    })
)

############
expect_test(
    name    = "pr7533_test",
    stdout  = "pr7533.stdout",
    expected = "pr7533.reference",
    test_executable    = ":Pr7533",
)

test_module(
    name   = "Pr7533",
    struct = "pr7533.ml",
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": [
            "//stdlib:Stdlib.List",
            "//stdlib:Stdlib.Sys",
        ]
    })
)

############
expect_test(
    name    = "pr7657_test",
    stdout  = "pr7657.stdout",
    expected = "pr7657.reference",
    test_executable    = ":Pr7657",
)

test_module(
    name   = "Pr7657",
    struct = "pr7657.ml",
    # deps    = ["//stdlib:Primitives"]
    opts   = [
        "-no-strict-sequence",
        # "-w", "-21-5"
    ],
    deps  =["//stdlib:Primitives"]
)

############
expect_test(
    name    = "recvalues_test",
    stdout  = "recvalues.stdout",
    expected = "recvalues.reference",
    test_executable    = ":Recvalues",
)

test_module(
    name   = "Recvalues",
    struct = "recvalues.ml",
    deps   = select({
        "//testsuite/tests:with-stdlib?":["//stdlib"],
        "//conditions:default": [
            "//stdlib:Stdlib.Gc",
            "//stdlib:Stdlib.List",
        ]
    })
)

############
expect_test(
    name    = "sets_test",
    stdout  = "sets.stdout",
    expected = "sets.reference",
    test_executable    = ":Sets",
)

test_module(
    name   = "Sets",
    struct = "sets.ml",
    deps   = [
        "//stdlib:Stdlib.Set",
        "//stdlib:Stdlib.Printf",
    ]
)

############
expect_test(
    name    = "stringmatch_test",
    stdout  = "stringmatch.stdout",
    expected = "stringmatch.reference",
    test_executable    = ":Stringmatch",
)

test_module(
    name   = "Stringmatch",
    struct = "stringmatch.ml",
    deps   = [
        "//stdlib:Stdlib.String",

    ]
)

############
expect_test(
    name    = "switch_opts_test",
    stdout  = "switch_opts.stdout",
    expected = "switch_opts.reference",
    test_executable    = ":Switch_opts",
)

test_module(
    name   = "Switch_opts",
    struct = "switch_opts.ml",
    deps   = [
        "//stdlib:Stdlib.Printf",
        "//stdlib:Stdlib.List",
    ]
)

############
expect_test(
    name    = "tailcalls_test",
    stdout  = "tailcalls.stdout",
    expected = "tailcalls.reference",
    test_executable    = ":Tailcalls",
)

test_module(
    name   = "Tailcalls",
    struct = "tailcalls.ml",
    deps   = ["//stdlib:Primitives"]
)

############
expect_test(
    name    = "trigraph_test",
    stdout  = "trigraph.stdout",
    expected = "trigraph.reference",
    test_executable = ":trigraph",
)

test_executable(
    name    = "trigraph",
    # prologue = select({
    #     "//config/ocaml/compiler/libs:archived?": ["//stdlib"],
    #     "//conditions:default": []
    # }),
    main    = ":Trigraph",
)

test_module(
    name   = "Trigraph",
    struct = "trigraph.ml",
    # if --//config/ocaml/compiler/libs:archived? is set, then use
    # _stdlib and ignore these:
    stdlib_deps = ["//stdlib:Stdlib"],
    # deps   = select({
    #     "//config/ocaml/compiler/libs:archived?": ["//stdlib"],
    #     "//conditions:default": ["//stdlib:Primitives"]
    # })
)

############
expect_test(
    name    = "tuple_match_test",
    stdout  = "tuple_match.stdout",
    expected = "tuple_match.reference",
    test_executable    = ":Tuple_match",
    # prologue = ["//stdlib:Primitives"],
    opts = ["-open", "Stdlib"]
)

test_module(
    name   = "Tuple_match",
    struct = "tuple_match.ml",
    opts   = ["-open", "Stdlib"],
    deps   = [
        "//stdlib:Stdlib",
        "//stdlib:Stdlib.Gc",
        "//stdlib:Stdlib.Printf"
    ]
)

compile_fail_test(
# test_module(
    name   = "unit_naming_test",
    struct = "unit_naming.ml",
    expected = "unit_naming.compilers.reference",
    deps   = [
        ":CamlCase"
    ],
)

############
expect_test(
    name    = "zero_divided_by_n_test",
    stdout  = "zero_divided_by_n.stdout",
    expected = "zero_divided_by_n.reference",
    test_executable    = ":Zero_divided_by_n",
)

test_module(
    name   = "Zero_divided_by_n",
    struct = "zero_divided_by_n.ml",
    opts   = ["-nopervasives"],
    deps   = ["//stdlib:Stdlib"],
)

