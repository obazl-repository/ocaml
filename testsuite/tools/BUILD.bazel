load("//tools:TOOL_RULES.bzl", "ocaml_tool_vm")

load("//bzl:rules.bzl", "cc_assemble")

load("//test:rules.bzl",
     "test_program",
     "test_library",
     "test_module",
     "test_signature",
)

load("//lex:BUILD_RULES.bzl", "run_ocamllex")

load("//config:WARNINGS.bzl", "w")

package(default_visibility = ["//testsuite/tests:__subpackages__"])

ASM_DEFINES = [
    "NATIVE_CODE",
    "TARGET_$(ARCH)",
    "MODEL_$(MODEL)",
    "SYS_$(SYSTEM)"
]

MODULE_OPTS = []
SIG_OPTS    = []

################################################################
# expect_MAIN=expect_test
# expect_PROG=$(expect_MAIN)$(EXE)
# expect_DIRS = parsing utils driver typing toplevel
# expect_OCAMLFLAGS = $(addprefix -I $(ROOTDIR)/,$(expect_DIRS))
# expect_LIBS := $(addprefix $(COMPILERLIBSDIR)/,\
#   ocamlcommon ocamlbytecomp ocamltoplevel)

# ../../boot/ocamlrun ../../ocamlc -nostdlib -I ../../stdlib -linkall -o expect_test ../../compilerlibs/ocamlcommon.cma ../../compilerlibs/ocamlbytecomp.cma ../../compilerlibs/ocamltoplevel.cma expect_test.cmo

ocaml_tool_vm( #FIXME: use compiler rule?
    name = "inline_expect",
    prologue = [
        "//stdlib",
        "//compilerlibs:ocamlcommon",
        "//bytecomp:ocamlbytecomp",
        "//toplevel:ocamltoplevel"
    ],
    main = ":Expect_test",
    opts = ["-linkall"],
    tags     = ["compiler"], # this tool is effectively a compiler
    visibility = [
        "//ocamltest:__pkg__",
        "//testsuite:__subpackages__"
    ]
)

################
# codegen_PROG = codegen$(EXE)
# codegen_DIRS = parsing utils typing middle_end bytecomp lambda asmcomp
# codegen_OCAMLFLAGS = $(addprefix -I $(ROOTDIR)/, $(codegen_DIRS)) -w +40 -g
# codegen_LIBS = $(addprefix $(COMPILERLIBSDIR)/,\
#   ocamlcommon ocamloptcomp)
# codegen_OBJECTS = $(addsuffix .cmo,\
#   parsecmmaux parsecmm lexcmm codegen_main)

################
#FIXME: use ocaml_tool?
test_program(
    name = "codegen",
    stem = "codegen",
    main = ":Codegen_main",
    # makefiles build a vm executable, we build a native executable:
    compiler = "@dev//bin:ocamlopt.opt",
    opts = ["-w", "+40", "-g"],
    prologue = [
        # "//stdlib",
        # "//compilerlibs:ocamlcommon",
        # "//asmcomp:ocamloptcomp",
        # ":Parsecmmaux",
        # ":Parsecmm",
        # ":Lexcmm",
    ],
    visibility = ["//testsuite/tests:__subpackages__"]
)

############
test_module(
    name   = "Codegen_main",
    struct = "codegen_main.ml",
    opts = MODULE_OPTS,
    warnings = [w.MISSING_MLI_70],
    deps   = [
        "//utils:ocamlcommon",
        # "//utils:Clflags",

        "//asmcomp:ocamloptcomp",
        "//compilerlibs:ocamlcommon",
        # "//asmcomp:Asmgen",
        # "//asmcomp:Emit",
        # "//asmcomp:Emitaux",
        # "//middle_end:Compilenv",


        ":Lexcmm",
        ":Parsecmm",

        ":Parsecmmaux",
        # ":Parsecmm",
        # ":Lexcmm",
    ],
    stdlib_deps = [
        "//stdlib:Stdlib.Arg",
        "//stdlib:Stdlib.Filename",
        "//stdlib:Stdlib.Format",
        "//stdlib:Stdlib.Lexing",
        "//stdlib:Stdlib.Parsing",
        "//stdlib:Stdlib.Printf",
    ]
)

################
test_module(
    name   = "Expect_test",
    struct = "expect_test.ml",
    opts = MODULE_OPTS + ["-linkall"],
    alerts = ["-unsynchronized_access"],
    warnings = [
        w.FRAGILE_MATCH_4,
        w.MISSING_RECORD_FIELD_PATTERN_9,
        w.DISAMBIGUATED_NAME_42,
        w.OPEN_SHADOW_IDENTIFIER_44,
        w.MISSING_MLI_70
    ],
    deps   = [
        "//toplevel:Toploop",
    ],
    sig_deps = ["//parsing:Parsetree_cmi"],
    libOCaml_deps = [
        "//driver:Main_args",
        "//parsing:Location",
        "//parsing:Printast",
    ],
    stdlib_deps =[
        # "//stdlib",
        "//stdlib:Stdlib.StdLabels",
    ]
)

test_module(
    name   = "Lexcmm",
    struct = "lexcmm.ml",
    opts = MODULE_OPTS,
    deps   = [
        ":Parsecmm"
    ],
    stdlib_deps =[
        "//stdlib:Stdlib.Scanf",
    ]
)

run_ocamllex(
    name = "lexcmm_ml",
    src  = "lexcmm.mll",
    out  = "lexcmm.ml",
)

test_signature(
    name = "Lexcmm_cmi",
    src  = "lexcmm.mli",
    opts = SIG_OPTS,
)

test_module(
    name   = "Parsecmm",
    struct = "parsecmm.ml",
    opts = MODULE_OPTS,
    deps   = [
        "//compilerlibs:ocamlcommon",
        "//asmcomp:ocamloptcomp",
        # "//asmcomp:Cmm",
        # "//lambda:Lambda",
        # "//parsing:Location",
        ":Parsecmmaux"
    ],
    stdlib_deps = ["//stdlib:Stdlib.Parsing"],
    warnings = [w.FRAGILE_MATCH_4, w.UNUSED_VAR_STRICT_27]
)

genrule(
    name = "parsecmm_ml",
    outs  = ["parsecmm.ml", "parsecmm.mli"],
    srcs  = [
        "parsecmm.mly",
        "//yacc:ocamlyacc"
    ],
    cmd  = " ".join([
        "$(execpath //yacc:ocamlyacc)",
        "--strict", "-q",
        "$(location parsecmm.mly) > /dev/null;",
        # "echo `ls -la lex`;",
        "cp testsuite/tools/parsecmm.ml $(RULEDIR)/;",
        "cp testsuite/tools/parsecmm.mli $(RULEDIR)/;"
    ])
)

test_module(
    name   = "Parsecmmaux",
    struct = "parsecmmaux.ml",
    sig    = "Parsecmmaux_cmi",
    opts = MODULE_OPTS,
    deps   = [
        "//compilerlibs:ocamlcommon"
        # "//lambda:Lambda",
        # "//middle_end:Backend_var",
        # "//parsing:Location",
    ],
    stdlib_deps =[
        "//stdlib:Stdlib.Hashtbl",
        "//stdlib:Stdlib.String"
    ]
)

test_signature(
    name = "Parsecmmaux_cmi",
    src  = "parsecmmaux.mli",
    opts = SIG_OPTS,
    deps   = [
        "//middle_end:Backend_var_cmi",
        "//parsing:Location_cmi",
    ]
)

################################################################
# %.$(O): %.S
# 	$(ASPP) $(OC_ASPPFLAGS) -o $@ $<
cc_assemble(
    name = "asmgen_amd64",
    src = "asmgen_amd64.S",
    defines = ASM_DEFINES,
    ## This tc provides custom MAKE vars
    toolchains = ["//profile/system/local"],
)
